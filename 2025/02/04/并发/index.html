<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Java并发不错的并发知识：https:&#x2F;&#x2F;learn.lianglianglee.com&#x2F;%e4%b8%93%e6%a0%8f&#x2F;Java%20%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2078%20%e8%ae%b2-%e5%ae%8c&#x2F;01%20%e4%b8%ba%e4%bd%95%e8%af%b4%e5%8f%aa%e6%9c%89%201%20%e7%a7%">
<meta property="og:type" content="article">
<meta property="og:title" content="并发">
<meta property="og:url" content="http://example.com/2025/02/04/%E5%B9%B6%E5%8F%91/index.html">
<meta property="og:site_name" content="Zhang&#39;Blog">
<meta property="og:description" content="Java并发不错的并发知识：https:&#x2F;&#x2F;learn.lianglianglee.com&#x2F;%e4%b8%93%e6%a0%8f&#x2F;Java%20%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2078%20%e8%ae%b2-%e5%ae%8c&#x2F;01%20%e4%b8%ba%e4%bd%95%e8%af%b4%e5%8f%aa%e6%9c%89%201%20%e7%a7%">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67cbb7d3066befcec6e0aba9.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67cbb84e066befcec6e0acc7.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67cbb8e4066befcec6e0ad8d.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67a2b8edd0e0a243d4fbdbaa.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67a2bbe7d0e0a243d4fbdcf7.png">
<meta property="og:image" content="https://pic1.imgdb.cn/item/67d288fe88c538a9b5bc72c2.png">
<meta property="article:published_time" content="2025-02-04T11:21:39.000Z">
<meta property="article:modified_time" content="2025-03-13T08:56:51.405Z">
<meta property="article:author" content="ZhangYuHao">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic1.imgdb.cn/item/67cbb7d3066befcec6e0aba9.png">


<link rel="canonical" href="http://example.com/2025/02/04/%E5%B9%B6%E5%8F%91/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2025/02/04/%E5%B9%B6%E5%8F%91/","path":"2025/02/04/并发/","title":"并发"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>并发 | Zhang'Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Zhang'Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%B9%B6%E5%8F%91"><span class="nav-number">1.</span> <span class="nav-text">Java并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%A4%A9%E7%94%9F%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">Java天生的多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">线程的优先级和守护线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.2.1.</span> <span class="nav-text">优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJava%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="nav-number">1.3.</span> <span class="nav-text">什么是Java中的线程同步？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">什么是线程安全？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%EF%BC%9FJava%E6%94%AF%E6%8C%81%E5%8D%8F%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="nav-number">1.5.</span> <span class="nav-text">什么是协程？Java支持协程吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89"><span class="nav-number">1.6.</span> <span class="nav-text">在Java中线程的生命周期如何定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%80%9A%E8%AE%AF%EF%BC%9F"><span class="nav-number">1.7.</span> <span class="nav-text">线程之间如何进行通讯？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized-%E5%92%8C-ReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.8.</span> <span class="nav-text">Synchronized 和 ReentrantLock的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A2%E7%84%B6ReentrantLock-%E5%8A%9F%E8%83%BD%E9%82%A3%E4%B9%88%E5%85%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8Synchronized%E5%91%A2%EF%BC%9F"><span class="nav-number">1.8.1.</span> <span class="nav-text">既然ReentrantLock 功能那么全，为什么还要用Synchronized呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.8.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition%E5%92%8CObject%E7%B1%BB%E9%94%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.9.</span> <span class="nav-text">Condition和Object类锁方法的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.10.</span> <span class="nav-text">如何创建多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">1.11.</span> <span class="nav-text">线程池的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.12.</span> <span class="nav-text">如何合理设置线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="nav-number">1.12.0.1.</span> <span class="nav-text">选择原则：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="nav-number">1.13.</span> <span class="nav-text">Java中有哪些拒绝策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%B9%B6%E5%8F%91%E5%BA%93%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%EF%BC%9F%E4%BB%96%E4%BB%AC%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.14.</span> <span class="nav-text">Java 并发库中提供了哪些线程池实现？他们有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84shutdown%E5%92%8CshutdownNow%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.15.</span> <span class="nav-text">线程池的shutdown和shutdownNow的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%86%85%E9%83%A8%E5%87%BA%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%BC%82%E5%B8%B8%E5%90%8E%EF%BC%8C%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E6%98%AF%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%87%BA%E4%BA%86%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="nav-number">1.16.</span> <span class="nav-text">线程池内部出现任务异常后，如何知道是哪个线程出了异常？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84DelayQueue%E5%92%8C-ScheduledThreadPool%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.17.</span> <span class="nav-text">Java中的DelayQueue和 ScheduledThreadPool有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84Timer"><span class="nav-number">1.18.</span> <span class="nav-text">Java中的Timer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Timer%E4%BD%BF%E7%94%A8"><span class="nav-number">1.18.1.</span> <span class="nav-text">Timer使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">1.18.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timer%E5%BC%8A%E7%AB%AF"><span class="nav-number">1.18.3.</span> <span class="nav-text">Timer弊端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-Timer-%E5%92%8C-Schedule"><span class="nav-number">1.18.4.</span> <span class="nav-text">关于 Timer 和 @Schedule</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8Java%E4%B8%AD%E6%8E%A7%E5%88%B6%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="nav-number">1.19.</span> <span class="nav-text">如何在Java中控制多个线程的执行顺序？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%A0%E4%BD%BF%E7%94%A8%E8%BF%87Java%E4%B8%AD%E7%9A%84%E5%93%AA%E4%BA%9B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F"><span class="nav-number">1.20.</span> <span class="nav-text">你使用过Java中的哪些阻塞队列？</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZhangYuHao"
      src="/images/111.png">
  <p class="site-author-name" itemprop="name">ZhangYuHao</p>
  <div class="site-description" itemprop="description">一个小人物的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/2567821933" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;2567821933" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:103903Zyh@gmail.com" title="E-Mail → mailto:103903Zyh@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/04/%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="并发 | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          并发
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-04 19:21:39" itemprop="dateCreated datePublished" datetime="2025-02-04T19:21:39+08:00">2025-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-13 16:56:51" itemprop="dateModified" datetime="2025-03-13T16:56:51+08:00">2025-03-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><p>不错的并发知识：<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2078%20%e8%ae%b2-%e5%ae%8c/01%20%e4%b8%ba%e4%bd%95%e8%af%b4%e5%8f%aa%e6%9c%89%201%20%e7%a7%8d%e5%ae%9e%e7%8e%b0%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%96%b9%e6%b3%95%ef%bc%9f.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2078%20%e8%ae%b2-%e5%ae%8c/01%20%e4%b8%ba%e4%bd%95%e8%af%b4%e5%8f%aa%e6%9c%89%201%20%e7%a7%8d%e5%ae%9e%e7%8e%b0%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%96%b9%e6%b3%95%ef%bc%9f.md</a></p>
<h2 id="Java天生的多线程"><a href="#Java天生的多线程" class="headerlink" title="Java天生的多线程"></a>Java天生的多线程</h2><ul>
<li>main 主线程</li>
<li>Reference Handler （引用处理的线程，强，软，弱，虚，-GC 有不同表现， -JVM深入分析）</li>
<li>Attach Listener（附加监听器。简单来说，他是jdk里边一个工具类提供的jvm进程间通信的工具。 cmd –java -version； jvm –jstack，jmp，dump）进程间的通讯）</li>
<li>Signal Dispatcher（信号分发器，我们通过cmd发送jstask，传入了jvm进程中这时候信号分发器就要发挥作用了。</li>
<li>Monitor Ctrl-Break</li>
<li>Finalizer（JVM垃圾回收相关内容，此处只做简单的介绍，只有当开始一轮垃圾收集的时候，才会开始调用finalize方法。jvm在垃圾收集的时候，会将是去引用的对象封装到Finalizer对象（Reference），放入到我们的F-queue队列中。由Finalizer现成执行inalize方法）</li>
</ul>
<h2 id="线程的优先级和守护线程"><a href="#线程的优先级和守护线程" class="headerlink" title="线程的优先级和守护线程"></a>线程的优先级和守护线程</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1-10，在线程构建的时候可以通过<code>setPriority（int）</code>方法来修改优先级，默认优先级是5，<strong>优先级高的线程分配CPU时间片的数量要多余优先级低的线程。</strong></p>
<h2 id="什么是Java中的线程同步？"><a href="#什么是Java中的线程同步？" class="headerlink" title="什么是Java中的线程同步？"></a>什么是Java中的线程同步？</h2><p><strong>线程同步</strong>是指在多项成环境下，为了避免多个线程对共享资源进行同时访问，从而引发的数据不一致问题或其他问题的一种机制。通过对关键代码段加锁，使得同一时刻只有一个线程可以访问共享资源。</p>
<p>当多个线程共享同一资源（如变量、对象或文件）是，若没有同步机制，可能导致 <strong>竞态条件</strong> ，线程对共享资源的操作是非原子性的，多个现成之间可能导致同时修改数据，导致结果不符合预期。</p>
<h2 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h2><p>**线程安全 **是指多个线程访问某一共享资源时，能够保证一致性和正确性，即无论线程如何交替执行，程序都能够产生预期的结果，且不会出现数据竞争或内存冲突。在Java中，线程安全的实现通常依赖于同步机制和线程隔离技术。</p>
<p><strong>常用的线程安全措施</strong></p>
<ul>
<li><strong>同步锁</strong>： 通过 <code>synchronized</code> 和 <code>ReentrantLock</code> 实现对共享资源的同步控制。</li>
<li><strong>原子操作类</strong>： Java提供的 <code>AtomicInteger</code> 和 <code>AtomicReference</code> 等类确保多线程环境下的原子操作。</li>
<li><strong>线程安全容器</strong>： 如 <code>ConcurrentHashMap</code> 和 <code>CopyOnWriteArrayList</code> 等，避免手动加锁。</li>
<li><strong>局部变量</strong>： 线程内独立的局部变量天然是线程安全的，因为每个线程都有自己的栈空间（线程隔离）</li>
<li><strong>ThreadLocal：</strong> 类似于局部变量，属于线程本地资源，通过线程隔离保证了线程安全。</li>
</ul>
<h2 id="什么是协程？Java支持协程吗？"><a href="#什么是协程？Java支持协程吗？" class="headerlink" title="什么是协程？Java支持协程吗？"></a>什么是协程？Java支持协程吗？</h2><p>说明：</p>
<p><strong>协程：</strong> （Coroutine) 是一种轻量级的线程，它允许在执行中暂停并在之后恢复执行，而无需阻塞队列。与线程相比，协程就是 <strong>用户态调度</strong> ，效率更高，因为它不涉及操作系统的内核调度。</p>
<p>Java一开始没有原生支持的协程，但在Java19中通过Project Loom 引入了虚拟线程，最终在Java21确认。</p>
<h2 id="在Java中线程的生命周期如何定义"><a href="#在Java中线程的生命周期如何定义" class="headerlink" title="在Java中线程的生命周期如何定义"></a>在Java中线程的生命周期如何定义</h2><p>在Java中，线程的生命周期可以分为以下几个状态：</p>
<ul>
<li><strong>New（初始状态）：</strong> 线程对象创建后，但未调用start（）方法。</li>
<li><strong>Runable(可运行状态）：</strong> 调用start（）方法后，线程进入就绪状态，等待CPU调度。</li>
<li><strong>Blocked(阻塞状态）:</strong> 线程试图获取一个对象锁而被阻塞。</li>
<li><strong>Waiting（等待状态）：</strong> 线程进入等待状态，需要被显式唤醒才能继续执行。</li>
<li><strong>Timed Waiting（含等待时间的等待状态）：</strong> 线程进入等待状态，但指定了等待时间，超时后会被唤醒。</li>
<li><strong>Terminated（终止状态）：</strong> 线程执行完成后或因异常退出。</li>
</ul>
<p>操作系统中线程的生命周期：</p>
<ul>
<li>新建（New）： 线程对象被创建，但尚未启动。</li>
<li>就绪（Runnable）： 线程被启动，处于可运行状态，等待CPU调度执行。</li>
<li>运行（Running)： 线程获取CPU资源， 开始执行run（）方法中的代码。</li>
<li>阻塞（Blocked）： 线程因为某些操作（如等待锁、IO锁操作）被阻塞，暂时停止执行。</li>
<li>终止（Terminated): 线程执行完成或因异常退出后，生命周期结束。</li>
</ul>
<h2 id="线程之间如何进行通讯？"><a href="#线程之间如何进行通讯？" class="headerlink" title="线程之间如何进行通讯？"></a>线程之间如何进行通讯？</h2><p>在Java中，线程之间的通信是指 <strong>多个线程协同工作</strong>， 主要实现方式包括：</p>
<p><strong>1. 共享变量</strong></p>
<ul>
<li>线程可以通过访问共享内存变量来交换信息（需要注意同步问题，防止数据竞争和不一致）</li>
<li>共享也可以是文件，例如写入同一个文件来进行通信。</li>
</ul>
<p><strong>2. 同步机制：</strong></p>
<ul>
<li>synchronized：Java中的同步关键字，用于确保同一时刻只有一个线程可以访问共享资源，利用Object类提供的<code>wait(),notify(),notifyAll()</code> 实现线程之间的等待、通知机制。</li>
<li>ReentrantLock： 配置Condition提供了类似于wait(),notify()的等待、通知。</li>
<li>BlockingQueue: 通过阻塞队列实现生产者-消费者模式</li>
<li>CountDownLatch：可以允许一个或多个线程等待，直到在其他线程中执行一组操作完成</li>
<li>Cyclicbarrier：可以让一组线程互相等待，直到达到某个公共屏障点。</li>
<li>Volatile： Java中的关键字，确保变量的可加性，防止指令重排。</li>
<li>Semaphore：信号量，可以控制对特定资源的访问线程数。</li>
</ul>
<h2 id="Synchronized-和-ReentrantLock的区别？"><a href="#Synchronized-和-ReentrantLock的区别？" class="headerlink" title="Synchronized 和 ReentrantLock的区别？"></a>Synchronized 和 ReentrantLock的区别？</h2><blockquote>
<p>注意： 有时候会看到Synchroized时Lock对比，实际上 ReentrantLock实现了Lock接口。</p>
</blockquote>
<p>两者的<strong>共同特点</strong>：</p>
<ul>
<li>都是用来协调多线程对共享对象、变量的访问。</li>
<li>都是可重入锁，同一线程可以多次获得同一个锁</li>
<li>都保证了可见性和互斥性。</li>
</ul>
<p>两者的<strong>不同特点</strong>：</p>
<ul>
<li>ReentrantLock显示的获得、释放锁（需要手动控制），synchronized隐式获得锁释放。</li>
<li>ReentrantLock可影响中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性。</li>
<li>ReentrantLock是API级别的（需要写代码实现）， synchronized 是JVM级别的（内置）</li>
<li>ReentrantLock可以实现公平锁和， synchronized就是一个非公平锁。</li>
<li>ReentrantLock通过Condition可以绑定多个条件。</li>
<li>底层实现不同，synchronized 是同步阻塞，   使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略。</li>
<li>Lock是一个接口，而sychronized是Java中的关键字，由内置语言实现。</li>
<li>synchronized发生异常是，会自动释放线程占有的锁，因此不会导致死锁现象发生。而Lock在发生异常时，如果没有主动通过unLock() 去释放锁，则很可能造成死锁现象，因此使用lock是需要在finally快中释放锁。</li>
<li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能响应中断。</li>
<li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到</li>
<li>Lock可以提高多个线程进行读操作的效率，即就是<strong>实现读写锁</strong>等。（分为独占锁和共享锁）</li>
</ul>
<h3 id="既然ReentrantLock-功能那么全，为什么还要用Synchronized呢？"><a href="#既然ReentrantLock-功能那么全，为什么还要用Synchronized呢？" class="headerlink" title="既然ReentrantLock 功能那么全，为什么还要用Synchronized呢？"></a>既然ReentrantLock 功能那么全，为什么还要用Synchronized呢？</h3><p>尽管 <code>ReentrantLock</code> 提供了更多功能和灵活性，<code>synchronized</code> 仍然被广泛使用，原因如下：</p>
<ol>
<li><strong>简洁性</strong>：<ul>
<li><code>synchronized</code> 语法简单，自动管理锁的获取和释放，减少了代码复杂度。</li>
<li><code>ReentrantLock</code> 需要显式地加锁和解锁，增加了代码的复杂性和出错风险。</li>
</ul>
</li>
<li><strong>内置支持</strong>：<ul>
<li><code>synchronized</code> 是 Java 语言的一部分，无需额外导入。</li>
<li><code>ReentrantLock</code> 属于 <code>java.util.concurrent</code> 包，需要显式导入。</li>
</ul>
</li>
<li><strong>自动释放锁</strong>：<ul>
<li><code>synchronized</code> 在代码块或方法执行结束后自动释放锁，避免忘记解锁。</li>
<li><code>ReentrantLock</code> 必须手动调用 <code>unlock()</code>，否则可能导致死锁。</li>
</ul>
</li>
<li><strong>性能差异</strong>：<ul>
<li>在 Java 6 及以后版本中，<code>synchronized</code> 经过优化，性能与 <code>ReentrantLock</code> 相当，甚至在某些场景下更优。</li>
<li>只有在高并发场景下，<code>ReentrantLock</code> 的高级功能（如可中断锁、公平锁等）才能体现出优势。</li>
</ul>
</li>
<li><strong>调试和监控</strong>：<ul>
<li><code>synchronized</code> 与 JVM 的监控工具（如 JConsole、VisualVM）集成更好，便于调试。</li>
<li><code>ReentrantLock</code> 的调试和监控相对复杂。</li>
</ul>
</li>
<li><strong>兼容性</strong>：<ul>
<li><code>synchronized</code> 自 Java 1.0 引入，兼容所有 Java 版本。</li>
<li><code>ReentrantLock</code> 在 Java 5 中引入，不适用于早期版本。</li>
</ul>
</li>
<li><strong>默认行为</strong>：<ul>
<li><code>synchronized</code> 的默认行为（如非公平锁）适合大多数场景。</li>
<li><code>ReentrantLock</code> 提供了更多选项（如公平锁），但这些功能在大多数情况下并非必需。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**<code>synchronized</code>**：适合大多数场景，简洁、易用、性能良好。</li>
<li>**<code>ReentrantLock</code>**：适合需要高级功能（如可中断锁、公平锁等）的高并发场景。</li>
</ul>
<p>因此，<code>synchronized</code> 仍然是许多场景下的首选，而 <code>ReentrantLock</code> 则用于需要更复杂控制的场合。</p>
<h2 id="Condition和Object类锁方法的区别"><a href="#Condition和Object类锁方法的区别" class="headerlink" title="Condition和Object类锁方法的区别"></a>Condition和Object类锁方法的区别</h2><ul>
<li>Condition 类的 awiat 方法和 Object 类的 wait 方法等效</li>
<li>Condition 类的 signal 方法和 Object 类的 notify 方法等效</li>
<li>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效</li>
<li>ReentrantLock 类可以唤醒指定条件的线程，而Object唤醒是随机的。</li>
</ul>
<h2 id="如何创建多线程"><a href="#如何创建多线程" class="headerlink" title="如何创建多线程"></a>如何创建多线程</h2><p><strong>1. 实现Runnable接口</strong></p>
<ul>
<li>实现Runnable接口的 <code>run()</code>方法，使用构造器Thread类的构造函数传入<code>Runnbale</code> 对象，调用<code>start()</code> 方法启动线程。（这个是没有返回值的）</li>
</ul>
<p><strong>2. 继承Thread类</strong></p>
<ul>
<li>继承Thread类并重写<code>run()</code>方法，直接创建<code>Thread</code> 子类并调用<code>start（）</code> 方法启动线程。</li>
</ul>
<p><strong>3. 使用Callable和FutureTask</strong></p>
<ul>
<li><p>实现 Callable 接口的 call方法，使用FutureTask包装Callable对象，在通过Thread方法启动（有返回值）</p>
</li>
<li><p>实例：</p>
<img src="https://pic1.imgdb.cn/item/67cbb7d3066befcec6e0aba9.png" alt="image.png"></li>
</ul>
<p><strong>4. 使用线程池(ExecutorService)</strong></p>
<ul>
<li><p>通过 <code>ExecutorService</code> 提交 <code>Runnable</code> 或 <code>Callable</code>任务，不直接创建和管理线程，适合大量并发任务。</p>
<img src="https://pic1.imgdb.cn/item/67cbb84e066befcec6e0acc7.png" alt="image.png"></li>
</ul>
<p><strong>5. CompletableFuture（本质也是线程池，默认forkjoinpool)</strong></p>
<ul>
<li>Java8引入的功能，非常方便地进行异步任务调度，通过<code>thenApply、thenAccept</code> 等方法可以轻松的处理异步任务之间的依赖关系。</li>
</ul>
<img src="https://pic1.imgdb.cn/item/67cbb8e4066befcec6e0ad8d.png" alt="image.png">

<blockquote>
<p>注意：本质上只有一种，就是Thread来创建，其他的都是对Thread做了一个封装。</p>
</blockquote>
<p><strong>线程池的优势</strong></p>
<ul>
<li>使用线程池可以有效的管理和重用线程，避免频繁创建和销毁线程带来的开销。常用的线程池<code>FixedThreadPool</code>、<code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></li>
</ul>
<p> <strong>FixedThreadPool</strong></p>
<ul>
<li><strong>适用场景</strong>：任务数量已知且相对稳定，且任务执行时间较长。</li>
<li><strong>特点</strong>：线程池大小固定，不会动态调整。</li>
<li><strong>优点</strong>：资源消耗可控，适合负载较重的场景。</li>
<li><strong>缺点</strong>：如果任务数量突然增加，可能会导致任务积压。</li>
</ul>
<p><strong>CachedThreadPool</strong></p>
<ul>
<li><strong>适用场景</strong>：任务数量不确定，且任务执行时间较短。</li>
<li><strong>特点</strong>：线程池大小不固定，会根据任务数量动态调整。</li>
<li><strong>优点</strong>：适合处理大量短时任务，资源利用率高。</li>
<li><strong>缺点</strong>：如果任务数量过多，可能会创建大量线程，导致资源耗尽。</li>
</ul>
<p><strong>ScheduledThreadPool</strong></p>
<ul>
<li><strong>适用场景</strong>：需要定期执行任务或延迟执行任务。</li>
<li><strong>特点</strong>：支持定时任务和周期性任务。</li>
<li><strong>优点</strong>：适合需要调度任务的场景。</li>
<li><strong>缺点</strong>：不适合处理大量短时任务。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><strong>FixedThreadPool</strong>：适合任务数量稳定且执行时间较长的场景。</li>
<li><strong>CachedThreadPool</strong>：适合任务数量不确定且执行时间较短的场景。</li>
<li><strong>ScheduledThreadPool</strong>：适合需要定时或周期性执行任务的场景。</li>
</ul>
<h2 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h2><p><strong>当前一个满的情况下，会执行后一个</strong></p>
<p>核心线程池 -》 工作队列 -》 新开线程 -》 拒绝策略</p>
<p>线程池的参数：</p>
<ul>
<li>corePoolSize ： 核心线程数</li>
<li>maximumPoolSize: 最大线程数</li>
<li>workQueue： 工作队列</li>
<li>keepAliveTime： 回收线程时间</li>
<li>threadFactory： 线程工厂，表示怎么创建线程</li>
<li>Rejected： 这个接口是实现拒绝策略的，表示都满了的拒绝。</li>
</ul>
<p><img src="https://pic1.imgdb.cn/item/67a2b8edd0e0a243d4fbdbaa.png"></p>
<p>poll： 假如queue为空，并且允许关闭核心线程数 或者 我当前的线程树大于核心线程数， 回收。（或超时）</p>
<p>take： 否则， 阻塞在take中，等待queue里面的task。（自旋）</p>
<p><strong>整体结构图</strong></p>
<p><img src="https://pic1.imgdb.cn/item/67a2bbe7d0e0a243d4fbdcf7.png"></p>
<h2 id="如何合理设置线程池"><a href="#如何合理设置线程池" class="headerlink" title="如何合理设置线程池"></a>如何合理设置线程池</h2><h4 id="选择原则："><a href="#选择原则：" class="headerlink" title="选择原则："></a>选择原则：</h4><ul>
<li><strong>CPU 密集型任务</strong>：任务主要消耗 CPU 资源（如计算、逻辑处理）。<ul>
<li>核心线程数通常设置为 <strong>CPU 核心数 + 1</strong>。</li>
<li>例如，4 核 CPU 可以设置为 5。</li>
<li>过多的线程会导致频繁的上下文切换，反而降低性能。</li>
</ul>
</li>
<li><strong>IO 密集型任务</strong>：任务主要消耗 IO 资源（如文件读写、网络请求、数据库操作）。<ul>
<li>核心线程数可以设置为 <strong>CPU 核心数 × 2</strong> 或更高。</li>
<li>因为 IO 操作会阻塞线程，增加线程数可以提高 CPU 利用率。</li>
</ul>
</li>
<li><strong>混合型任务</strong>：既有 CPU 密集型任务，也有 IO 密集型任务。<ul>
<li>可以根据任务的比例动态调整，或者通过性能测试来确定最佳值。</li>
</ul>
</li>
</ul>
<h2 id="Java中有哪些拒绝策略"><a href="#Java中有哪些拒绝策略" class="headerlink" title="Java中有哪些拒绝策略"></a>Java中有哪些拒绝策略</h2><p>一共有4种：</p>
<ul>
<li><strong>AbortPolicy</strong>：当任务队列满且没有线程空闲，此时添加任务会直接抛出 <code>RejectedExecutionException</code> 错误，这也是默认的拒绝策略，适合于必须通知调用者任务未能被执行。（abort 放弃）</li>
<li><strong>CallerRunsPolicy：</strong> 当任务队列满没有空闲空间，此时添加任务由即调用者线程执行。适用于希望通过减缓任务提交速度来稳定系统的场景（Caller调用）</li>
<li><strong>DiscardOldestPolicy:</strong>  当任务队列满且没有线程空闲，会删除最早的任务，然后重新提交当前任务。适用于希望丢弃最旧的任务以保证新的重要任务能够被处理的场景。</li>
<li><strong>DiscardPolicy</strong>： 直接丢弃当前任务，不会执行任何操作，也不会抛出异常。适用于对部分任务丢弃没有影响的场景，或系统负载较高时不需要处理所有任务。</li>
</ul>
<h2 id="Java-并发库中提供了哪些线程池实现？他们有什么区别？"><a href="#Java-并发库中提供了哪些线程池实现？他们有什么区别？" class="headerlink" title="Java 并发库中提供了哪些线程池实现？他们有什么区别？"></a>Java 并发库中提供了哪些线程池实现？他们有什么区别？</h2><p><strong>1. FixedThreadPool：</strong> 创建一个固定数量的线程池。</p>
<p>线程池中的线程数是固定的，空闲的线程会被复用。如果所有线程都在忙，则新任务会放入队列中等待。</p>
<p>适合负载稳定的场景，任务数量确定且不需要动态调整线程数。（fixed 固定的）</p>
<p><strong>2. CachedThreadPool：</strong>一个可以根据需要创建新线程的线程池。</p>
<p>线程池的线程数量没有上限，空闲线程会在60秒后被回收，如果有新任务且没有可用线程，会创建线程。</p>
<p>适合短期大量并发场景，任务执行时间短且线程数需求变化较大。（Cached 缓存）</p>
<p><strong>3. SingleThreadExecutor：</strong> 创建一个只有单个线程的线程池。</p>
<p>只有一个线程处理任务，任务会按照提交顺序一次执行。</p>
<p>适用于需要保证任务按顺序执行的场景，或者不需要并发处理任务的情况。</p>
<p><strong>4. ScheduledThreadPool：</strong> 支持定时任务和周期性任务的线程池。</p>
<p>可以定时或以固定频率执行任务，线程池大小可以由用户指定。</p>
<p>适用于需要周期性任务执行的场景，如定时任务调度。</p>
<p><strong>5. WorkStealingPool:</strong> 基于任务窃取算法的线程池</p>
<p>线程池中的每个线程维护着一个双端队里（deque），线程可以从自己的队列中去任务队列执行，如果线程的任务队列为空，它可以从其他线程的队列中”窃取” 任务来执行，达到负载均衡的效果。</p>
<p>适合大量小任务并行执行，特别是递归算法或大任务分解成小任务。</p>
<h2 id="线程池的shutdown和shutdownNow的区别是什么？"><a href="#线程池的shutdown和shutdownNow的区别是什么？" class="headerlink" title="线程池的shutdown和shutdownNow的区别是什么？"></a>线程池的shutdown和shutdownNow的区别是什么？</h2><p>这两个方法都是用来关闭线程池的，但工作方式有所不同：</p>
<p><strong>1. shutdown</strong></p>
<p>启动线程池的 <strong>平滑关闭</strong>， 它不再接受新的任务，但会继续执行已经提交的任务（包括在队列内的任务）。</p>
<p>线程池会进入 <code>SHUTDOWN</code> 状态，所有已执行和正在执行的任务都会继续完成，只有所有任务完成后，线程池才会完全终止。</p>
<p><strong>2. shutdownNow</strong></p>
<p>启动线程池的 <strong>强制关闭</strong>， 它会尝试停止所有正在执行的任务，并<strong>返回等待执行的任务队列</strong>。它会尽力中断正在执行的任务， <strong>但不能保证所有任务都能被立即停止</strong>。</p>
<p>线程池进入 <code>STOP</code> 状态，除了尝试中断正在执行的任务外，还会清空任务队列，返回未执行的任务队列。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li><strong>shutdown：</strong> 适用于程序需要平滑停止线程池的场景，如应用程序正常退出时，保证所有已提交的任务都能执行完毕，避免任务丢失。</li>
<li><strong>shutdownNow：</strong> 适用于紧急情况或需要立即停止线程池的场景，如应用程序异常退出时。快速清理资源，但可能导致部分任务未完成。</li>
</ul>
<p><strong>线程池的生命周期：</strong></p>
<ul>
<li>运行状态： 线程池可以接受新任务并处理已提交的任务。</li>
<li>关闭状态： 通过<code>shutdown</code> 进入，该状态下线程池不再接受新任务，但会继续执行已有的任务。</li>
<li>停止状态： 通过调用 <code>shutdownNow</code> 进入，该状态下线程池会试图中断所有正在执行的任务并清空任务队列。</li>
<li>终止状态： 所有任务执行完毕且线程池完全关闭后，线程池进入 终止状态。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>调用 shutdown 和 shutdownNow后，再次调用他们不会有额外效果。shutdownNow只会在第一次调用时有效果。</li>
<li>并且，即使线程池进入 关闭状态，相关资源不会立即释放。必须等待所有线程完成任务，线程池进入 终止状态后，资源才会释放。</li>
</ul>
<h2 id="线程池内部出现任务异常后，如何知道是哪个线程出了异常？"><a href="#线程池内部出现任务异常后，如何知道是哪个线程出了异常？" class="headerlink" title="线程池内部出现任务异常后，如何知道是哪个线程出了异常？"></a>线程池内部出现任务异常后，如何知道是哪个线程出了异常？</h2><p>默认情况下， <strong>线程池不会直接报告哪个线程发生异常</strong>，但是可以采取一下几种方式：</p>
<p><strong>1. 自定义线程池 ThreadFactory</strong></p>
<ul>
<li>通过自定义 <code>ThreadFactory</code> ， 为每个线程设置一个异常处理器（<code>UncaughtExceptionHandler</code>)，在其中记录发生异常的线程信息。</li>
</ul>
<p><strong>2. 通过<code>Future</code></strong></p>
<ul>
<li>提交任务时使用 <code>submit()</code>方法，而不是 <code>execute()</code> , 这样可以通过 <code>Future</code> 对象捕获并检查任务执行结果和异常。</li>
</ul>
<p><strong>3. 通过内部手动捕获异常并记录</strong></p>
<ul>
<li>在任务 <code>run()</code> 方法内部，使用 <code>try-catch</code> 结构捕获异常，并记录或处理异常，同时记录线程信息。</li>
</ul>
<h2 id="Java中的DelayQueue和-ScheduledThreadPool有什么区别？"><a href="#Java中的DelayQueue和-ScheduledThreadPool有什么区别？" class="headerlink" title="Java中的DelayQueue和 ScheduledThreadPool有什么区别？"></a>Java中的DelayQueue和 ScheduledThreadPool有什么区别？</h2><p>DelayQueue是一个阻塞队列，而ScheduledThreadPool是线程池，不过内不核心原理都是差不多。</p>
<p>DelayQueue是利用优先队列存储元素，当从队列中获取任务时，如果最老的任务已经到了执行时间，可以从队列中出队一个任务，返之，可以获得null或者阻塞等待任务到时。</p>
<p>ScheduledThreadPool 内部也是用了一个优先队列 DelayWorkQueue且可以内部多线程执行任务，支持定时执行的任务，即每隔一段时间执行一次的任务。</p>
<p><strong>关于</strong></p>
<p>这两个底层几乎一样，差别就是 DelayWorkQueue没有使用 PriorityQueue而是用RunnableScheduledFuture数组来实现优先队列，不过底层原理都是一样的。</p>
<h2 id="Java中的Timer"><a href="#Java中的Timer" class="headerlink" title="Java中的Timer"></a>Java中的Timer</h2><p>Java中的timer是一个用于调度任务的工具类，用于在未来某个时刻执行任务或周期性地执行任务，Timer类一般与TimerTask搭配使用，其中TimerTask是一个需要执行的任务。</p>
<p>适用于简单的定时任务，如定时更新，定期发送报告等。</p>
<h3 id="Timer使用"><a href="#Timer使用" class="headerlink" title="Timer使用"></a>Timer使用</h3><p>TimerTask是Timer需要执行的任务，它是一个实现了Runnable接口的抽象类，必须通过继承并实现其run（）方法。</p>
<p>基本使用：</p>
<ul>
<li><code>Timer.schedule(TimerTask task, long delay)</code> 在指定的延迟之后执行任务。</li>
<li><code>Timer.scheduleAtFixedRate(TimerTask task,long dalay, long period)</code> 周期性的执行任务。</li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line"><span class="type">TimerTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;Task executed!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">timer.schedule(task, <span class="number">2000</span>);  <span class="comment">// 2 秒后执行任务</span></span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Timer可以实现延时任务，也可以实现周期任务，它的核心就是一个优先队列和封装的执行任务的线程。</p>
<p>实现原理是：<strong>维持一个小顶堆</strong>，即最快需要执行的任务排在优先队列的第一个，根据堆的特性我们知道插入和删除的时间复杂度都是O（logn）</p>
<p>然后有个TimerThread线程	不断地拿排着第一个任务的执行时间和当前时间做对比。</p>
<p>如果时间到了先看看这个任务是不是周期性执行的任务，如果是则修改当前任务时间为下次执行的时间，如果不是周期性任务则将任务从优先队列中移除，最后执行任务，如果时间还未到则调用wait（）等待。</p>
<p>执行结构图：</p>
<img src="https://pic1.imgdb.cn/item/67d288fe88c538a9b5bc72c2.png" alt="image.png">

<p>可以看出Timer实际就是根据任务的执行时间维护一个优先队列，并且起了一个线程不断地拉取任务执行。</p>
<h3 id="Timer弊端"><a href="#Timer弊端" class="headerlink" title="Timer弊端"></a>Timer弊端</h3><p>首先优先队列的插入和删除的时间复杂度是O（logn），当数据量大的时候，频繁的入堆出堆性能有待考虑。</p>
<p>并且是 <strong>单线程执行</strong>， 那么如果一个任务执行的时间过久则会影响下一个任务的执行时间</p>
<p>并且从它对异常没有做什么处理，所以一个任务出错的时候会导致之后的任务都无法执行。</p>
<h3 id="关于-Timer-和-Schedule"><a href="#关于-Timer-和-Schedule" class="headerlink" title="关于 Timer 和 @Schedule"></a>关于 Timer 和 @Schedule</h3><p>@Schedule 和 Timer 类虽然都用于定时任务，但它们的使用场景和功能有所不同，各有优缺点。</p>
<p><strong>1. @Schedule</strong></p>
<p>是javaEE中的注解，通常与EJB或Spring等框架结合使用，用于声明周期性任务，它的特点是：</p>
<ul>
<li><strong>声明式编程：</strong> 通过注解即可定义任务执行的时间，简化了代码。</li>
<li><strong>基于cron表达式</strong>： 支持复杂的调度规则。</li>
<li><strong>依赖框架：</strong> 需要框架支持，如Spring或JavaEE容器。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 * * * ?&quot;)</span> <span class="comment">// 每小时执行一次</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduledTask</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Task executed at: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>2. Timer类</strong></p>
<p>Timer 是Java标准库中的类，用于调度任务。它的特点是：</p>
<ul>
<li><strong>编程式配置：</strong> 通过代码控制任务的调度，灵活性提高。</li>
<li><strong>简单任务调度：</strong> 适合一次性或周期性任务，但不支持复杂的cron表达式。</li>
<li><strong>独立于框架：</strong> 不依赖外部框架，适用于纯Java应用。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Task executed at: &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>); <span class="comment">// 每小时执行一次</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 主要区别</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Schedule</code> 注解</th>
<th align="left"><code>Timer</code> 类</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>配置方式</strong></td>
<td align="left">声明式（注解）</td>
<td align="left">编程式（代码）</td>
</tr>
<tr>
<td align="left"><strong>灵活性</strong></td>
<td align="left">依赖框架，适合固定规则的任务</td>
<td align="left">灵活，适合动态任务</td>
</tr>
<tr>
<td align="left"><strong>复杂度</strong></td>
<td align="left">支持复杂 cron 表达式</td>
<td align="left">仅支持简单的时间间隔</td>
</tr>
<tr>
<td align="left"><strong>依赖</strong></td>
<td align="left">需要 Spring 或 Java EE 容器</td>
<td align="left">纯 Java，无需额外依赖</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">周期性任务，规则固定</td>
<td align="left">一次性或简单周期性任务</td>
</tr>
</tbody></table>
<p><strong>4. 总结</strong></p>
<ul>
<li><strong><code>@Schedule</code></strong> 适合在框架支持的场景下使用，尤其是需要复杂调度规则的任务。</li>
<li><strong><code>Timer</code></strong> 适合纯 Java 应用或需要动态调度的任务。</li>
</ul>
<h2 id="如何在Java中控制多个线程的执行顺序？"><a href="#如何在Java中控制多个线程的执行顺序？" class="headerlink" title="如何在Java中控制多个线程的执行顺序？"></a>如何在Java中控制多个线程的执行顺序？</h2><p>在Java中控制多个线程的执行顺序有很多种方法：</p>
<ul>
<li><p>CompletableFuture，它内部有thenRun的方式，假设我们现在有三个任务T1、T2、T3需要按顺序执行，那么仅需要使用一下伪代码即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.runAsync(() -&gt; &#123;<span class="keyword">do</span> t1 sth&#125;)</span><br><span class="line">   .thenRun(()-&gt; &#123;<span class="keyword">do</span> t2 sth&#125;)</span><br><span class="line">   .thenRun(()-&gt; &#123;<span class="keyword">do</span> t3 sth&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>synchronized + wait()&#x2F;notify(), 通过对象锁和线程间通讯机制来控制线程的执行顺序。</p>
</li>
<li><p>ReentrantLock + condition</p>
</li>
<li><p>Thread 类的 join（），通过调用这个方法，可以使一个线程等待另一个线程执行完毕后在继续执行。</p>
</li>
<li><p>CountDownLatch（），使一个或多个线程等待其他线程完成各自工作后再继续执行。</p>
</li>
<li><p>CyclicBarrier，使多个线程相互等待，直到所有线程都达到某个共同点后在继续执行。</p>
</li>
<li><p>Semaphore，控制线程的执行顺序，适用于需要限制同时访问资源的线程数量的场景。</p>
</li>
<li><p>线程池，内部仅设置一个线程来执行任务，按序的将任务提交到线程池中就可以了。</p>
</li>
</ul>
<h2 id="你使用过Java中的哪些阻塞队列？"><a href="#你使用过Java中的哪些阻塞队列？" class="headerlink" title="你使用过Java中的哪些阻塞队列？"></a>你使用过Java中的哪些阻塞队列？</h2><p>阻塞队列主要用来阻塞队列的插入和获取操作，当队列满了的时候插入操作会被阻塞，直到队列有空位。当队列为空的时候获取操作会被阻塞，知道队列有值。</p>
<p>常用在实现 生产者和消费者 场景，在笔试题中比较常见。</p>
<p>常见的阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue: 一个有界队列，底层基于数组实现。需要在初始化是指定队列的大小，队列满时，生产者会被阻塞，队列空时，消费者会被阻塞。</li>
<li>LinkedBlockingQueue：基于链表的阻塞队列，允许可选的界限（有界或无界）。无界模式下可以不断添加元素，直到耗尽系统资源。有界模式则类似与 <code>ArrayBlockingQueue</code>，但吞吐量通常较高。</li>
<li>PriorityBlockingQueue: 一个无界的优先级队列，元素按照自然顺序或指定的比较器顺序进行排序。与其他阻塞队列不同的是，PriorityBlockingQueue 不保证元素的FIFO顺序。</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="prev" title="设计模式">
                  <i class="fa fa-angle-left"></i> 设计模式
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="next" title="计算机网络">
                  计算机网络 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZhangYuHao</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
