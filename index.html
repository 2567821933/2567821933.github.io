<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一个小人物的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Zhang&#39;Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Zhang&#39;Blog">
<meta property="og:description" content="一个小人物的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZhangYuHao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zhang'Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhang'Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZhangYuHao"
      src="/images/111.png">
  <p class="site-author-name" itemprop="name">ZhangYuHao</p>
  <div class="site-description" itemprop="description">一个小人物的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/2567821933" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;2567821933" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:103903Zyh@gmail.com" title="E-Mail → mailto:103903Zyh@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/02/OJ%E5%88%A4%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/03/02/OJ%E5%88%A4%E9%A2%98/" class="post-title-link" itemprop="url">OJ判题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-03-02 15:16:19 / 修改时间：16:31:26" itemprop="dateCreated datePublished" datetime="2025-03-02T15:16:19+08:00">2025-03-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="OJ判题系统"><a href="#OJ判题系统" class="headerlink" title="OJ判题系统"></a>OJ判题系统</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>OJ &#x3D; Online Judge 在线判题评测系统</p>
<p>用户可以选择题目，在线做题，编写代码并提交代码；系统会对用户提交的代码，根据我们出题人设置答案。</p>
<p>来判断用户的提交结果是否正确</p>
<p>最大难点： <strong>判题逻辑</strong></p>
<p>介绍： 用于在线评测编程题目代码的系统，能够根据用户提交的代码、出题人预先设置的题目输入和输出用例。进行编译代码，运行代码，判断代码运行结果是否正确。</p>
<p>判断题系统作为一个开发API提供给大家，便于大家开发自己的OJ系统。</p>
<h3 id="OJ常用概念"><a href="#OJ常用概念" class="headerlink" title="OJ常用概念"></a>OJ常用概念</h3><p>ac表示你的题目通过，结果正确</p>
<p>题目限制；</p>
<p>题目介绍</p>
<p>题目输入</p>
<p>题目输出</p>
<p>题目输入用例</p>
<p>题目输出用例</p>
<p>普通测评：管理员设置题目的输入和输出用例，交给判题机；给判题机去执行用户的代码，给用户的代码喂输入用例，看用户程序的执行结果是否和标准答案输出一致。</p>
<p>特殊测评（SPJ）： 管理员设置题目的输入和输出，比如我输入1，用户的答案只要是 &gt;0 或 &lt;2 都正确；特判程序，不是通过对比用例文件是否一致这种死板的程序来检验，而是要专门根据这道题来写一个特殊的判断程序。程序接收题目的输入，标准输出用例，用户结果，特判程序根据这些值来比较是否正确。</p>
<p>交互测评： 让用户输入一个例子，就给出一个输出结果，交互比较灵活，没办法通过简单的，死板的输入输出文件来搞定。 </p>
<p>不能让用户随便引入包，随便遍历，暴力破译，需要使用正确的算法 &#x3D;》 安全性</p>
<p>判题过程是异步的 &#x3D;》 异步化</p>
<p>提交之后会生成一个提交记录，有运行的结果以及运行信息（时间限制，内存限制）</p>
<h2 id="做项目流程"><a href="#做项目流程" class="headerlink" title="做项目流程"></a>做项目流程</h2><ol>
<li>项目介绍，项目调研，需求分析</li>
<li>核心业务流程</li>
<li>项目要做的功能（功能模块）</li>
<li>技术选型（技术预演）</li>
<li>项目初始化</li>
<li>项目开发</li>
<li>测试</li>
<li>优化</li>
<li>代码提交、代码审查</li>
<li>产品验收</li>
<li>上线</li>
</ol>
<p>写文档，持续调研，持续记录总结</p>
<h2 id="现有系统调研"><a href="#现有系统调研" class="headerlink" title="现有系统调研"></a>现有系统调研</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol>
<li>题目浏览</li>
<li>在线做题，在线提交</li>
</ol>
<h3 id="项目扩展思路"><a href="#项目扩展思路" class="headerlink" title="项目扩展思路"></a>项目扩展思路</h3><ol>
<li>支持多种语言</li>
<li>远程评测</li>
<li>普通测评、特殊测评、交互测评、在线自测、子任务分组测评、文件IO</li>
<li>统计分析，用户判题记录</li>
<li>权限校验</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/27/mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/27/mybatis/" class="post-title-link" itemprop="url">mybatis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-27 19:17:21" itemprop="dateCreated datePublished" datetime="2025-02-27T19:17:21+08:00">2025-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-01 22:51:37" itemprop="dateModified" datetime="2025-03-01T22:51:37+08:00">2025-03-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h2><h3 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h3><p>ORM（Object Relational Mapping，对象关系映射）是一种编程技术，用于在面对对象编程语言时，实现 <strong>对象</strong> 与 <strong>关系数据库数据</strong> 之间的映。它允许开发者通过操作对象来间接操作数据库，而无需直接编写SQL语句。</p>
<h3 id="ORM的核心功能"><a href="#ORM的核心功能" class="headerlink" title="ORM的核心功能"></a>ORM的核心功能</h3><p><strong>1. 表与类的映射</strong></p>
<ul>
<li>数据库中的每张表对应程序中的一个类。</li>
<li>表中的每列对应类的一个属性。</li>
<li>表中的每一行对应类的一个实例。</li>
</ul>
<p><strong>2. CRUD操作</strong></p>
<ul>
<li>插入数据</li>
<li>查询数据</li>
<li>更新数据</li>
<li>删除数据</li>
</ul>
<p><strong>3. 关系映射</strong></p>
<ul>
<li>处理表与表之间的关系</li>
<li>例如，用户表和订单表之间的一对多关系可以通过ORM框架自动映射</li>
</ul>
<p><strong>4. 事务管理</strong></p>
<ul>
<li>提供了事务支持，确保了数据的一致性和完整性。</li>
</ul>
<p><strong>5. 数据库迁移</strong></p>
<ul>
<li>支持数据库的版本控制，方便升级和回滚。</li>
</ul>
<h3 id="常见的ORM框架"><a href="#常见的ORM框架" class="headerlink" title="常见的ORM框架"></a>常见的ORM框架</h3><p>Java：</p>
<ul>
<li>Hibernate：功能强大，支持多种数据库，广泛用于企业级应用。</li>
<li>MyBatis：更接近SQL，灵活性高，适合复杂查询。</li>
</ul>
<h2 id="Mybatis-执行流程"><a href="#Mybatis-执行流程" class="headerlink" title="Mybatis 执行流程"></a>Mybatis 执行流程</h2><p>mybatis通常是通过SqlSession获取Mapper，通过Mapper来执行查找操作的。</p>
<p>以下是最外层的执行逻辑</p>
<img src="https://pic1.imgdb.cn/item/67c2f887d0e0a243d4092336.png" alt="image.png">

<p>通过读取mybatis配置信息，获取sqlSession来执行对应的方法。</p>
<p>这里是getSqlSession（）方法的里面</p>
<p>通过读取配置信息，获取SqlSessionFactoryBuilder这个类，通过这个类来获取对应的SqlSessionFactory</p>
<img src="https://pic1.imgdb.cn/item/67c2f902d0e0a243d4092370.png" alt="image.png">

<p>看到底下的getSqlSession了吗？可以通过这个方法来让SqlSessionFactory获取SqlSession</p>
<p>之后获取SqlSession后，就可以通过SqlSession来调用对应的方法，查询数据了</p>
<img src="https://pic1.imgdb.cn/item/67c2f995d0e0a243d40923de.png" alt="image.png">

<p>注意：通常情况下不会直接调用查找的方法，而且获取Mapper，通过Mapper来调用需要的方法。（通过Mapper来代理）</p>
<p>当sqlSession执行查找方法时：</p>
<p>Mybatis会根据传入的SQL映射语句的ID来寻找对应的SQL语句执行。对于通过 <code>namespace</code> 和 <code>id</code> 进行定位，MyBatis会将映射文件解析成一个 <code>MapperStatement</code> 对象</p>
<img src="https://pic1.imgdb.cn/item/67c2fbccd0e0a243d4092536.png" alt="image.png">

<blockquote>
<p><strong>MapperStatement</strong> ，里面保存了 SQL语句、参数类型、返回类型信息。</p>
</blockquote>
<img src="https://pic1.imgdb.cn/item/67c2fc95d0e0a243d4092591.png" alt="image.png">



<p>在SQL执行之前，MyBatis会根据映射文件中配置的<code>parameterType</code> 类型，将传入的参数封装成适当的对象。<strong>（StatementHandler，处理Sql语句的具体执行，包括SQL的预处理，绑定参数，执行查询等）</strong></p>
<p>执行SQL语句</p>
<p>并将查询到的结构通过映射文件中配置的 <code>resultType</code> 类型返回，并将查询类型转换成Java对象。**(通过调用ResultSetHandler， 处理得到的结果集。)**</p>
<p>事务管理：MyBatis的事务管理通过SqlSession来处理，SqlSession提供了事务的提交和回滚方式，当调用<code>SqlSession.commit()</code>时，SQL执行的结果会被提交到数据库；若发生异常，调用<code>SqlSession.rollback()</code>事务会回滚。</p>
<p>关闭：<code>close()</code></p>
<h3 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h3><img src="https://pic1.imgdb.cn/item/67c30078d0e0a243d40927ef.png" alt="image.png">

<h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul>
<li><strong>SqlSessionFactory：</strong> 负责创建<code>sqlSession</code>对象</li>
<li><strong>SqlSession：</strong>负责执行SQL操作，管理事务</li>
<li><strong>Configuration：</strong> 保存MyBatis的全员配置信息，维护映射器，插件，类型处理器等</li>
<li><strong>MappedStatement：</strong> 表示映射的SQL语句及其相关信息，如SQL，参数类型，返回类型等</li>
<li><strong>Executor：</strong> 用于执行SQL语句的组件，根据<code>MapperStatement</code> 中的SQL配置信息，通过数据库连接执行SQL语句，提供缓存支持。</li>
<li><strong>StatementHandler:</strong> <code>StatementHandler</code>负责处理SQL语句的具体执行，包括SQL的预处理，绑定参数，执行查询等</li>
<li><strong>ResultSetHandler：</strong> <code>ResultSetHandler</code> 负责处理查询结果的映射，将结果集转换成Java对象。</li>
</ul>
<blockquote>
<p>注意： 获取MapperStatement在创建SqlSession之前</p>
<p>在执行SQL之前的MapperStatement是获取，不是创建。</p>
</blockquote>
<p>之后会创建PrepareStatement（在JDBC中）</p>
<p><strong>创建 PreparedStatement</strong>：</p>
<ul>
<li>MyBatis 通过 JDBC 的 <code>Connection</code> 对象创建 <code>PreparedStatement</code>。</li>
<li>如果 SQL 中使用的是 <code>#&#123;&#125;</code>，MyBatis 会将 <code>#&#123;&#125;</code> 替换为 <code>?</code>，并通过 <code>PreparedStatement</code> 设置参数。</li>
</ul>
<p><strong>执行 SQL</strong>：</p>
<ul>
<li>调用 <code>PreparedStatement.execute()</code> 执行 SQL。</li>
<li>如果是查询操作，MyBatis 会将结果映射为 Java 对象。</li>
</ul>
<h2 id="关于MyBatis的缓存"><a href="#关于MyBatis的缓存" class="headerlink" title="关于MyBatis的缓存"></a>关于MyBatis的缓存</h2><p>Mybatis中有两类缓存，分别是一级缓存和二级缓存</p>
<p><strong>一级缓存（SqlSession）</strong>： 仅在同一个<code>sqlsession</code> 中生效，基于命名空间，sql语句和参数作为唯一标识</p>
<ul>
<li>默认开启，生命周期和sqlsession一致</li>
<li>当执行 <code>commit</code> <code>rollback</code> 或手动清理时会清空</li>
</ul>
<p><strong>二级缓存（Mapper级别）：</strong> 夸Sqlsession共享缓存，基于Mapper缓存。</p>
<ul>
<li>需要手动配置开启</li>
<li>生命周期和 SqlSessionFactory一致</li>
<li>数据的更新、插入和删除会使相关的缓存失效</li>
<li>支持定制化存储。</li>
</ul>
<blockquote>
<p><strong>注意: 开启缓存后，会先去二级缓存中查找，之后再去一级</strong></p>
</blockquote>
<p><strong>两个缓存都是，基于PerpetualCache的HashMap本地缓存</strong></p>
<h2 id="MyBatis和Hibernate有哪些不同？"><a href="#MyBatis和Hibernate有哪些不同？" class="headerlink" title="MyBatis和Hibernate有哪些不同？"></a>MyBatis和Hibernate有哪些不同？</h2><ul>
<li>ORM模型<ul>
<li>Hibernate 是全自动ORM框架，会自动生成SQL并管理实体对象的生命周期，<strong>强调对象模型</strong></li>
<li>MyBatis是半自动ORM工具，需要开发者手写SQL。<strong>强调SQL控制</strong></li>
</ul>
</li>
<li>灵活性<ul>
<li>Mybatis提供了更灵活的SQL定制能力</li>
<li>Hibernate 更注重对象和数据库的映射，适合复杂的实体关系模型</li>
</ul>
</li>
<li>性能<ul>
<li>在复杂查询场景下，Mybatis的性能通常优于Hibernate，因为SQl可控。</li>
</ul>
</li>
</ul>
<img src="https://pic1.imgdb.cn/item/67c31079d0e0a243d4093439.png" alt="image.png">

<h2 id="关于-和"><a href="#关于-和" class="headerlink" title="关于#{} 和 ${}"></a>关于#{} 和 ${}</h2><p>​	在mybatis中， <code>#&#123;&#125;</code> 和 <code>\$&#123;&#125;</code> 都是用来处理SQL语句中的占位符，但他们的作用域和使用功能场景有显著的不同</p>
<p> <code>#&#123;&#125;</code>（PreparedStatement 占位符）： 传入SQL查询语句参数，它会将传入的参数进行类型处理，并使用功能PreparedStatement进行SQL绑定，从而避免SQL注入攻击。**#{} 会将数据作为参数传递给数据库，而不是直接拼接到SQL中**</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>预编译处理</strong>：<ul>
<li>MyBatis 会将 <code>#&#123;&#125;</code> 替换为 <code>?</code>，并使用 <code>PreparedStatement</code> 进行参数绑定。</li>
<li>参数值会被安全地传递给数据库，防止 SQL 注入。</li>
</ul>
</li>
<li><strong>自动类型转换</strong>：<ul>
<li>MyBatis 会根据参数的类型自动进行 JDBC 类型转换（如 String 转 VARCHAR）。</li>
</ul>
</li>
<li><strong>安全性高</strong>：<ul>
<li>由于使用预编译机制，<code>#&#123;&#125;</code> 可以有效防止 SQL 注入攻击。</li>
</ul>
</li>
</ul>
<p><code>\$&#123;&#125;</code> (字符拼接) ： 用于 <strong>直接将参数拼接到SQL中</strong>，可能会导致sql注入问题。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>直接替换</strong>：<ul>
<li>MyBatis 会将 <code>$&#123;&#125;</code> 中的内容直接替换为参数值，生成完整的 SQL 语句。</li>
<li>不会使用 <code>PreparedStatement</code>，而是直接拼接 SQL 字符串。</li>
</ul>
</li>
<li><strong>无类型转换</strong>：<ul>
<li>参数值会直接以字符串形式拼接到 SQL 中，不会进行 JDBC 类型转换。</li>
</ul>
</li>
<li><strong>安全性低</strong>：<ul>
<li>如果参数值来自用户输入，可能会导致 SQL 注入攻击。</li>
</ul>
</li>
</ul>
<img src="https://pic1.imgdb.cn/item/67c3125dd0e0a243d4093517.png" alt="image.png">

<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>**<code>#&#123;&#125;</code>**：<ul>
<li>安全、预编译，适合传递动态参数值。</li>
<li>推荐在大多数场景中使用。</li>
</ul>
</li>
<li>**<code>$&#123;&#125;</code>**：<ul>
<li>直接替换，适合动态表名、列名等非用户输入部分。</li>
<li>使用时需谨慎，避免 <strong>SQL 注入风险</strong>。</li>
</ul>
</li>
</ul>
<h2 id="xml和dao接口原理"><a href="#xml和dao接口原理" class="headerlink" title="xml和dao接口原理"></a>xml和dao接口原理</h2><p>核心原理是 <strong>JDBC的能力</strong> 和 <strong>动态代理</strong> ，通过解析XML映射文件和动态生成“DAO接口实现类来完成SQL</p>
<ol>
<li><strong>加载配置和Mapper</strong><ul>
<li>mybatis启动，读取配置文件mapper.xml ,</li>
<li>xml信息被解析成 MapperStatement，包含SQL，配置信息，参数规则映射结果映射</li>
</ul>
</li>
<li><strong>动态代理DAO接口：</strong><ul>
<li>Mybatis为每个DAO生成一个动态代理类（MapperProxy），拦截接口方法调用。</li>
<li>动态代理的核心是根据方法名和参数匹配到对应的<code>MapperStatement</code> ,然后调用功能JDBC</li>
</ul>
</li>
<li><strong>通过JDBC来执行SQL</strong><ul>
<li>mybatis的SqlSession是对JDBC的一个封装，它的核心是使用PreparedStatement来完成SQL的执行</li>
<li>解析sql时，对#{}进行？处理，并通过prepareStatement.setXXX来设置参数</li>
<li>JDBC执行sql，并获取ResultSet</li>
</ul>
</li>
<li><strong>获取结果映射集</strong><ul>
<li>JDBC的查询结果（ResultSet）会被Mybatis的<code>ResultMap</code> 或<code>ResultType</code> 映射为DAO接口方法的返回类型（如POJO，Map或list）</li>
</ul>
</li>
</ol>
<h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>是mybatis根据不同的条件，需求动态生成SQL语句的一种机制。主要目的：提高SQL的灵活性和复用性，在复杂的查询语句或更新场景中，根据参数动态构建不同SQL语句</p>
<p>原理：</p>
<p>动态SQL基于XML映射文件中定义的SQL判断和标签，这些标签被解析后转化成SQL被执行。</p>
<p>解析流程：</p>
<ul>
<li>解析动态SQL：在映射文件加载时，mybatis会解析动态sql</li>
<li>参数绑定：当执行sql语句时，mybatis会根据传入的参数绑定具体的值</li>
<li>生成最终的sql</li>
<li>执行sql，并返回结果集</li>
</ul>
<h2 id="是否支持懒加载"><a href="#是否支持懒加载" class="headerlink" title="是否支持懒加载"></a>是否支持懒加载</h2><p>支持</p>
<h2 id="关于MyBatsi如何实现数据库类型转化的？"><a href="#关于MyBatsi如何实现数据库类型转化的？" class="headerlink" title="关于MyBatsi如何实现数据库类型转化的？"></a>关于MyBatsi如何实现数据库类型转化的？</h2><p>主要依赖于 <strong>TypeHandler</strong> 机制</p>
<p>作用：</p>
<ul>
<li>将java对象转化为JDBC类型，用于SQL参数</li>
<li>将JDBC类型转换为Java对象，用于查询结果集</li>
</ul>
<p>具体操作流程：</p>
<ul>
<li>Mybatis在加载映射文件时，根据字段类型和java类型确定使用TypeHandler</li>
<li>在执行SQL时，<code>Parameterhandler</code> 会使用TypeHandler将Java参数转化为JDBC类型</li>
<li>在解析结果集时，<code>ResultHandler</code>会使用 TypeHandler将JDBC对象转换成Java对象。</li>
</ul>
<h2 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis-Plus"></a>Mybatis-Plus</h2><p>是对Mybatis的增强框架，它对Mybatis进行了二次封装，只做增强不做改变。通过提供一系列API方法和代码生成器，使重复的CRUD操作更加简单，无需手动编写SQL，从而大幅度提高了开发效率。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/24/springboot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/24/springboot/" class="post-title-link" itemprop="url">springboot</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-24 15:21:43" itemprop="dateCreated datePublished" datetime="2025-02-24T15:21:43+08:00">2025-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-26 22:05:55" itemprop="dateModified" datetime="2025-02-26T22:05:55+08:00">2025-02-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><img src="https://pic1.imgdb.cn/item/67bc74e9d0e0a243d403add7.png" alt="image.png">

<p>首先需要@SpringBootApplication这个注解。</p>
<p>通过SpringApplication.run来启动。</p>
<p>阶段</p>
<p><img src="https://pic1.imgdb.cn/item/67bc7543d0e0a243d403ae21.png"></p>
<p>2</p>
<p><img src="https://pic1.imgdb.cn/item/67bc75f0d0e0a243d403aeec.png"></p>
<h2 id="自己写的"><a href="#自己写的" class="headerlink" title="自己写的"></a>自己写的</h2><p>整体结构：</p>
<p><img src="https://pic1.imgdb.cn/item/67bd2b64d0e0a243d4043f9d.png"></p>
<p>首先看启动函数</p>
<p><img src="https://pic1.imgdb.cn/item/67bd2a29d0e0a243d4043f07.png"></p>
<p>点进去之后是这个：</p>
<p><img src="https://pic1.imgdb.cn/item/67bd2a4cd0e0a243d4043f1c.png"></p>
<p>这个时候就要分成两部分了，一个是 <code>new SpringApplication(primarySources)</code> 另一个是 <code>.run()</code></p>
<h4 id="new-springApplication"><a href="#new-springApplication" class="headerlink" title="new springApplication()"></a>new springApplication()</h4><p>在这个构造器里面，通常是用来初始化的。</p>
<p>具体构造是：</p>
<p><img src="https://pic1.imgdb.cn/item/67bd2b26d0e0a243d4043f85.png"></p>
<p>这里我把代码复制下来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">        <span class="built_in">this</span>.bannerMode = Mode.CONSOLE;</span><br><span class="line">        <span class="built_in">this</span>.logStartupInfo = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.addCommandLineProperties = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.addConversionService = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.headless = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.registerShutdownHook = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.additionalProfiles = Collections.emptySet();</span><br><span class="line">        <span class="built_in">this</span>.isCustomEnvironment = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.lazyInitialization = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.applicationContextFactory = ApplicationContextFactory.DEFAULT;</span><br><span class="line">        <span class="built_in">this</span>.applicationStartup = ApplicationStartup.DEFAULT;</span><br><span class="line">        <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">        Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(Arrays.asList(primarySources)); <span class="comment">// 将启动类放入primarySources（初级来源）</span></span><br><span class="line">        <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath(); <span class="comment">// 推算当前web的类型</span></span><br><span class="line">        <span class="built_in">this</span>.bootstrapRegistryInitializers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="built_in">this</span>.getSpringFactoriesInstances(BootstrapRegistryInitializer.class)); </span><br><span class="line">        <span class="built_in">this</span>.setInitializers(<span class="built_in">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));<span class="comment">// 读取初始化器</span></span><br><span class="line">        <span class="built_in">this</span>.setListeners(<span class="built_in">this</span>.getSpringFactoriesInstances(ApplicationListener.class)); <span class="comment">//读取监听器</span></span><br><span class="line">        <span class="built_in">this</span>.mainApplicationClass = <span class="built_in">this</span>.deduceMainApplicationClass(); <span class="comment">// 将main方法所在的类放入mainApplicationClass。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总结：整个过程就是初始化阶段，扩展，和保存main方法。</p>
<p>可扩展接口：</p>
<ul>
<li>ApplicationContextInitializers； 初始化器</li>
<li>ApplicationListener； 监听器</li>
</ul>
<h4 id="运行run（）"><a href="#运行run（）" class="headerlink" title="运行run（）"></a>运行run（）</h4><p>运行run方法的话会进入这个函数</p>
<p><img src="https://pic1.imgdb.cn/item/67bd2d7dd0e0a243d40440e5.png"></p>
<p>这里把run()方法的实现复制下来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime(); <span class="comment">// 记录启动开始时间</span></span><br><span class="line">    <span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> <span class="built_in">this</span>.createBootstrapContext(); <span class="comment">// 创建引导上下文（BootstrapContext）</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 初始化Spring应用上下文</span></span><br><span class="line">    <span class="built_in">this</span>.configureHeadlessProperty(); <span class="comment">// 配置Headless模式（无图形界面模式）</span></span><br><span class="line">    <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> <span class="built_in">this</span>.getRunListeners(args); <span class="comment">// 获取SpringApplicationRunListeners，用于发布启动事件</span></span><br><span class="line">    listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass); <span class="comment">// 发布应用启动事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args); <span class="comment">// 封装命令行参数</span></span><br><span class="line">        <span class="comment">// 准备环境（读取配置文件、环境变量等），并发布环境准备事件</span></span><br><span class="line">        <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="built_in">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">        <span class="built_in">this</span>.configureIgnoreBeanInfo(environment); <span class="comment">// 配置需要忽略的Bean信息</span></span><br><span class="line">        <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> <span class="built_in">this</span>.printBanner(environment); <span class="comment">// 打印Banner（启动时的Logo）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Spring应用上下文（AnnotationConfigApplicationContext或AnnotationConfigServletWebServerApplicationContext）</span></span><br><span class="line">        context = <span class="built_in">this</span>.createApplicationContext();</span><br><span class="line">        context.setApplicationStartup(<span class="built_in">this</span>.applicationStartup); <span class="comment">// 设置应用启动指标（用于性能监控）</span></span><br><span class="line">        <span class="comment">// 准备应用上下文：设置环境、注册BeanDefinition、发布上下文准备事件</span></span><br><span class="line">        <span class="built_in">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="built_in">this</span>.refreshContext(context); <span class="comment">// 刷新上下文（加载IOC容器，初始化Bean）</span></span><br><span class="line">        <span class="built_in">this</span>.afterRefresh(context, applicationArguments); <span class="comment">// 刷新后的扩展点（可用于自定义逻辑）</span></span><br><span class="line">        <span class="type">Duration</span> <span class="variable">timeTakenToStartup</span> <span class="operator">=</span> Duration.ofNanos(System.nanoTime() - startTime); <span class="comment">// 计算启动耗时</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="comment">// 打印启动信息（如启动时间、应用名称等）</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass)).logStarted(<span class="built_in">this</span>.getApplicationLog(), timeTakenToStartup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listeners.started(context, timeTakenToStartup); <span class="comment">// 发布应用启动完成事件</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>.callRunners(context, applicationArguments); <span class="comment">// 调用ApplicationRunner和CommandLineRunner</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var12) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handleRunFailure(context, var12, listeners); <span class="comment">// 处理启动失败</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var12);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Duration</span> <span class="variable">timeTakenToReady</span> <span class="operator">=</span> Duration.ofNanos(System.nanoTime() - startTime); <span class="comment">// 计算应用就绪耗时</span></span><br><span class="line">        listeners.ready(context, timeTakenToReady); <span class="comment">// 发布应用就绪事件</span></span><br><span class="line">        <span class="keyword">return</span> context; <span class="comment">// 返回初始化完成的Spring应用上下文</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var11) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handleRunFailure(context, var11, (SpringApplicationRunListeners)<span class="literal">null</span>); <span class="comment">// 处理就绪失败</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var11);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="关于-this-refreshContext-context"><a href="#关于-this-refreshContext-context" class="headerlink" title="关于 this.refreshContext(context)"></a>关于 this.refreshContext(context)</h5><p>点进去的话是这个：</p>
<p><img src="https://pic1.imgdb.cn/item/67bd31e1d0e0a243d40442a4.png"></p>
<p>最主要的还是底下的 <code>this.refresh(context)</code></p>
<p><img src="https://pic1.imgdb.cn/item/67bd3225d0e0a243d40442bd.png"></p>
<p>这里面就是加载IOC容器，类似Spring的加载</p>
<p><img src="https://pic1.imgdb.cn/item/67bd330cd0e0a243d404430a.png"></p>
<p>在这里会解析自动配置类，是在SpringIOC容器中加载。</p>
<p><img src="https://pic1.imgdb.cn/item/67bd3456d0e0a243d40443a5.png"></p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250225110644414.png" alt="image-20250225110644414"></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><strong>简化配置</strong>： SpringBoot通过自动配置（<code>@EnableAutoconfig</code>），根据项目中的类路径依赖，环境变量等自动为应用配置适当的Spring模块，避免了大量的XML</li>
<li><strong>内置服务器</strong>： Springboot内置了 Tomcat，Jetty, Undertow等服务器，应用程序可以直接通过 java -jar 启动，而不需要部署到外部的web服务器中。</li>
<li><strong>快速开发</strong>： SpringBoot提供了开箱即用的项目结构，默认资源配置和依赖管理，支持快速原型开发。它还提供了许多常用的开发工具</li>
<li><strong>独立运行</strong>: Springboot应用打包成一个独立的jar或war包，可以通过命令直接运行，简化了部署过程。</li>
</ul>
<h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>@SpringBootApplication 是Spring boot的核心注解，它是一下三个注解的组合：</p>
<ul>
<li>@configuration: 表示该类是Spring配置类</li>
<li>@EnableAutoConfigruation: 启用Springboot的自动配置功能。</li>
<li>@ComponenScan: 自动扫描当前包及其子类包带有的Spring注解类</li>
</ul>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>@EnableAutoConfiguration 是SpringBoot的自动配置核心注解，它会根据类路径中的依赖自动配置Spring应用中的各种组件。</p>
<p>例子：</p>
<p>如果应用中引入了 <code>spring-boot-starter-web</code> 依赖，SpringBoot会自动为应用配置嵌入Tomcat服务器，MVC框架等。</p>
<h2 id="Spring-Boot-的启动器（starters）"><a href="#Spring-Boot-的启动器（starters）" class="headerlink" title="Spring Boot 的启动器（starters）"></a>Spring Boot 的启动器（starters）</h2><p>Spring boot提供了一系列 <strong>Starters(启动器)</strong> ，这些启动器是预定的依赖包集合，涵盖了常用的Spring和第三方库。通过引入一个简单的启动器依赖，开发者可以快速整合需要的功能。</p>
<p>常用的starter</p>
<ul>
<li><code>spring-boot-starter-web</code> : 用于构建Web应用，包含了springMVC和嵌入式Tomcat。</li>
<li><code>spring-boot-starter-data-jpa</code>: 用于集成Spring Data JPA 和 Hibernate, 简化数据库访问</li>
<li><code>spring-boot-starter-security</code>:  用于集成Spring Security，实现身份验证和授权。</li>
<li><code>spring-boot-starter-thymeleaf</code>: 集成Thymeleaf模版引擎，适用于MVC模式下的视图层渲染。</li>
</ul>
<h2 id="Spring-Boot的自动配置"><a href="#Spring-Boot的自动配置" class="headerlink" title="Spring Boot的自动配置"></a>Spring Boot的自动配置</h2><p>SpringBoot自动配置机制依赖于 <code>spring-boot-autoconfigure</code> 模块，他会根据classpath下的 **META&#x2F;INF&#x2F;spring.factories **配置相关的Bean服务。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>Springboot自动配置的核心原理是 <code>EnableAutoConfiguration</code> 注解，根据classpath下的 **META&#x2F;INF&#x2F;spring.factories **配置相关的Bean服务。</p>
<p>这个注解包含了<code>@Import(AutoConfigurationSelector.class)</code>这个注解，通过这个注解</p>
<p>它根据项目中的依赖和 <code>application.properties</code> 和<code>application.yml</code>文件中的配置，判断需要加载哪些Bean，通过条件注解（如 @ConditionalOnClass、 @ConditionalOnMissingBean等),SpringBoot可以有选择的加载相关配置。</p>
<h2 id="SpringBoot支持的嵌入web容器"><a href="#SpringBoot支持的嵌入web容器" class="headerlink" title="SpringBoot支持的嵌入web容器"></a>SpringBoot支持的嵌入web容器</h2><ul>
<li>Tomcat(默认)<ul>
<li>Tomcat是SpringBoot默认的嵌入式Web容器。Tomcat是一种轻量级，广泛使用的Servlet容器，Spring会自动将Tomcat内嵌到应用程序中。</li>
</ul>
</li>
<li>Jetty：<ul>
<li>Jetty是一个高效的Web服务器和Servlet容器，通常用于嵌入式系统或资源占用较敏感的环境。它比Tomcat更加轻量，并且适合长连接应用（如WebSocket，Comet)</li>
</ul>
</li>
<li>Undertow:<ul>
<li>Undertow 是一个轻量级的高性能Web服务器和Servlet服务器，适合用于处理高并发的Http请求，它支持异步IO和HTTP2，是一种灵活性能出色的选择。</li>
</ul>
</li>
<li>Netty（仅限WebFlux)<ul>
<li>对于使用SpringWebFlux的响应式Web应用，SpringBoot支持Netty作为嵌入式Web容器，Netty是一个非阻塞的异步事件驱动框架，非常适合响应式编程模型和高并发应用。</li>
</ul>
</li>
</ul>
<h2 id="如何在Spring中定义和读取定义配置？"><a href="#如何在Spring中定义和读取定义配置？" class="headerlink" title="如何在Spring中定义和读取定义配置？"></a>如何在Spring中定义和读取定义配置？</h2><p><strong>1. @Value</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;my.custom.property&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String myProperty;</span><br></pre></td></tr></table></figure>

<p><strong>2. @ConfigurationProperties</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my.custom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3. Environment接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> env.getProperty(<span class="string">&quot;my.custom.property&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Boot-打成的jar-和普通的-jar有什么区别？"><a href="#Spring-Boot-打成的jar-和普通的-jar有什么区别？" class="headerlink" title="Spring Boot 打成的jar 和普通的 jar有什么区别？"></a>Spring Boot 打成的jar 和普通的 jar有什么区别？</h2><p>Spring boot 打成的jar包不仅包含了应用程序的源代码和依赖库，还包含了程序运行需要的配置，脚本和服务依赖（内嵌的服务器），<strong>可以直接部署运行</strong></p>
<p>普通jar包，只有源码和依赖，通常需要外部的服务器或容器来运行。</p>
<h4 id="如何打包成-Spring-Boot-jar包"><a href="#如何打包成-Spring-Boot-jar包" class="headerlink" title="如何打包成 Spring Boot jar包"></a>如何打包成 Spring Boot jar包</h4><p>通常可以通过这个插件来进行配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意： 主要是springboot内嵌了服务器（tomcat），所以打包的时候会带上，所以只需要有个jdk就可以运行这个jar包了。而普通的需要启动tomcat才能运行这个jar包。</p>
<h2 id="连接数和处理请求"><a href="#连接数和处理请求" class="headerlink" title="连接数和处理请求"></a>连接数和处理请求</h2><p>最大连接数8192 + 100等待， 处理请求 200</p>
<h2 id="SpringBoot如何处理跨域请求？"><a href="#SpringBoot如何处理跨域请求？" class="headerlink" title="SpringBoot如何处理跨域请求？"></a>SpringBoot如何处理跨域请求？</h2><p>CORS： （Cross-Origin Resource Sharing）</p>
<p><strong>1. 配置局部CORS</strong>， 需要使用<code>@CrossOrigin</code> 这个注解，只需要写在Controller上，参数是要跨域的地址。</p>
<p>具体实现：</p>
<p><img src="https://pic1.imgdb.cn/item/67bf0db4d0e0a243d406267e.png"></p>
<p><strong>2. 配置全局CORS</strong>， 通过实现WebMvcConfigurer，来配置跨域请求</p>
<p>具体实现：</p>
<p><img src="https://pic1.imgdb.cn/item/67bf0e50d0e0a243d406271c.png"></p>
<p><strong>3. 还可以添加CorsFilter</strong> 来处理跨域请求。（可以自定义Filter，但是没必要）</p>
<p>具体实现：</p>
<p><img src="https://pic1.imgdb.cn/item/67bf0ebfd0e0a243d406278b.png"></p>
<p>注意：</p>
<ol>
<li>跨域成功后，响应会出现一个跨域成功的响应头。</li>
<li><strong>CorsFilter -&gt; Interceptor -&gt; CorsInterceptor</strong> ，这是执行顺序，当请求在进入Cors前被拦截的话，会报跨域错误，可以使用CorsFilter解决。</li>
</ol>
<h2 id="SpringBoot中实现拦截器的操作？"><a href="#SpringBoot中实现拦截器的操作？" class="headerlink" title="SpringBoot中实现拦截器的操作？"></a>SpringBoot中实现拦截器的操作？</h2><ol>
<li>创建拦截器类，继承HandlerInterceptor接口。</li>
<li>在配置类，WebMvcConfigurer中注册拦截器addInterceptors。</li>
</ol>
<p><strong>拦截器方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;面试鸭请求开始前&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 返回 true 继续处理，false 则拦截请求</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;面试鸭请求后&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;面试鸭请求完成&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注册拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">       registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>()).addPathPatterns(<span class="string">&quot;/api/**&quot;</span>);  <span class="comment">// 拦截指定路径</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于过滤器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 过滤逻辑</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于过滤器和拦截器的执行顺序</strong></p>
<p><img src="https://pic1.imgdb.cn/item/67bf115fd0e0a243d40629cf.png"></p>
<p>可以通过@Order注解或配置类中加入的顺序定义执行顺序。</p>
<p><strong>区别对比：</strong></p>
<ol>
<li>执行时机<ul>
<li>拦截器在SpringMVC中处理请求之前或之后执行，主要拦截控制方法。</li>
<li>过滤器则在Servlet层面工作，它拦截了所有HTTP请求，不局限于SpringMVC</li>
</ul>
</li>
<li>应用场景<ul>
<li>拦截器适用于处理与控制器相关的逻辑，例如权限校验，日志记录等</li>
<li>过滤器适合处理所有HTTP请求相关操作，如字符编码设置，CORS处理等</li>
</ul>
</li>
<li>优先级<ul>
<li>过滤器的执行优先级高于拦截器，过滤器先于拦截器处理请求。</li>
</ul>
</li>
</ol>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><h2 id="SpringBoot-Actuator是什么？"><a href="#SpringBoot-Actuator是什么？" class="headerlink" title="SpringBoot Actuator是什么？"></a>SpringBoot Actuator是什么？</h2><p>actuator 执行器，驱动器</p>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Spring Actuator 是Spring Boot的一个子项目，提供了一套用于监控和管理SpringBoot应用程序的的功能。这些功能包括不但限于<strong>应用程序健康检查，指标收集，应用程序信息和环境配置等</strong>。Actuator通过提供多种可定制的端点来实现这些功能，这些端点可以通过HTTP，JMX来进行访问。具有简便性，可扩展性，安全性，易于集成。</p>
<h2 id="SpringBoot中如何实现异步处理？"><a href="#SpringBoot中如何实现异步处理？" class="headerlink" title="SpringBoot中如何实现异步处理？"></a>SpringBoot中如何实现异步处理？</h2><p><strong>1. <code>@Async</code> 注解</strong></p>
<p>它是Spring提供的注解，通过这个注解指定某个方法在另一个线程中异步执行。</p>
<p>注意：需要再启动类中配置 <code>@EableAsync</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 异步执行的代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Executing method asynchronously. &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2. 使用CompletableFuture</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">asyncMethodWithReturn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 异步执行的代码</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">&quot;Hello, mianshiya.com!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3. 使用定时任务</strong></p>
<p><code>@Scheduled</code></p>
<p>注意：同样需要再主类中，设置<code>@EableScheduled</code></p>
<p><strong>4. 使用线程池</strong></p>
<p>可以将任务显示的提交到线程池中，进行任务的异步处理，推荐使用自定义线程池，可以根据项目和任务的情况设置对应的线程池参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置代码</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;taskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">taskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">2</span>); <span class="comment">// 执行者</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">2</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">500</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;Thread-&quot;</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池的注意事项</strong></p>
<ul>
<li>合理配置线程池：根据应用的具体需求，合理的配置线程池的大小和其他参数，，以保证系统的性能和稳定性。（即使使用了@Async，本质也是利用线程池执行异步任务）</li>
<li>注意异常处理：任务中的异常处理需要关注，避免出现异常未捕获直接丢失且没有发现的情况。</li>
</ul>
<h2 id="Spring-Boot-的事件机制"><a href="#Spring-Boot-的事件机制" class="headerlink" title="Spring Boot 的事件机制"></a>Spring Boot 的事件机制</h2><p>通过 发布-订阅模式</p>
<p>作用：</p>
<ul>
<li>解耦： 通过事件机制，可以在不同组件之间传递消息，而不需要他们之间有直接的依赖关系，从而提高了代码的可维护性和扩展性。</li>
<li>异步处理： 某些事件可以异步处理，从而提高应用程序的响应速度和性能。</li>
<li>状态通知：通过事件，可以通知应用应用程序的不同部分发生某些特定的状态变化。</li>
</ul>
<p><strong>具体</strong></p>
<p>基于 <strong>观察者模式实现</strong> 。</p>
<p>需要： 事件（继承了ApplicationEvent）， 事件发布者（ApplicationEventPublisher）， 监听器（@EventListener）</p>
<p>自定义实现：</p>
<p><strong>事件定义</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">MyCustomEvent</span><span class="params">(Object source, String message)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(source);</span><br><span class="line">       <span class="built_in">this</span>.message = message;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> message;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>发布事件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventPublisher</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> ApplicationEventPublisher eventPublisher; <span class="comment">// 直接依赖注入</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(String message)</span> &#123;</span><br><span class="line">       <span class="type">MyCustomEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCustomEvent</span>(<span class="built_in">this</span>, message);</span><br><span class="line">       eventPublisher.publishEvent(event);发布</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>监听事件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">// 表示是异步处理</span></span><br><span class="line">   <span class="meta">@EventListener</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleCustomEvent</span><span class="params">(MyCustomEvent event)</span> &#123; <span class="comment">// 参数是要监听的事件</span></span><br><span class="line">       System.out.println(<span class="string">&quot;mianshiya Received event - &quot;</span> + event.getMessage());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SpringBoot中的内置事件"><a href="#SpringBoot中的内置事件" class="headerlink" title="SpringBoot中的内置事件"></a>SpringBoot中的内置事件</h4><ul>
<li>ApplicationStartingEvent: 在运行时发布</li>
<li>ApplicationEnvironmentPrepareEvent：在环境信息已准备但上下文还未创建时发布</li>
<li>ApplicationPreparedEvent：在上下文创建完成但未刷新是发布。</li>
<li>ApplicationRedyEvent：在任何相关的代码都已准备好运行时发布。</li>
<li>ApplicationFailedEvent：在启动时遇到错误是发布。</li>
</ul>
<h2 id="如何在SpringBoot启动时执行特定的代码？"><a href="#如何在SpringBoot启动时执行特定的代码？" class="headerlink" title="如何在SpringBoot启动时执行特定的代码？"></a>如何在SpringBoot启动时执行特定的代码？</h2><p>答： 一共有六种</p>
<p><strong>1. 实现接口 CommandLineRunner接口</strong></p>
<p>command 命令  line 线 runner 跑步者</p>
<p>实现这个接口后，用于在SpringBoot应用启动完成后，执行特定的代码逻辑，具体可以看springboot的启动流程。可以有多个实现类，通过 @Order来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;www.mianshiya.com: Application started!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2. 实现ApplicationRunner接口</strong></p>
<p>ApplicationRunner接口和CommandLineRunner接口类似，不过有一个ApplicationArguments参数，就是应用启动参数。</p>
<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ApplicationRunner: mianshiya.com started with arguments: &quot;</span> + args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用@PostConstruct注解</strong></p>
<p>Spring容器初始化bean后，会执行初始化方法。这个注解适用于需要在bean初始化后立即执行的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPostConstructBean</span> &#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PostConstruct: Bean initialized!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// construct 构建</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>4. 使用InitializingBean接口</strong></p>
<p>提供了方法，用于在Spring容器初始化bean的属性后执行，执行特定的初始化逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInitializingBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InitializingBean: Properties set!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>5. 使用Spring 事件监听器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventListener</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;EventListener: Context refreshed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>6. 自定义BeanFactoryPostProcessor 和 BeanPostProcessor</strong></p>
<p>他们都是Spring容器给的扩展点，可以在Spring容器初始化bean之前或之后执行特定的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">         <span class="comment">// bean 初始化前</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MySpecificBean) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BeanPostProcessor: Before initialization of &quot;</span> + mianshiya.com);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">       <span class="comment">// bean 初始化后</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MySpecificBean) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BeanPostProcessor: After initialization of &quot;</span> + mianshiya.com);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/23/springMVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/23/springMVC/" class="post-title-link" itemprop="url">springMVC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-02-23 15:15:29 / 修改时间：16:12:45" itemprop="dateCreated datePublished" datetime="2025-02-23T15:15:29+08:00">2025-02-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="结果流程图"><a href="#结果流程图" class="headerlink" title="结果流程图"></a>结果流程图</h2><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250223151556493.png" alt="image-20250223151556493"></p>
<p><img src="https://pic1.imgdb.cn/item/67bacd78d0e0a243d402794b.png"></p>
<p>介绍：</p>
<p>首先，SpringMVC 是属于 <strong>SpringFramework</strong> 生态里面的一个模块， 它是在 Serlet 的基础上构建，并且使用了<strong>MVC模式</strong>，设计的一个Web框架，它的目的是为了简化传统的 <strong>Servlet+JSP</strong> 模式下的Web开发方式，其次 SpringMVC 的整个架构设计是对Java Web里面的MVC框架模式做了一些<strong>增强和扩展</strong>，主要体现在以下几个方面：</p>
<ul>
<li>把传统MVC框架里面的Controller控制器做了拆分，分成了<strong>前端控制器Dispactcherservlet</strong>和<strong>后端控制器Controller</strong>。</li>
<li>把Model模型拆分成了<strong>业务层的Service和数据访问层的Repository</strong>。</li>
<li>在视图层面，可以支持不同的视图<strong>Freemark,velocity,JSP</strong>等</li>
</ul>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p><strong>Dispatcherservlet:</strong> 它是SpringMVC的核心，他是一个Servlet，负责接受HTTP请求并调度请求到适当的处理器。</p>
<p><strong>@Controller和@RequestMapping：</strong> 前者用于标记控制类，后者则用于定义控制类中的方法和URL请求的映射关系。</p>
<p><strong>ModelAndView</strong> : 控制返回的数据和视图封装在 ModelAndView 对象中。</p>
<p><strong>ViewResolver（视图解析器）</strong>: 它负责将逻辑视图名称解析为物理视图，Spring提供了多种视图解析器。</p>
<p><strong>@RequestParam和@PathVariable</strong>： 用于获取请求参数，后者用于获取URL中的路径变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> String userId)</span> &#123;</span><br><span class="line">  <span class="comment">// 使用请求参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String userId)</span> &#123;</span><br><span class="line">  <span class="comment">// 使用路径变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表单处理和数据绑定"><a href="#表单处理和数据绑定" class="headerlink" title="表单处理和数据绑定"></a>表单处理和数据绑定</h2><p>SpringMVC提供了强大的表单处理和数据绑定，允许将表单数据直接绑定到模型对象中。</p>
<p><strong>数据绑定：</strong> 通过 <code>@ModelAttroibute</code> 注解，Spring自动将表单数据绑定到模型对象上，并将其传递给控制方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/submitForm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">submitForm</span><span class="params">(<span class="meta">@ModelAttribute(&quot;user&quot;)</span> User user)</span> &#123;</span><br><span class="line">  <span class="comment">// 处理表单提交的数据</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>表单校验：</strong> <code>@Valid</code>  和  <code>BindingResult</code></p>
<h2 id="SpringMVC的全局异常处理"><a href="#SpringMVC的全局异常处理" class="headerlink" title="SpringMVC的全局异常处理"></a>SpringMVC的全局异常处理</h2><p><strong>全局异常处理：</strong> 通过 <code>@ControllerAdvice</code> 和<code>@ExceptionHandler</code> 注解可以定义全局异常处理器，捕获应用中抛出的异常，并进行统一的异常处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">  <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">handleException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">      <span class="comment">// 处理异常</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringMVC的拦截器"><a href="#SpringMVC的拦截器" class="headerlink" title="SpringMVC的拦截器"></a>SpringMVC的拦截器</h2><h3 id="1-Spring-MVC-请求处理流程"><a href="#1-Spring-MVC-请求处理流程" class="headerlink" title="1. Spring MVC 请求处理流程"></a>1. <strong>Spring MVC 请求处理流程</strong></h3><p>Spring MVC 的请求处理流程大致如下：</p>
<ol>
<li>**请求到达 <code>DispatcherServlet</code>**：<ul>
<li><code>DispatcherServlet</code> 是 Spring MVC 的核心组件，负责接收所有的 HTTP 请求。</li>
</ul>
</li>
<li>**调用 <code>HandlerMapping</code>**：<ul>
<li><code>DispatcherServlet</code> 通过 <code>HandlerMapping</code> 找到与请求匹配的处理器（Handler），通常是控制器方法。</li>
</ul>
</li>
<li><strong>执行拦截器的 <code>preHandle</code> 方法</strong>：！！<ul>
<li>在找到处理器之后，<code>DispatcherServlet</code> 会调用拦截器链中的 <code>preHandle</code> 方法。</li>
<li>如果某个拦截器的 <code>preHandle</code> 方法返回 <code>false</code>，则请求处理终止，后续的拦截器和控制器方法都不会执行。</li>
</ul>
</li>
<li><strong>执行控制器方法</strong>：<ul>
<li>如果所有拦截器的 <code>preHandle</code> 方法都返回 <code>true</code>，则 <code>DispatcherServlet</code> 会调用控制器方法处理请求。</li>
</ul>
</li>
<li><strong>执行拦截器的 <code>postHandle</code> 方法</strong>：！！<ul>
<li>在控制器方法执行完成后，<code>DispatcherServlet</code> 会调用拦截器链中的 <code>postHandle</code> 方法。</li>
</ul>
</li>
<li><strong>渲染视图</strong>：<ul>
<li>如果控制器方法返回了一个视图名称，<code>DispatcherServlet</code> 会调用 <code>ViewResolver</code> 解析视图并渲染。</li>
</ul>
</li>
<li><strong>执行拦截器的 <code>afterCompletion</code> 方法</strong>：！！<ul>
<li>在视图渲染完成后，<code>DispatcherServlet</code> 会调用拦截器链中的 <code>afterCompletion</code> 方法。</li>
</ul>
</li>
</ol>
<h3 id="2-设置拦截器"><a href="#2-设置拦截器" class="headerlink" title="2. 设置拦截器"></a>2. 设置拦截器</h3><p>实现HandlerInterceptor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 在处理器方法调用前进行拦截</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 处理器方法执行后，但视图渲染前执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 视图渲染后执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在配置类中注册拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>) <span class="comment">// 拦截所有路径</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/error&quot;</span>); <span class="comment">// 排除某些路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringMVC的父子容器"><a href="#SpringMVC的父子容器" class="headerlink" title="SpringMVC的父子容器"></a>SpringMVC的父子容器</h2><p>在 Spring MVC 中，<strong>父子容器</strong>是一种常见的架构设计，用于将 <strong>Spring MVC 容器</strong>（子容器）和 <strong>Spring 根容器</strong>（父容器）分离。这种设计有助于清晰地划分职责，并解决 Bean 的重复加载和冲突问题。</p>
<hr>
<h3 id="1-父子容器的概念"><a href="#1-父子容器的概念" class="headerlink" title="1. 父子容器的概念"></a>1. <strong>父子容器的概念</strong></h3><ul>
<li><strong>父容器（Root ApplicationContext）</strong>：<ul>
<li>通常用于管理业务逻辑层的 Bean，例如 Service、Repository、DataSource 等。</li>
<li>父容器由 <code>ContextLoaderListener</code> 初始化，加载的配置文件通常是 <code>applicationContext.xml</code> 或通过 Java 配置类。</li>
<li>父容器是全局的，可以被多个子容器共享。</li>
</ul>
</li>
<li><strong>子容器（Web ApplicationContext）</strong>：<ul>
<li>通常用于管理 Web 层的 Bean，例如 Controller、HandlerMapping、ViewResolver 等。</li>
<li>子容器由 <code>DispatcherServlet</code> 初始化，加载的配置文件通常是 <code>spring-servlet.xml</code> 或通过 Java 配置类。</li>
<li>子容器可以访问父容器中的 Bean，但父容器不能访问子容器中的 Bean。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-父子容器的关系"><a href="#2-父子容器的关系" class="headerlink" title="2. 父子容器的关系"></a>2. <strong>父子容器的关系</strong></h3><ul>
<li><strong>继承关系</strong>：<ul>
<li>子容器是父容器的子容器，子容器可以访问父容器中的 Bean，但父容器不能访问子容器中的 Bean。</li>
<li>这种设计使得 Web 层可以共享业务逻辑层的 Bean，同时保持职责分离。</li>
</ul>
</li>
<li><strong>Bean 查找规则</strong>：<ul>
<li>当子容器查找一个 Bean 时，会先在子容器中查找。如果找不到，则会到父容器中查找。</li>
<li>这种机制避免了 Bean 的重复定义和冲突。</li>
</ul>
</li>
</ul>
<h3 id="3-父子容器的优点5"><a href="#3-父子容器的优点5" class="headerlink" title="3. *父子容器的优点5"></a>3. *<em>父子容器的优点</em>5</h3><ul>
<li><strong>职责分离</strong>：<ul>
<li>父容器负责业务逻辑层的 Bean，子容器负责 Web 层的 Bean，职责清晰。</li>
</ul>
</li>
<li><strong>避免 Bean 冲突</strong>：<ul>
<li>父子容器的设计避免了 Bean 的重复定义和冲突。</li>
</ul>
</li>
<li><strong>共享 Bean</strong>：<ul>
<li>子容器可以访问父容器中的 Bean，方便共享业务逻辑层的组件。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-父子容器的注意事项"><a href="#4-父子容器的注意事项" class="headerlink" title="4. 父子容器的注意事项"></a>4. <strong>父子容器的注意事项</strong></h3><ul>
<li><strong>Bean 的作用范围</strong>：<ul>
<li>如果某个 Bean 在父容器和子容器中都定义了，子容器会优先使用自己定义的 Bean。</li>
</ul>
</li>
<li><strong>AOP 配置</strong>：<ul>
<li>如果需要在父子容器中共享 AOP 配置，建议将 AOP 配置放在父容器中。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>父容器</strong>：管理业务逻辑层的 Bean，由 <code>ContextLoaderListener</code> 初始化。</li>
<li><strong>子容器</strong>：管理 Web 层的 Bean，由 <code>DispatcherServlet</code> 初始化。</li>
<li><strong>父子容器的关系</strong>：子容器可以访问父容器中的 Bean，但父容器不能访问子容器中的 Bean。</li>
<li><strong>优点</strong>：职责分离、避免 Bean 冲突、共享 Bean。</li>
</ul>
<p>父子容器的设计是 Spring MVC 中一种常见的架构模式，能够有效组织和管理应用程序的组件。</p>
<h2 id="关于applicationcontext的初始化"><a href="#关于applicationcontext的初始化" class="headerlink" title="关于applicationcontext的初始化"></a>关于applicationcontext的初始化</h2><hr>
<h3 id="1-ApplicationContext-的初始化方式"><a href="#1-ApplicationContext-的初始化方式" class="headerlink" title="1. ApplicationContext 的初始化方式"></a>1. <strong><code>ApplicationContext</code> 的初始化方式</strong></h3><p><code>ApplicationContext</code> 可以通过多种方式初始化，具体取决于项目的类型和配置：</p>
<ul>
<li><p><strong>手动初始化</strong>：通过代码显式地创建 <code>ApplicationContext</code>，例如：</p>
<p>java</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure>

<p>这种方式通常用于独立的 Java 应用程序（非 Web 应用）。</p>
</li>
<li><p><strong>自动初始化</strong>：在 Web 应用中，<code>ApplicationContext</code> 通常由 Spring 的相关组件（如 <code>ContextLoaderListener</code> 或 <code>DispatcherServlet</code>）自动初始化。</p>
</li>
</ul>
<hr>
<h3 id="2-Web-应用中的-ApplicationContext-初始化"><a href="#2-Web-应用中的-ApplicationContext-初始化" class="headerlink" title="2. Web 应用中的 ApplicationContext 初始化"></a>2. <strong>Web 应用中的 <code>ApplicationContext</code> 初始化</strong></h3><p>在 Spring MVC 的 Web 应用中，<code>ApplicationContext</code> 的初始化通常分为两部分：</p>
<ul>
<li><p><strong>父容器（Root ApplicationContext）</strong>：</p>
<ul>
<li><p>由 <code>ContextLoaderListener</code> 初始化。</p>
</li>
<li><p>负责加载业务逻辑层的 Bean（如 Service、Repository 等）。</p>
</li>
<li><p>在 <code>web.xml</code> 中配置：</p>
<p>xml</p>
<p>复制</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>运行 HTML</p>
</li>
</ul>
</li>
<li><p><strong>子容器（Web ApplicationContext）</strong>：</p>
<ul>
<li><p>由 <code>DispatcherServlet</code> 初始化。</p>
</li>
<li><p>负责加载 Web 层的 Bean（如 Controller、HandlerMapping 等）。</p>
</li>
<li><p>在 <code>web.xml</code> 中配置：</p>
<p>xml</p>
<p>复制</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>运行 HTML</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-为什么说-ApplicationContext-是由-ContextLoaderListener-初始化的？"><a href="#3-为什么说-ApplicationContext-是由-ContextLoaderListener-初始化的？" class="headerlink" title="3. 为什么说 ApplicationContext 是由 ContextLoaderListener 初始化的？"></a>3. <strong>为什么说 <code>ApplicationContext</code> 是由 <code>ContextLoaderListener</code> 初始化的？</strong></h3><ul>
<li>在 Web 应用中，<code>ContextLoaderListener</code> 是一个 Servlet 监听器，它会在 Web 应用启动时自动初始化父容器（Root ApplicationContext）。</li>
<li>这种设计是为了将 Spring 容器的初始化与 Web 容器的生命周期绑定，避免手动管理 <code>ApplicationContext</code> 的创建和销毁。</li>
<li>通过 <code>ContextLoaderListener</code>，Spring 可以自动加载配置文件并初始化父容器，而不需要开发者显式地调用 <code>new</code> 来创建 <code>ApplicationContext</code>。</li>
</ul>
<hr>
<h3 id="4-手动初始化-vs-自动初始化"><a href="#4-手动初始化-vs-自动初始化" class="headerlink" title="4. 手动初始化 vs 自动初始化"></a>4. <strong>手动初始化 vs 自动初始化</strong></h3><ul>
<li><p><strong>手动初始化</strong>：</p>
<ul>
<li><p>适用于独立的 Java 应用程序。</p>
</li>
<li><p>开发者需要显式地创建 <code>ApplicationContext</code>，并管理其生命周期。</p>
</li>
<li><p>示例：</p>
<p>java</p>
<p>复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>自动初始化</strong>：</p>
<ul>
<li>适用于 Web 应用程序。</li>
<li>由 <code>ContextLoaderListener</code> 或 <code>DispatcherServlet</code> 自动初始化 <code>ApplicationContext</code>。</li>
<li>开发者只需在 <code>web.xml</code> 或 Java 配置类中定义配置，Spring 会自动完成容器的初始化和销毁。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h3><ul>
<li>在 <strong>Web 应用</strong> 中，<code>ApplicationContext</code> 通常是由 <code>ContextLoaderListener</code> 或 <code>DispatcherServlet</code> 自动初始化的，而不是通过 <code>new</code> 手动创建的。</li>
<li>这种设计是为了将 Spring 容器的生命周期与 Web 容器的生命周期绑定，简化开发者的工作。</li>
<li>在 <strong>独立应用</strong> 中，开发者可以手动创建 <code>ApplicationContext</code>。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/23/springcloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/23/springcloud/" class="post-title-link" itemprop="url">springcloud</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-23 13:05:04" itemprop="dateCreated datePublished" datetime="2025-02-23T13:05:04+08:00">2025-02-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/21/spring%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/21/spring%E6%BA%90%E7%A0%81/" class="post-title-link" itemprop="url">spring源码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-21 14:36:18" itemprop="dateCreated datePublished" datetime="2025-02-21T14:36:18+08:00">2025-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-10 23:04:33" itemprop="dateModified" datetime="2025-03-10T23:04:33+08:00">2025-03-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><img src="https://pic1.imgdb.cn/item/67ceff5a066befcec6e27f31.png" alt="Spring.png">

<h2 id="Spring的启动流程"><a href="#Spring的启动流程" class="headerlink" title="Spring的启动流程"></a>Spring的启动流程</h2><p>什么是spring容器？</p>
<p>管理Bean对象，通过依赖注入组织Bean之间关系，从而降低业务对象之间耦合性， -IOC</p>
<p>学习Spring容器的启动流程，就是去学校application context 的创建过程</p>
<img src="https://pic1.imgdb.cn/item/67b98643d0e0a243d401e754.png" alt="image.png">

<p>创建：ApplicationContext</p>
<img src="https://pic1.imgdb.cn/item/67b98688d0e0a243d401e7a7.png" alt="image.png">

<p>创建容器后，通过getBean来获取Bean对象</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222161328079.png" alt="image-20250222161328079"></p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222163135114.png" alt="image-20250222163135114"></p>
<h3 id="读取配置类"><a href="#读取配置类" class="headerlink" title="读取配置类"></a>读取配置类</h3><p>读取配置类，通过配置类来找到要读取的xml文件，来加载Bean。</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222161521409.png" alt="image-20250222161521409"></p>
<p>上：读取配置类，来加载Bean信息</p>
<p>下：读取Xml文件，来读取Bean信息</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>读取完配置信息后，这些配置就会存储到<strong>BeanDefinition</strong>的对象中。</p>
<p>他是个接口，查看它的实现类，里面会存储配置的信息</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222162024143.png" alt="image-20250222162024143"></p>
<p>这些都是将配置信息复制到实现类中。</p>
<p>通常情况下， 有一个Bean 就会有一个 <strong>BeanDefinition</strong>。</p>
<p>这些保存在一个集合中， <strong>BeanDefinitionMap &lt; beanName, BeanDefiniton&gt;</strong> </p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222162449029.png" alt="image-20250222162449029"> </p>
<h3 id="创建Bean"><a href="#创建Bean" class="headerlink" title="创建Bean"></a>创建Bean</h3><p>循环BeanDefinition，获取Bean信息，懒加载则不会创建，判断是不是多例Bean</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222162829953.png" alt="image-20250222162829953"></p>
<p>可以通过@Scope 改变Bean的类型。</p>
<p>singlenObjects&lt;beanName, Object&gt; 存储Bean对象的map。从里面获取bean。</p>
<h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222164210750.png" alt="image-20250222164210750"></p>
<p>未获取到则创建Bean - 》 拿 BeanDfinitio。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>实例化， 通过反射的方式获取对象实例。</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222164559415.png" alt="image-20250222164559415"></p>
<h4 id="初始化方法回调"><a href="#初始化方法回调" class="headerlink" title="初始化方法回调"></a>初始化方法回调</h4><p>初始化方法回调的方式有三种</p>
<ul>
<li>实现接口InitializingBean，通过实现里面的初始化方法来初始化。</li>
<li>通过注解 @PostConstruct，来把注解的方法变成初始化方法。</li>
<li>通过xml来初始化。</li>
</ul>
<p>初始化完成后，会将Bean放入单例池中。</p>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p>实例化 -》 依赖注入 -》 初始化 -》 放入单例池中 -&gt; 销毁</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222165416502.png" alt="image-20250222165416502"></p>
<p>销毁方法回调的三种方式</p>
<ul>
<li>DisposableBean接口来实现销毁方法回调。</li>
</ul>
<p>实例化时， 会通过反射的方式，去推断构造函数，默认会调用无参函数。</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222165809114.png" alt="image-20250222165809114"></p>
<p>通过反射的方式获取工厂方法，来获取对应的Bean。</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222165930034.png" alt="image-20250222165930034"></p>
<p>初始化这里会调用初始化方法，还会调用Aware。</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222170905614.png" alt="image-20250222170905614"></p>
<p>会调用9次后置处理器。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222171307910.png" alt="image-20250222171307910"></p>
<p>BeanFactory没有读取配置的功能，需要传入BenaDefinition。</p>
<h3 id="不使用applicationcontext读取配置类"><a href="#不使用applicationcontext读取配置类" class="headerlink" title="不使用applicationcontext读取配置类"></a>不使用applicationcontext读取配置类</h3><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222172029850.png" alt="image-20250222172029850"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/20/spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/20/spring/" class="post-title-link" itemprop="url">spring</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-20 10:24:06" itemprop="dateCreated datePublished" datetime="2025-02-20T10:24:06+08:00">2025-02-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-21 14:35:55" itemprop="dateModified" datetime="2025-02-21T14:35:55+08:00">2025-02-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="跨平台的原理"><a href="#跨平台的原理" class="headerlink" title="跨平台的原理"></a>跨平台的原理</h2><p>JVM是运行在操作系统上的程序，不同的操作系统的安装包不同。</p>
<p>不同的操作系统上的JVM不同，这才是JVM跨平台的本质。</p>
<p><strong>字节码的作用</strong></p>
<p><img src="https://pic1.imgdb.cn/item/67b6c659d0e0a243d400edfb.png"></p>
<p><strong>JVM与字节码</strong></p>
<p><img src="https://pic1.imgdb.cn/item/67b6c745d0e0a243d400ee5f.png"></p>
<h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h2><p><img src="https://pic1.imgdb.cn/item/67b6c8c3d0e0a243d400eef2.png"></p>
<p>方法区通常是class对象</p>
<h3 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h3><p><img src="https://pic1.imgdb.cn/item/67b6c9f3d0e0a243d400ef25.png"></p>
<p>类加载器的分类</p>
<p><img src="https://pic1.imgdb.cn/item/67b6ca90d0e0a243d400ef6d.png"></p>
<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>加载类的本质是得到类的class对象</p>
<p><img src="https://pic1.imgdb.cn/item/67b6cbcad0e0a243d400efbc.png"></p>
<p>AppClassLoader 会在需要加载时，查找目录，看看这个类是否已经加载，若未加载，则调用父类ExtClassLoader来查找目录，BootStrapClassLoader同理。若加载过，则返回对应类，若未加载，则返回null，让子类加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.class.getClassLoad(); <span class="comment">// 获取类加载器。可以通过类加载器来加载对应的类。</span></span><br></pre></td></tr></table></figure>



<h3 id="Tomcat为什么要自定义类加载器？"><a href="#Tomcat为什么要自定义类加载器？" class="headerlink" title="Tomcat为什么要自定义类加载器？"></a>Tomcat为什么要自定义类加载器？</h3><p><img src="https://pic1.imgdb.cn/item/67b6cf65d0e0a243d400f0c8.png"></p>
<p>目的实现隔离</p>
<h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p><img src="https://pic1.imgdb.cn/item/67b6d159d0e0a243d400f19c.png"></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p><img src="https://pic1.imgdb.cn/item/67b6d1f3d0e0a243d400f1f4.png"></p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p><img src="https://pic1.imgdb.cn/item/67b6e100d0e0a243d400f820.png"></p>
<p><img src="https://pic1.imgdb.cn/item/67b6e138d0e0a243d400f839.png"></p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p><img src="https://pic1.imgdb.cn/item/67b6e1e2d0e0a243d400f87c.png"></p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p><img src="https://pic1.imgdb.cn/item/67b6e2ead0e0a243d400f8b0.png"></p>
<p>OOM： 内存溢出异常</p>
<p>SOF： 栈多次调用</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><img src="https://pic1.imgdb.cn/item/67b6e33cd0e0a243d400f8cd.png"></p>
<h5 id="什么是-YoungGC，Full-GC，-MinorGC"><a href="#什么是-YoungGC，Full-GC，-MinorGC" class="headerlink" title="什么是 YoungGC，Full GC， MinorGC"></a>什么是 YoungGC，Full GC， MinorGC</h5><p><img src="https://pic1.imgdb.cn/item/67b6e658d0e0a243d400f9a4.png"></p>
<h5 id="为什么要进行垃圾回收呢？"><a href="#为什么要进行垃圾回收呢？" class="headerlink" title="为什么要进行垃圾回收呢？"></a>为什么要进行垃圾回收呢？</h5><p>垃圾是指在JVM中没有任何引用指向它的对象，如果不清理这些垃圾对象，那么他们就一直占用这内存，而不能给其他对象使用，最终垃圾对象越来越多，就会出现OOM</p>
<p><strong>垃圾标记阶段</strong></p>
<p>也就是JVM中（主要是堆中）有哪些垃圾对象，有两种方式：</p>
<ul>
<li>引用计数法</li>
<li>可达性分析法</li>
</ul>
<p><strong>引用计数法</strong>（很少用）</p>
<p>每个对象都保存一个引用计数器属性，用户记录对象被引用次数。</p>
<p>优点： 实现简单，计数器为0则表示是垃圾回收对象</p>
<p>缺点：</p>
<ul>
<li>需要额外的空间来存储引用计数</li>
<li>以及需要额外的时间来维护引用计数</li>
<li>还有一个严重问题，无法处理循环引用的问题</li>
</ul>
<p><strong>可达性分析法</strong></p>
<p>可达分析法会以GC Roots 作为起始点，然后一层一层找到所引用的对象，被找到的对象就是存活对象，那么其他不可达的对象就是垃圾对象。</p>
<p><img src="https://pic1.imgdb.cn/item/67b6e9acd0e0a243d400fae5.png"></p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250220163814715.png" alt="image-20250220163814715"></p>
<p><strong>标记清除算法</strong></p>
<p>一种非常基础和常用的垃圾回收算法，针对某一块内存空间，比如新生代，老年代，如果可用内存不足后，就会STW，暂定用户线程的执行，然后执行算法进行垃圾回收。</p>
<ol>
<li>标记阶段：从GC Roots开始遍历找到可达对象，并在对象头中进行记录。</li>
<li>清除阶段： 堆空间进行线性遍历，如果发现对象头中没有记录是可达对象，则回收它。</li>
</ol>
<p>缺点：</p>
<ol>
<li>效率不高</li>
<li>存在内存碎片</li>
</ol>
<p>优点：思路简单</p>
<p><strong>复制算法</strong></p>
<p><img src="https://pic1.imgdb.cn/item/67b6ec05d0e0a243d400fb6b.png"></p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250220164729281.png" alt="image-20250220164729281"></p>
<p>优点：</p>
<ol>
<li>没有标记和清除阶段， 通过GC Roots 找到可达对象，直接复制，不需要修改对象头，效率更高。</li>
<li>不会出现内存碎片。</li>
</ol>
<p>缺点；</p>
<ol>
<li>需要更多内存，始终有一半空闲</li>
<li>对象复制后，对象存放的内存地址发生变化，需要额外的时间修改栈帧中记录的地址</li>
<li>如果可达对象比较多，垃圾对象少，那么复制算法的效率就会比较低，所以垃圾对象多的情况下，复制算法比较合适。</li>
</ol>
<p><strong>标记整理算法</strong></p>
<p><img src="https://pic1.imgdb.cn/item/67b6ed09d0e0a243d400fbe1.png"></p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250220165117992.png" alt="image-20250220165117992"></p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250220165156641.png" alt="image-20250220165156641"></p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250220165227467.png" alt="image-20250220165227467"></p>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250220165545242.png" alt="image-20250220165545242"></p>
<h4 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h4><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250220165629075.png" alt="image-20250220165629075"></p>
<p>STW 停止等待状态： 它的存在是因为Java的垃圾回收器需要扫描整个堆内存来标记和清除不再使用的对象，如果不停止应用的线程的话，会导致垃圾回收器扫描是出现漏标和误删的情况。</p>
<h5 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h5><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250220170324112.png" alt="image-20250220170324112"></p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250220170533820.png" alt="image-20250220170533820"></p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250220170600689.png" alt="image-20250220170600689"></p>
<h5 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h5><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250220170843704.png" alt="image-20250220170843704"></p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250220170927390.png" alt="image-20250220170927390"></p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250220170944539.png" alt="image-20250220170944539"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/19/%E9%9D%A2%E8%AF%95%E8%AE%AD%E7%BB%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/19/%E9%9D%A2%E8%AF%95%E8%AE%AD%E7%BB%83/" class="post-title-link" itemprop="url">面试训练</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-19 08:41:47" itemprop="dateCreated datePublished" datetime="2025-02-19T08:41:47+08:00">2025-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-10 15:21:54" itemprop="dateModified" datetime="2025-03-10T15:21:54+08:00">2025-03-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h2><h3 id="Mysql的存储引擎有哪些？他们之间的区别是什么？"><a href="#Mysql的存储引擎有哪些？他们之间的区别是什么？" class="headerlink" title="Mysql的存储引擎有哪些？他们之间的区别是什么？"></a>Mysql的存储引擎有哪些？他们之间的区别是什么？</h3><p>在8.4版本的mysql中，支持的存储引擎有10个，这里着重分析一下比较重要的三个存储引擎，<strong>Innodb，MyISAM，Memory</strong>。</p>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><ul>
<li>采用聚簇索引，索引值和数据行存储在一起（B+树结构）</li>
<li>支持事务，和外键</li>
<li>采用行级锁</li>
<li>不支持全文索引，在5.6.4版本之后支持全文索引</li>
<li>默认隔离级别是可重复读，并且存储持久化。</li>
<li>采用MVCC多版本并发控制</li>
</ul>
<p><strong>优势：</strong>高并发，事务安全，支持外键支持崩溃恢复（redo日志）</p>
<p><strong>缺点：</strong> 相比与<strong>MyISAM</strong>占用更多的存储空间，全文索引在mysql5.6之后才支持。</p>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ul>
<li>采用非聚簇索引，叶子结点保存的是数据的物理地址（B+树结构）</li>
<li>不支持事务和外键</li>
<li>采用表级锁</li>
<li>支持全文索引</li>
</ul>
<p><strong>优势：</strong> 在只读情况下，效率高，比Innodb占用空间少</p>
<p><strong>缺点：</strong>当有写操作时，由于是表级锁，效率低，需要手动崩溃恢复</p>
<h4 id="Memeory"><a href="#Memeory" class="headerlink" title="Memeory"></a>Memeory</h4><ul>
<li>存储在内存中，读取速度快，无法数据持久化</li>
<li>表级锁，并发情况下可能性能受限。</li>
<li>不支持事务和外键</li>
<li>底层采用<strong>哈希索引</strong>（Hash Table），支持<strong>B树</strong></li>
</ul>
<p><strong>优势</strong>： 读取速度快，高速数据访问</p>
<p><strong>缺点：</strong> 存储大小受限，无法做到数据持久化，通常用来临时存储</p>
<h4 id="扩展-Mysql-的InnoDB存储引擎和MyISAM存储存储引擎有什么不同？"><a href="#扩展-Mysql-的InnoDB存储引擎和MyISAM存储存储引擎有什么不同？" class="headerlink" title="扩展 Mysql 的InnoDB存储引擎和MyISAM存储存储引擎有什么不同？"></a>扩展 Mysql 的InnoDB存储引擎和MyISAM存储存储引擎有什么不同？</h4><p><img src="https://pic1.imgdb.cn/item/67b5cf89d0e0a243d400cdf5.png"></p>
<p>这里比起<strong>MyISAM</strong>存储引擎，<strong>InnoDB</strong>采用的是聚簇索引，叶子结点存储的是索引值和数据行。</p>
<p>MyISAM的叶子结点存储的是数据的物理地址，采用了数据和索引分离的方式。</p>
<p>而InnoDB则是由于其需要支持事务和外键。</p>
<p>优点：</p>
<p><strong>1. 保证了事务支持和数据一致性</strong></p>
<ul>
<li>InnoDB 是一个支持事务的存储引擎，需要保证数据的 ACID 特性（原子性、一致性、隔离性、持久性）。</li>
<li>为了实现事务的隔离性和一致性，InnoDB 需要将数据与索引紧密关联，确保在事务中能够快速定位和锁定数据。</li>
<li>如果采用 MyISAM 的方式（索引和数据分离），事务的实现会变得复杂，性能也会受到影响</li>
</ul>
<p><strong>2. 聚簇设计</strong></p>
<ul>
<li>排列数据有序方便搜索，叶子结点本身存储数据行</li>
<li>MyISAM数据无需，范围查找效率低</li>
</ul>
<p><strong>3. 辅助索引设置</strong></p>
<ul>
<li>InnoDB采用二级索引，<strong>数据移动时无需更新辅助索引</strong>：如果数据行的物理地址发生变化（例如数据页分裂），辅助索引无需更新，因为它存储的是主键值。</li>
<li><strong>支持行级锁</strong>：InnoDB 的行级锁是基于主键实现的，辅助索引通过主键值定位数据行，可以高效地加锁。</li>
</ul>
<p><strong>4. 采用聚簇索引的原因</strong></p>
<ul>
<li>InnoDB 需要支持外键约束、MVCC（多版本并发控制）等高级功能。</li>
<li>聚簇索引的设计使得这些功能更容易实现。例如：<ul>
<li>MVCC 需要存储多个版本的数据行，聚簇索引可以高效地管理这些版本。</li>
<li>外键约束需要快速定位相关数据行，聚簇索引提供了高效的查找能力。</li>
</ul>
</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><p>InnoDB 更适合高并发和事务处理的场景 </p>
</li>
<li><p>MyISAM 则适合读操作较多的场景。</p>
</li>
</ul>
<h3 id="MySQL-InnoDB-引擎中的聚簇索引和非聚簇索引有什么区别？"><a href="#MySQL-InnoDB-引擎中的聚簇索引和非聚簇索引有什么区别？" class="headerlink" title="MySQL InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别？"></a>MySQL InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别？</h3><p><strong>聚簇索引</strong></p>
<ul>
<li>通常是主键索引，只能出现一个。</li>
<li>叶子节点存储的是索引值和数据行。</li>
<li>B+树按照主键排序，非叶子节点存储的是主键值，无数据行</li>
</ul>
<p><strong>非聚簇索引</strong></p>
<ul>
<li>又叫做二级索引，通常作为辅助索引，可以存在多个（不建议太多，会占用资源，维护消耗也大）</li>
<li>叶子结点存储的是索引值和主键值</li>
<li>B+树按照索引排序，非叶子结点存储索引</li>
<li>通常需要回表，索引覆盖等操作</li>
</ul>
<h3 id="MySQL的索引类型有哪些？"><a href="#MySQL的索引类型有哪些？" class="headerlink" title="MySQL的索引类型有哪些？"></a>MySQL的索引类型有哪些？</h3><p>基于 <strong>数据结构</strong> ：</p>
<ul>
<li>B+树索引</li>
<li>Hash索引</li>
<li>全文索引（Full-Text）</li>
<li>R-树索引</li>
</ul>
<p>基于 <strong>B+树：</strong></p>
<ul>
<li>聚簇索引</li>
<li>非聚簇索引</li>
</ul>
<p>基于 <strong>索引性质</strong>：</p>
<ul>
<li>主键索引（一个表唯一）非空，字段不重复</li>
<li>唯一索引：字段可以为空，但是非空字段唯一</li>
<li>联合索引（最左前缀匹配）</li>
<li>普通索引：无要求</li>
<li>全文索引</li>
<li>空间索引</li>
</ul>
<h2 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h2><h3 id="为什么MySQL采用B-树来作为索引结构？"><a href="#为什么MySQL采用B-树来作为索引结构？" class="headerlink" title="为什么MySQL采用B+树来作为索引结构？"></a>为什么MySQL采用B+树来作为索引结构？</h3><p>B+ 树相对于二叉树和红黑树来说，采用多分支，避免了树的阶层更长。</p>
<p>这里主要来和B树做一下比较。</p>
<p>首先，来了解一下 <strong>B+树的结构</strong></p>
<p><img src="https://pic1.imgdb.cn/item/6776ad76d0e0a243d4ede61f.png"></p>
<p><strong>1. 数据行都存储在叶子结点</strong></p>
<ul>
<li>相比于B树，b+树的数据行都存储在叶子结点，非叶子结点只存储主键值，来引导查询过程。</li>
<li>减少了非叶子节点的空间占用。</li>
</ul>
<p><strong>2. 叶子结点采用双向链表链接</strong></p>
<ul>
<li>叶子结点采用双向链表链接，若使用范围查找的话，效率更高（采用遍历链表的形式）</li>
<li>而b树则需要遍历B树，效率较低</li>
</ul>
<p><strong>3. 树的高度更小</strong></p>
<ul>
<li>B+树的非叶子结点存储的是主键值，所占页资源更少，可以存储更多的页，使得每页有更多的子结点。</li>
<li>而B树则非叶子结点也存储数据行，占用更多的存储空间，造成子结点相对B+树更少。</li>
</ul>
<p><strong>4. 查找操作的效率更高</strong>：</p>
<ul>
<li>B+树的查找操作通常仅限于叶子节点，而B树在查找时可能需要在内部节点和叶子节点之间反复跳转。</li>
<li>由于叶子节点之间有链表连接，B+树在范围查询时特别高效。</li>
</ul>
<h3 id="MySQL索引的最左前缀匹配原则是什么？"><a href="#MySQL索引的最左前缀匹配原则是什么？" class="headerlink" title="MySQL索引的最左前缀匹配原则是什么？"></a>MySQL索引的最左前缀匹配原则是什么？</h3><p>首先来了解一下应用背景</p>
<p>在InnoDB存储引擎中，采用B+树的结构来存储数据，B+树是顺序存储的，通常根据索引来排序。</p>
<p>若要使用联合索引的话<code>（a, b, c)</code>， 则会按照<code>(a,b,c)</code> 的形式来进行排序。</p>
<p>查询时也是一句顺序，来进行从左到右的查找。</p>
<p>最左前缀匹配原则是 MySQL 在使用索引时遵循的一种规则，尤其在涉及组合索引时。</p>
<p>mysql在查询时，会<strong>从最左边的索引列开始匹配，直到遇到第一个无法继续匹配的列为止</strong>。这意味着，若通过联合索引查询数据时，查询条件必须遵循 “最左前缀” 的要求，<strong>必须从组合索引最左边的字段开始匹配，逐步向右，不能跳过任何列。</strong></p>
<p>联合索引<code>(first_name,last_name,age)</code></p>
<p>类型：</p>
<ol>
<li><p>完全匹配最左前缀：当你查询条件完全包含最左边的字段，MySQL可以使用这个索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> first_name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配多个最左前缀： 有多个字段符合最左前缀</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> first_name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span> <span class="keyword">AND</span> last_name <span class="operator">=</span> <span class="string">&#x27;Doe&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>部分前缀匹配： 如果查询条件值匹配索引的前几个字段一部分</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> first_name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line"># 注意：这里实现最左前缀的之后first_name,关于age的条件需要回表搜索。</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>关于范围查询，若使用 &gt; 或 &lt; ,这样的形式，则会将遇到的第一个进行范围查询，而之后则不会。因为之后的数据经过范围查询后是无序的。</li>
<li>若遇到等值的形式， &gt;&#x3D;, &lt;&#x3D;, BETWEEN, like 则不会停止。</li>
</ul>
<h3 id="MySQL三层B-树能存储多大的数据？"><a href="#MySQL三层B-树能存储多大的数据？" class="headerlink" title="MySQL三层B+树能存储多大的数据？"></a>MySQL三层B+树能存储多大的数据？</h3><p>通常情况下面试官并不是问的具体的数据，而是计算过程和对B+树的结构了解，以及数据存储的上限。</p>
<p>在mysql的InnDB存储引擎下，默认的页大小为<strong>16KB。</strong></p>
<p>数据和主键大小取整的话大概<strong>1kb。</strong></p>
<p>主键和指针， <strong>8字节 和 6字节</strong></p>
<p>好的，有了基础数据参数后就可以开始计算了。</p>
<ul>
<li>主节点有一页，里面存储的子页面个数， 16  * 1080 &#x2F; (6+8) &#x3D; 1170 中间结点</li>
<li>中间结点计算同主节点，1170 * 1170</li>
<li>叶子结点，每页存储的数据 （16 &#x2F; 1) *1170 * 1170 &#x3D; 21902400</li>
</ul>
<p>所以， 三层B+树存储的数据大约时 2000万条。</p>
<h2 id="day03"><a href="#day03" class="headerlink" title="day03"></a>day03</h2><h3 id="MySQL中的回表是什么？"><a href="#MySQL中的回表是什么？" class="headerlink" title="MySQL中的回表是什么？"></a>MySQL中的回表是什么？</h3><p><strong>回表</strong>通常出现在二级索引中，二级索引的叶子结点存储的是索引和主键值，通过索引查询到主键id后，由于主键索引的叶子结点保存数据行，需要在回到主键中进行查找，这个过程被称为<strong>回表</strong>。</p>
<p>注意：回表会带来随机io，会影响查询效率。</p>
<p><strong>索引覆盖：</strong> 同样出现在二级索引中，当查询的值在索引中保存时，就不需要进行回表操作，减少了I&#x2F;O操作，提升了效率。</p>
<p><strong>索引下推：</strong> MySQL 5.6之后引入的一种优化技术，默认开启，可以在有like的条件下，减少回表的次数。用索引查询数据时，将部分查询条件下推到存储引擎中层来过滤减少要读取的数据。</p>
<h3 id="MySQL中建立索引的注意事项"><a href="#MySQL中建立索引的注意事项" class="headerlink" title="MySQL中建立索引的注意事项"></a>MySQL中建立索引的注意事项</h3><p>这里说一下自己总结的注意事项</p>
<ol>
<li><strong>索引并不是越多越好</strong>，索引的建立需要空间的占用，索引要平衡好查询效率和空间的占用</li>
<li><strong>不要建立大量重复的值的索引</strong>， 建立索引后，B+树通过索引的值进行排序，提高查询效率，若值大量的重复，则不会提升查询效率，还会造成空间的浪费。</li>
<li><strong>不要对频繁修改的表建立索引</strong>， 前面说了，建立索引后需要占用空间和维护，每次主键索引修改数据后，索引也需要进行相应的修改，会导致修改效率降低。</li>
<li><strong>根据 where，order by， group by， distinct</strong>，根据这些关键字的条件建立索引。</li>
<li><strong>不要建立长字段索引</strong>，占用空间较大，影响整体性能。</li>
</ol>
<h3 id="MySQL中的索引一定有效吗？如何进行排查？"><a href="#MySQL中的索引一定有效吗？如何进行排查？" class="headerlink" title="MySQL中的索引一定有效吗？如何进行排查？"></a>MySQL中的索引一定有效吗？如何进行排查？</h3><p>索引的使用取决于：查询条件，数据分布，索引设计等多个因素</p>
<p><strong>1. 索引未必一定有效</strong></p>
<p><strong>（1）索引选择性差</strong></p>
<ul>
<li>如果索引列的数据选择性较低（例如某个值大部分相同），索引就可能不被使用。这时，mysql就会使用全表扫描， 选择成本更低的选项。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE gender = &#x27;Male&#x27;;</span><br><span class="line"># 这里gender索引值只有Male和Female两个值</span><br><span class="line"># 索引选择性差</span><br></pre></td></tr></table></figure>



<p><strong>（2）范围查询</strong></p>
<ul>
<li>使用了范围查询（如 <code>BETWEEN</code>、<code>&gt;</code>、<code>&lt;</code>、<code>LIKE</code> 等）时，索引会被部分使用，通常只能利用范围查询前的字段索引。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">AND</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span>;</span><br><span class="line"># 这里索引只用到了age，之后回表查询，没有用到name。</span><br></pre></td></tr></table></figure>

<p><strong>（3）对索引使用了函数或表达式</strong></p>
<ul>
<li>在查询中对索引列使用了函数（如 <code>YEAR(date_column)</code>）或进行表达式计算时，索引可能会失效，因为计算后值与存储的索引值不匹配。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> <span class="keyword">YEAR</span>(order_date) <span class="operator">=</span> <span class="number">2023</span>;</span><br><span class="line"># <span class="keyword">YEAR</span>(order_date) 会导致索引失效，除非使用适当的索引，如索引覆盖完整的 order_date 列</span><br></pre></td></tr></table></figure>

<p><strong>（4） 隐式类型转换</strong></p>
<ul>
<li>在查询中，如果传入的查询条件数据类型与索引列的数据类型不同，MySQL 可能会进行隐式类型转换，导致索引失效。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="string">&#x27;25&#x27;</span>;</span><br><span class="line">#如果 age 列是 <span class="type">INT</span> 类型，而查询条件是字符串 <span class="string">&#x27;25&#x27;</span>，会导致类型不匹配，进而导致索引失效。</span><br></pre></td></tr></table></figure>

<p><strong>(5) 使用OR连接</strong></p>
<ul>
<li>在查询中使用 <code>OR</code> 时，如果 <code>OR</code> 连接的条件不能充分利用索引，MySQL 可能会选择全表扫描。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<p>如果 <code>name</code> 和 <code>age</code> 列分别有索引，MySQL 可能不能有效使用这两个索引，而是选择全表扫描。</p>
<h4 id="如何进行排查？"><a href="#如何进行排查？" class="headerlink" title="如何进行排查？"></a>如何进行排查？</h4><ol>
<li><strong>explan的使用</strong>： <code>EXPLAIN</code> 命令可以显示 MySQL 执行查询时选择的执行计划，帮助我们判断是否使用了索引。</li>
<li><strong>SHOW WARNINGS</strong>： 来排除索引失效的原因</li>
<li><strong>慢日志</strong>：查看慢日志，通过启用慢日志，可以查看哪些查询可能没有使用到索引而执行缓慢。</li>
</ol>
<h2 id="day04"><a href="#day04" class="headerlink" title="day04"></a>day04</h2><h3 id="MySQL-中的索引数量是否越多越好？为什么？"><a href="#MySQL-中的索引数量是否越多越好？为什么？" class="headerlink" title="MySQL 中的索引数量是否越多越好？为什么？"></a>MySQL 中的索引数量是否越多越好？为什么？</h3><p>答：并不是</p>
<ul>
<li><strong>增加存储开销</strong>：索引也是需要开销的，创建过多的索引会导致索引占用空间资源过多。</li>
<li><strong>降低写效率</strong>：每次添加修改删除数据都要同步修改索引的b+树，若索引过多，会导致修改数据的效率降低。</li>
<li><strong>维护效率增加：</strong> 索引的维护需要CPU和内存资源，尤其是当表发生大量更新时，索引维护的成本也会随之增加。频繁更新字段上的索引可能导致额外的计算开销。</li>
<li><strong>影响查询优化器的选择：</strong> 虽然索引的目的是加速查询，但过多的索引可能会导致 MySQL 在查询优化时难以做出最佳决策。数据库查询优化器可能会选择错误的索引，从而导致查询效率不如预期。</li>
</ul>
<h3 id="如何使用MySQL中的explain语句进行查询分析？"><a href="#如何使用MySQL中的explain语句进行查询分析？" class="headerlink" title="如何使用MySQL中的explain语句进行查询分析？"></a>如何使用MySQL中的explain语句进行查询分析？</h3><p><code>explain</code> MySQL中的关键字，放在查询语句之前可以对这个查询语句进行分析。</p>
<p>以下是实践操作：</p>
<p><img src="https://pic1.imgdb.cn/item/67b96db5d0e0a243d401d203.png"></p>
<p>可以看到explain查询出的属性图表。</p>
<p><img src="https://pic1.imgdb.cn/item/67794cf9d0e0a243d4ef03ed.png"></p>
<p><strong>重点：</strong></p>
<ul>
<li><strong>select_type:</strong> 显示查询的类型，包含 SIMPLE（简单查询），PRIMARY（子查询或联合查询中执行的外层查询），SUBQUERY（独立的查询）</li>
<li><strong>type</strong>： 显示访问的类型，可以通过这个来就行优化。<ul>
<li>ALL： 全表扫描</li>
<li>index： 全索引扫描</li>
<li>range： 索引范围扫描</li>
<li>ref： 索引等值匹配</li>
<li>eq_ref: 唯一索引等值匹配（链表查询的等值匹配）</li>
<li>const： 主键或唯一索引匹配</li>
<li>system： 表中只有一行数据。</li>
</ul>
</li>
<li>rows： 估计要扫描的行数</li>
<li>Extra：额外做了哪些操作</li>
</ul>
<h3 id="MySQL如何进行调优？"><a href="#MySQL如何进行调优？" class="headerlink" title="MySQL如何进行调优？"></a>MySQL如何进行调优？</h3><p>操作方面：查看慢日志，通过explain对查询语句进行。</p>
<p><strong>1. 索引优化</strong></p>
<ul>
<li>选择合适的索引</li>
<li>删除冗余的索引</li>
<li>增加索引覆盖的实现</li>
<li>联合索引遵循最左匹配原则</li>
</ul>
<p><strong>2. 查询语句优化</strong></p>
<ul>
<li>避免使用* ， 只查询需要的字段</li>
<li>使用JOIN代替子查询</li>
<li>使用EXISTS 或 in 代替 NOT EXISTS 或NOTIN</li>
</ul>
<h2 id="day05"><a href="#day05" class="headerlink" title="day05"></a>day05</h2><h3 id="MySQL中的varchar和char有什么区别？"><a href="#MySQL中的varchar和char有什么区别？" class="headerlink" title="MySQL中的varchar和char有什么区别？"></a>MySQL中的varchar和char有什么区别？</h3><h4 id="1-存储方式"><a href="#1-存储方式" class="headerlink" title="1. 存储方式"></a>1. 存储方式</h4><p><strong>varchar（可变字符）</strong></p>
<ul>
<li>VARCHAR 是<em>可变长度</em>的字符串类型，它只存储实际的字符长度*，并且在<strong>数据后面不补足空格</strong>。在 VARCHAR 字段中，<strong>MySQL会额外使用 1 个或 2 个字节来存储该字符串的长度信息</strong>（长度小于 255 字符使用 1 个字节，大于等于 255 字符使用 2 个字节）。这些额外的字节用于记录字符串的实际长度。</li>
<li>场景：适用于长度变化较大的字符串，例如用户名或电子邮件地址等</li>
</ul>
<p><strong>char（固定长度字符）</strong></p>
<ul>
<li>CHAR 是固定长度的字符串类型，不论存储的字符串有多长，MySQL 总是<strong>使用固定的长度分配存储空间。</strong><br>如果存储的字符串长度小于定义的长度，MySQL 会在字符串的<strong>末尾补足空格</strong>，以使其达到定义的长度。</li>
<li>适用于那些长度相对固定、变化不大的字符串字段，例如国家代码、邮政编码等。</li>
</ul>
<h4 id="2-性能差异"><a href="#2-性能差异" class="headerlink" title="2. 性能差异"></a>2. 性能差异</h4><p><strong>varchar</strong></p>
<ul>
<li>MySQL需要消耗一定的资源对varchar的长度进行计算，影响查询和修改效率。</li>
</ul>
<p><strong>char</strong></p>
<ul>
<li>长度固定，不需要计算长度，可以快速定位，存储和读取速度较快。</li>
</ul>
<h4 id="3-长度限制"><a href="#3-长度限制" class="headerlink" title="3. 长度限制"></a>3. 长度限制</h4><p><strong>VACHAR</strong></p>
<ul>
<li>可以存储可变长度的字符，最大储存长度为<strong>65535 字节</strong>（包括存储字符串长度的 1-2 字节）。（在MySQL中的）</li>
</ul>
<p><strong>CHAR</strong></p>
<ul>
<li>CHAR存储的是固定长度的字符串，最长可定义255个字符。</li>
</ul>
<h4 id="4-存储空间的占用"><a href="#4-存储空间的占用" class="headerlink" title="4. 存储空间的占用"></a>4. 存储空间的占用</h4><p><strong>varchar</strong></p>
<ul>
<li>根据实际大小进行改变，对于较长的字符，可以节省存储开销。</li>
<li>但是，对于较短的字符，会记录字符的长度，占用空间。（适合较长的字符）</li>
</ul>
<p><strong>char</strong></p>
<ul>
<li>字符大小固定，未使用的会用空格填充，对于未使用的部分会造成存储空间的浪费。</li>
<li>不需要记录数组长度，对于较短的字符，占用空间更小。（适合较短的字符）</li>
</ul>
<h4 id="5-空格处理的方式不同"><a href="#5-空格处理的方式不同" class="headerlink" title="5. 空格处理的方式不同"></a>5. 空格处理的方式不同</h4><p><strong>VACHAR</strong></p>
<ul>
<li>在 <code>VARCHAR</code> 中，存储的字符串后面的<strong>空格不会被自动去掉</strong>。例如，插入 <code>VARCHAR(5)</code> 列的值 <code>&#39;abc &#39;</code>，查询时仍会显示 <code>&#39;abc &#39;</code>（带空格）。</li>
</ul>
<p><strong>CAHR</strong></p>
<ul>
<li><code>CHAR</code> 会在存储时自动将字符串末尾的<strong>空格去除</strong>。例如，插入 <code>CHAR(5)</code> 列的值 <code>&#39;abc &#39;</code>，查询时只会得到 <code>&#39;abc&#39;</code>，末尾的空格会被忽略。</li>
</ul>
<p><strong>总结</strong></p>
<p><img src="https://pic1.imgdb.cn/item/677a9d6dd0e0a243d4ef34e8.png"></p>
<h3 id="MySQL中count（-、count（1）、count（字段名）有什么区别？"><a href="#MySQL中count（-、count（1）、count（字段名）有什么区别？" class="headerlink" title="MySQL中count（*)、count（1）、count（字段名）有什么区别？"></a>MySQL中count（*)、count（1）、count（字段名）有什么区别？</h3><p><strong>count（*)</strong></p>
<ul>
<li>会对所行的数据进行个数统计，效率较高（不需要查看具体的数据）</li>
</ul>
<p><strong>count（字段名）</strong></p>
<ul>
<li>会对这个字段进行个数统计，会忽略null。（会查看这个字段的数据）</li>
</ul>
<p><strong>count（1）</strong></p>
<ul>
<li>效果同**count（*)<strong>，MySQL底层会优化成</strong>count（*)**（实际效率没有差异）</li>
</ul>
<h3 id="请详细描述MySQL的B-树查询的全过程？"><a href="#请详细描述MySQL的B-树查询的全过程？" class="headerlink" title="请详细描述MySQL的B+树查询的全过程？"></a>请详细描述MySQL的B+树查询的全过程？</h3><p>在 MySQL 中，B+ 树被广泛用于实现索引，特别是 InnoDB 存储引擎中的聚簇索引。B+ 树是一种平衡树，具有良好的查询性能。</p>
<p><strong>1. B+树的基本结构</strong></p>
<ul>
<li><strong>根节点</strong>：B+ 树的顶部节点，包含指向子节点的指针。</li>
<li><strong>内部节点</strong>：包含索引键（key），指向子节点的指针，形成索引的层次结构。</li>
<li><strong>叶子节点</strong>：包含实际的数据或者数据的指针，叶子节点通过链表连接形成一个有序链表。</li>
<li><strong>指针</strong>：用于连接节点的指针。内部节点指向其他节点（包括叶子节点），而叶子节点指向实际数据或下一叶子节点。</li>
<li>注意：在 MySQL 的 <strong>B+树索引结构</strong>中，<strong>非叶子节点</strong>存储的是<strong>子节点页的最小值</strong>（或称为“下限值”），而不是最大值。</li>
</ul>
<p>结构图：</p>
<p><img src="https://i-blog.csdnimg.cn/direct/6e80a433101c4f869bf15d3e0b688a05.jpeg#pic_center"></p>
<p><strong>2. 查询数据流程</strong></p>
<p><strong>（1）从根节点开始查询</strong></p>
<ul>
<li>查询开始时，MySQL 从 B+ 树的根节点开始。根节点通常包含指向子节点的指针以及一些键（key）。</li>
<li>通过比较查询条件与根节点中存储的键值，MySQL 可以确定应该向哪个子节点继续查询。</li>
</ul>
<p><strong>（2）遍历内部节点</strong></p>
<ul>
<li>通过根节点的指针，MySQL 会进入到下一级的内部节点。在每个内部节点中，键值用于决定向哪个子节点继续查询。</li>
<li>内部节点的每个键值都将查询条件与它进行比较，选择最匹配的子节点。如果查询条件大于某个键，则继续向指向该键右边的子节点查询；如果小于某个键，则查询左边的子节点。</li>
</ul>
<p><strong>（3）直达叶子结点</strong></p>
<ul>
<li>继续沿着内部节点的指针查询，直到到达 B+ 树的叶子节点。在叶子节点中，存储的是实际的数据或者指向数据的指针。</li>
<li>对于 <code>SELECT</code> 查询，叶子节点中存储的是具体的行数据；对于某些索引查询，叶子节点中可能只存储数据行的地址</li>
</ul>
<p><strong>（4）数据检索</strong></p>
<ul>
<li>一旦到达叶子节点，MySQL 会在叶子节点中进行数据检索。对于聚簇索引，数据会直接存储在叶子节点中，而对于非聚簇索引，叶子节点存储的是指向数据行的指针，MySQL 需要根据这些指针回表查询对应的数据。</li>
<li>如果是聚簇索引，查询的结果可能直接从叶子节点返回；如果是非聚簇索引，MySQL 会根据索引中存储的指针回到表中查找完整数据。</li>
</ul>
<p><strong>（5）返回结果</strong></p>
<ul>
<li>数据检索完成后，MySQL 将查询结果返回给用户。如果是聚簇索引，数据会直接返回；如果是非聚簇索引，则需要回表获取完整数据。</li>
</ul>
<p><strong>5.总结</strong></p>
<p>B+ 树在 MySQL 中用于实现高效的索引查询。查询过程从根节点开始，通过内部节点逐层查找，直到到达叶子节点并返回数据。聚簇索引与非聚簇索引在查询过程中有不同的表现，聚簇索引可以直接从叶子节点返回数据，而非聚簇索引需要回表查找。合理设计索引并优化查询条件，可以显著提升查询性能。</p>
<h2 id="day06"><a href="#day06" class="headerlink" title="day06"></a>day06</h2><h3 id="MySQL是如何实现事务的？"><a href="#MySQL是如何实现事务的？" class="headerlink" title="MySQL是如何实现事务的？"></a>MySQL是如何实现事务的？</h3><p>事务的实现，必须保证<strong>ACID</strong></p>
<p><strong>ACID</strong></p>
<ul>
<li>原子性（Atomicity）： 事务中的操作要么都完成，要么全部都不完成，不会结束再中间某个点。</li>
<li>一致性（Consistency）： 事务必须保证数据库从一个一致的状态转移到另一一致的状态。</li>
<li>隔离性（Isolation）： 并发执行的事务之间不会互相影响。</li>
<li>持久性（Durability）：一旦事务提交，它对数据的改变就是永久的，系统发生故障也不会丢失。</li>
</ul>
<p><strong>原子性：</strong></p>
<p>InnoDB中，通过undo log记录来记录事务开始之后的反向操作，若在事务过程中出现了错误，则通过undo log 来实现回滚事务。</p>
<p><strong>一致性：</strong></p>
<p>约束检查：</p>
<ul>
<li>InnoDB 在事务执行过程中会检查约束条件（如主键、唯一键、外键等）。</li>
<li>如果违反约束，事务会回滚</li>
</ul>
<p><strong>隔离性：</strong></p>
<p>隔离级别： RU，RC，RR（默认），Serializable</p>
<p>InnDB默认使用RR隔离级别</p>
<p>通过MVCC解决 脏读 和 不可重复读</p>
<p>通过行锁或表锁解决 幻读问题</p>
<p><strong>持久性：</strong></p>
<p>Buffer poll （内存缓存区）</p>
<p>Redo_log , 保证了数据的持久性。</p>
<h3 id="MySQL中的MVCC是什么？"><a href="#MySQL中的MVCC是什么？" class="headerlink" title="MySQL中的MVCC是什么？"></a>MySQL中的MVCC是什么？</h3><p>是多版本并发控制。</p>
<p>是事务隔离级别的<strong>无锁</strong>的实现方式。</p>
<p>用于提高事务的并发性能。</p>
<p>版本链</p>
<p>底层使用， undo log + ReadView</p>
<p>undo log： 实现版本链</p>
<p><img src="https://pic1.imgdb.cn/item/67bbe15dd0e0a243d40328b7.png"></p>
<p>ReadView： 定位数据,快照信息。</p>
<p><img src="https://pic1.imgdb.cn/item/67bbe039d0e0a243d4032831.png"></p>
<ol>
<li>如果当前数据版本 &#x3D; db_trx_id ，说明修改这条数据的事务是当前事务。可见。</li>
<li>如果当前数据版本 &lt; min_trx_id, 说明这条数据的事务在当前事务生成readView的时候已提交，可见。</li>
<li>如果当前数据版本 在min 和 max之间，说明这条数据在事务开启时未提交。不可见</li>
<li>如果当前数据版本大于max，说明这条数据在事务开启时，未开启。不可见。</li>
</ol>
<h3 id="MySQL中的日志类型有哪些？binlog，redolog和undo-log的作用和区别是什么？"><a href="#MySQL中的日志类型有哪些？binlog，redolog和undo-log的作用和区别是什么？" class="headerlink" title="MySQL中的日志类型有哪些？binlog，redolog和undo log的作用和区别是什么？"></a>MySQL中的日志类型有哪些？binlog，redolog和undo log的作用和区别是什么？</h3><p>MySQL中用于数据持久化和恢复的机制非常关键，常见的日志类型包括 <strong>Redo log、Undo log、 Binary log 和 error log</strong>等， 每种日志都都有特定的作用，确保数据库在不同情况下的可恢复性、事务的隔离性和一致性。</p>
<p>日志类型：</p>
<ol>
<li><strong>Redo log</strong>（重做日志）： 是InnoDB存储引擎生成的日志，用于崩溃后修复数据，保证了事务的持久性。（重要）</li>
<li><strong>Undo log</strong>（回滚日志）：是InnodDB存储引擎生成的日志。用于事务的回滚和MVCC，保证了事务的原子性。（重要）</li>
<li><strong>Binary Log</strong>（二进制日志）：记录对数据的变更操作，用于主从复制，增量备份和数据恢复。（重要）</li>
<li><strong>Error log</strong>（错误日志）： 帮助程序员调试和监控数据库错误。</li>
<li><strong>Slow Query Log</strong>（慢查询日志） 记录慢查询，用于性能调优。</li>
<li><strong>General Query Log</strong>（一般查询日志） 记录所有查询，用于调试和审计。</li>
<li><strong>Relay Log</strong> （转发日志）支持主从复制，确保数据同步。</li>
<li><strong>Transaction Log</strong> （事务日志）记录事务的整个过程，确保事务的原子性、一致性和持久性。</li>
</ol>
<p>区别：</p>
<p><strong>Undo Log</strong></p>
<p>回滚日志，通常用在 <strong>事务和MVCC</strong>， 用于在事务崩溃后的数据恢复（回滚操作）</p>
<p>注意Undo log 不能保证持久性</p>
<ul>
<li>undo log 本身不强制在事务提交时写入磁盘</li>
<li>如果系统崩溃可能导致undolog丢失</li>
<li>undolog记录的是旧数据，无法用于恢复已提交事务的新数据</li>
<li>提交事务后，undolog可能被清理。</li>
</ul>
<p>操作例子：</p>
<ul>
<li>假设有一个事务执行以下操作：<ol>
<li>开始事务。</li>
<li>更新一行数据，将 <code>name</code> 从 <code>Alice</code> 改为 <code>Bob</code>。</li>
<li>删除一行数据。</li>
<li>插入一行新数据。</li>
</ol>
</li>
<li><strong>undo log 记录的内容</strong>：<ul>
<li>更新操作：记录 <code>name</code> 的旧值 <code>Alice</code>。</li>
<li>删除操作：记录被删除行的完整内容。</li>
<li>插入操作：记录插入行的主键。</li>
</ul>
</li>
<li><strong>回滚时</strong>：<ul>
<li>根据 undo log 中的记录，InnoDB 会执行以下反向操作：<ol>
<li>将 <code>name</code> 恢复为 <code>Alice</code>（反向 <code>UPDATE</code>）。</li>
<li>重新插入被删除的行（反向 <code>DELETE</code>）。</li>
<li>删除新插入的行（反向 <code>INSERT</code>）。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>undo log 并不是同时记录两者，而是通过记录旧数据来实现反向操作</p>
<p><strong>Redo log</strong></p>
<p>重写日志，通常在提交事务之后</p>
<p>作用：</p>
<ol>
<li><p>性能优化：</p>
<ul>
<li>事务提交时，MySQL并不会立即将修改的数据页写入磁盘（数据写入磁盘的方式是随机写，效率低），redolog是顺序写，效率高。</li>
<li>随机写，分布位置不同，写效率低</li>
<li>顺序写， 追加到日志尾，顺序写的性能高于随机写。</li>
</ul>
</li>
<li><p>崩溃恢复：</p>
<ul>
<li><strong>数据页写入的延迟性</strong>：<ul>
<li>事务提交时，数据可能还在内存<strong>（Buffer Pool）</strong>中，并没有立即写入磁盘。</li>
<li>如果此时系统崩溃，内存中的数据会丢失，导致已提交的事务修改丢失。</li>
</ul>
</li>
<li><strong>redo log 的作用</strong>：<ul>
<li>redo log 记录了事务的所有修改操作，并且是 <strong>持久化到磁盘</strong> 的（顺序写，性能高）。</li>
<li>即使系统崩溃，MySQL 在重启时可以通过 redo log 重做（redo）已提交的事务，确保数据不会丢失。</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意： 事务提交之后并不会立即写入磁盘中，而是可能存在内存中，这时候数据崩溃，就会导致数据的丢失。</p>
</blockquote>
<p> <strong>Write-Ahead Logging (WAL)</strong></p>
<p>数据页在写入磁盘之前，必须先将其修改记录到redolog中。</p>
<p>保证数据页写入前的日志持久化，是数据库实现持久性和高性能的关键。</p>
<blockquote>
<p><strong>这里提一下</strong>： 无论是使不使用redo log，实际数据的写入都是随机的，但是redo log 的使用，可以将事务的提交信息顺序的记录到日志的尾部，之后数据页的写入可以延迟到后台进行，不影响执行的效率。 而不使用的话，则会在提交后，开始写入磁盘，影响执行效率。</p>
</blockquote>
<p>总结：</p>
<ul>
<li><strong>redo log 的核心作用</strong>：<ul>
<li>将事务提交时的随机写转化为顺序写，提高性能。</li>
<li>通过延迟数据页写入，减少随机写的频率。</li>
<li>保证数据的持久性，即使系统崩溃，数据也不会丢失。</li>
</ul>
</li>
</ul>
<p><strong>3. Binary Log</strong></p>
<p>二进制日志；</p>
<ul>
<li><strong>作用</strong>：Binary Log 主要用于记录数据库的所有更改操作（如插入、更新、删除），是 MySQL 用于复制（Replication）和数据恢复的重要日志。它并不记录事务的详细数据，而是记录对数据的修改操作。记录的是逻辑日志</li>
</ul>
<p>Buffer Poll 缓存区</p>
<h2 id="day07"><a href="#day07" class="headerlink" title="day07"></a>day07</h2><h3 id="MySQL中事务的隔离级别有哪些？"><a href="#MySQL中事务的隔离级别有哪些？" class="headerlink" title="MySQL中事务的隔离级别有哪些？"></a>MySQL中事务的隔离级别有哪些？</h3><p><strong>读未提交</strong></p>
<p>最低隔离级别，在事务中，可以读取未提交的数据，可能造成脏读，不可重复读，幻读</p>
<p><strong>读已提交</strong></p>
<p>在事务中，读取已经提交的数据，解决了脏读的问题，但是会出现不可重复读的问题。</p>
<p><strong>可重复读</strong></p>
<p>在这个级别下，确保在一个事务中的多个查询返回的结果是一致的，可以避免不可重复读问题，但是可能引发幻读。</p>
<p><strong>串行化</strong></p>
<p>在这个隔离级别下，保证了事务间的操作结果是一个单线程的操作，避免了所有并发问题，但是，会对性能造成很大的影响。</p>
<h3 id="MySQL-默认的事务隔离级别是什么？为什么选择这个隔离级别"><a href="#MySQL-默认的事务隔离级别是什么？为什么选择这个隔离级别" class="headerlink" title="MySQL 默认的事务隔离级别是什么？为什么选择这个隔离级别"></a>MySQL 默认的事务隔离级别是什么？为什么选择这个隔离级别</h3><p>答：默认的隔离级别是RR，就是可重复读。</p>
<p>原因是binlog的statement格式问题。</p>
<p>binlog记录了原先是SQL语句，当处在ru和rc两种隔离级别下，会出现执行顺序的问题，会导致，主从不一致。</p>
<h3 id="数据库的脏读，不可重复读，幻读分别是什么？"><a href="#数据库的脏读，不可重复读，幻读分别是什么？" class="headerlink" title="数据库的脏读，不可重复读，幻读分别是什么？"></a>数据库的脏读，不可重复读，幻读分别是什么？</h3><ul>
<li>脏读： 一个事务读取到了另一个事务未提交的数据。</li>
<li>不可重复读： 在同一事务中，读取同一数据的两次结果不一致（由于中间有其他事务的提交）。</li>
<li>幻读： 在同一事务中，执行相同的查询操作，返回的结果集由于其他事务的插入而发生变化。</li>
</ul>
<h2 id="day08"><a href="#day08" class="headerlink" title="day08"></a>day08</h2><h3 id="MySQL中有哪些锁？"><a href="#MySQL中有哪些锁？" class="headerlink" title="MySQL中有哪些锁？"></a>MySQL中有哪些锁？</h3><p>mysql中有很多不同的锁，这里进行一些分类：</p>
<p><strong>1. 粒度分类</strong></p>
<ul>
<li><strong>表级锁</strong>：开销较小，加锁快，避免死锁，并发度低，适合查询</li>
<li><strong>行级锁</strong>： 开销大，加锁慢，可能出现死锁，并发度高，适合并发写，事务控制。</li>
<li><strong>页面锁</strong>： 开销，加锁速度，并发度都介于表级锁与行级锁之间，可能出现死锁。</li>
</ul>
<p><strong>2. 按照加锁机制分类（逻辑上）</strong></p>
<ul>
<li>悲观锁： 认为并发及易发生，所以每次操作时无论读写都先对记录进行加锁，防止其他线程对数据进行修改</li>
<li>乐观锁： 认为多个线程操作不会发生冲突，线程过来先去修改，如果没修改过或修改成功，修改过则失败或重试。</li>
</ul>
<p><strong>3. 兼容性分类</strong></p>
<ul>
<li><strong>共享锁（S读锁，shared locks）：</strong> 允许当前线程对共享资源加共享锁，其他线程可以读取，可以继续追加锁，但不能修改，不能追加排他锁。</li>
<li><strong>排他锁（X写锁，exclusive locks）</strong>： 会锁住共享资源，其他线程不能读取也不能追加共享锁或排他锁。</li>
</ul>
<p><strong>4. 可见性分析</strong></p>
<ul>
<li>隐式锁： 数据库根据事务隔离级别和执行操作自动加的锁，不用用户去进行干预。</li>
<li>显示锁： 用户指定的锁，通过SQL语句来进行控制。</li>
</ul>
<p><strong>5. 按锁模式划分</strong></p>
<ul>
<li><p>记录锁（Record lock): 锁定单个数据行的锁类型，是最精细的锁，会锁定某一行数据，防止其他事务对其进行修改。（行级锁）</p>
</li>
<li><p><strong>间隙锁（Gap lock）</strong>： 不是锁住具体的数据行，而是行之间的间隙，防止其他事务在改间隙中插入。（行级锁）</p>
</li>
<li><p><strong>临键锁（next-key 锁）</strong>： 是记录锁与间隙锁的结合，锁定某一行及其与下一行之间的间隙，防止其他事务对当前记录和改记录的范围进行修改或插入。（行级锁）</p>
</li>
<li><p>意向锁（IntentionLock）： <strong>表级锁</strong>的一种特殊类型，为更细力度的锁提供一个表示，避免其他事务在相同力度上加锁，避免冲突。分为（共享意向锁【IS】和独占意向锁【IX】)</p>
<blockquote>
<p>意向锁时一种标识，它的作用就是在上表级锁的时候，可以快速判断是否可以上锁，而不需要建立表中的所有记录。</p>
</blockquote>
</li>
<li><p>插入意向锁（Insert Intention Lock）：一种特殊的意向锁，表示事务打算在某间隙插入一行数据。</p>
</li>
</ul>
<p>元数据锁（Metadata Lock，MDL）： 用于保护数据库对象的元数据，防止在进行DDL操作时其他事务对这些对象进行修改。(表级锁)</p>
<p>自增锁（Auto Increment Lock）： 在插入自增列时，加锁以保证自增值的唯一性，防止并发插入导致的冲突，通常在插入操作时被使用，以确保生成的自增id是唯一的。</p>
<h4 id="间隙锁和临键锁时如何解决幻读问题的？"><a href="#间隙锁和临键锁时如何解决幻读问题的？" class="headerlink" title="间隙锁和临键锁时如何解决幻读问题的？"></a>间隙锁和临键锁时如何解决幻读问题的？</h4><p>数据id： 1 2 3 4 8 </p>
<p>例如： select * from … where  id &gt;&#x3D; 4</p>
<ol>
<li>会在4位置加行级锁</li>
<li>在8的位置加临键锁（锁住8 和 4到 8 的间隙）</li>
<li>在8之后加临键锁</li>
</ol>
<p>目的： <strong>防止在该范围插入幻影数据</strong></p>
<h3 id="MySQL的二阶段事务提交是什么？"><a href="#MySQL的二阶段事务提交是什么？" class="headerlink" title="MySQL的二阶段事务提交是什么？"></a>MySQL的二阶段事务提交是什么？</h3><p>涉及日志： <strong>redo log(重做日志） 和 binlog（二进制日志）</strong></p>
<p>答：在事务提交时，MySQL会将事务分为二阶段提交</p>
<p><strong>准备阶段（Prepare Phase）</strong>： 在准备阶段，将事务的提交信息写入redolog中，并将其标记为准备阶段，表示事务已经准备完成。</p>
<p><strong>提交阶段（Commit Phase）</strong>： 在提交阶段， MySQL Server 会写入 binlog（记录用户的DML操作）。当完成binlog写入后，MySQL会通知InnoDB，将redo log状态改为commit，完成这个事务的提价。</p>
<p><strong>目的</strong>： 保证redo log 和 binlog 之间的一致性，确保在数据崩溃恢复阶段，不会出现 <strong>数据丢失</strong> 或 <strong>数据不一致问题</strong>。</p>
<h3 id="MySQL中如果发生死锁应该如何解决？"><a href="#MySQL中如果发生死锁应该如何解决？" class="headerlink" title="MySQL中如果发生死锁应该如何解决？"></a>MySQL中如果发生死锁应该如何解决？</h3><p><strong>1. 死锁自动检测机制</strong></p>
<ul>
<li>MySQL自带着死锁检测机制，当检测到死锁时，数据库会回滚其中一个事务。通常会回滚事务中持有最资源的那个。</li>
</ul>
<p><strong>2. 等待锁超时</strong></p>
<p>获取锁的等待时间操作了这个阈值（50s），就释放锁，对事务回滚，解除死锁。</p>
<p><strong>3. 通过kill来手动处理死锁</strong></p>
<p>通过死锁日志定位发生死锁的事务，手动KILL死锁事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS <span class="comment">-- 查看死锁日志</span></span><br><span class="line">kill 线程ID <span class="comment">-- 通过线程ID，手动KILL死锁事务</span></span><br></pre></td></tr></table></figure>

<p><strong>死锁的避免</strong></p>
<ul>
<li>避免大事务：大事务占据锁的时间长，可以尝试将大事务分解成小事务。降低死锁的概率。</li>
<li>合理建立索引，减少加锁的范围： 命中索引会对该行上行锁；没有命中索引则会对整张表上表所，表锁的冲突概率大。</li>
<li>更改数据库隔离级别：可重复度比读已提交多了间隙锁，临键锁，通过降低隔离级别，减少死锁概率</li>
<li>开启死锁检测</li>
</ul>
<h2 id="day09"><a href="#day09" class="headerlink" title="day09"></a>day09</h2><h3 id="MySQL如何解决深度分页问题？"><a href="#MySQL如何解决深度分页问题？" class="headerlink" title="MySQL如何解决深度分页问题？"></a>MySQL如何解决深度分页问题？</h3><h4 id="什么是深度分页？"><a href="#什么是深度分页？" class="headerlink" title="什么是深度分页？"></a>什么是深度分页？</h4><p>深度分页是指在数据库查询过程中，使用分页查询时，由于分页较多，导致查询到后面数据遇到到的问题。</p>
<p>具体情况：当查询的页数比较多时，分页行为会对前面的数据进行排序，走索引的话会造成多次回表操作，影响效率。</p>
<p>造成的影响：</p>
<ul>
<li><strong>响应时间增加：</strong>随着分页深度的增加，查询所需要的时间也会增加，导致用户体验下降。</li>
<li><strong>服务器资源消耗：</strong>深分页查询会消耗更多的CPU和内存资源，可能导致服务器性能瓶颈。</li>
<li><strong>锁竞争和数据不一致：</strong>在并发环境下，长时间的查询可能导致锁竞争和数据不一致问题。</li>
</ul>
<h4 id="分析一下性能下降的原因"><a href="#分析一下性能下降的原因" class="headerlink" title="分析一下性能下降的原因"></a>分析一下性能下降的原因</h4><p>注意：<code>limit</code>是在构建结果集后，对数据丢弃处理的，所以需要先构建结果集。（会扫描每条数据，判断是否丢弃）</p>
<p><strong>1. 索引扫描的局限性</strong></p>
<ul>
<li>全索引扫描：（查询结果集时）当<code>LIMIT</code>语句的<code>offset</code>值很大时，MySQL 可能需要执行全索引扫描来找到满足条件的记录。这意味着从索引的根节点开始，一直扫描到叶子节点，无论这些节点是否包含目标数据。</li>
<li>索引跳跃性：（使用limit时） 即使是索引扫描，MySQL 也无法直接跳转到特定的<code>offset</code>位置。它必须从索引的开始位置顺序扫描，直到达到所需的位置。这种顺序扫描的过程是耗时的。</li>
<li>回表开销：对于非聚簇索引，找到满足条件的索引记录后，MySQL 需要执行回表操作来获取完整的行数据。在深分页查询中，由于<code>offset</code>值大，这会导致大量的回表操作，从而增加 I&#x2F;O 开销。</li>
</ul>
<p><strong>2. 数据访问模式</strong></p>
<ul>
<li>随机IO</li>
<li>缓存效率低下：数据量过大，可能导致缓存淘汰过快。</li>
</ul>
<p><strong>3. 锁和事务</strong></p>
<p>在并发环境下，深度分页查询可能遇到的问题（由于执行时间过长造成的问题）</p>
<ul>
<li>长事务和锁竞争</li>
<li>死锁风险</li>
</ul>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p><strong>1. 使用子查询</strong></p>
<p>通过使用子查询，快速定位到id的起点位置，在通过回表来完成查询，<strong>减少了多次回表</strong>造成的随机IO。</p>
<p><strong>2. 通过Inner Join（延迟关联策略）</strong></p>
<p>先在二级索引中找到满足条件的id，在通过和表的内连接，找到对应的数据行。</p>
<p><strong>底层原理：</strong></p>
<ul>
<li>通过在二级索引上快速找到满足条件的ID集合。</li>
<li>使用INNER JOIN在主键索引上检索这些ID对应的数据，<strong>减少了回表次数</strong>。</li>
</ul>
<p><strong>3. 记录ID</strong></p>
<p>在每次返回时，记录当前数据的最大id，下次查询时，只需要插叙 大于这个最大id的数据就行。</p>
<p>注意： 此方法<strong>仅适用于连续查询</strong>，跳页无法生效。</p>
<p><strong>4. 使用between…and</strong></p>
<p><strong>策略描述：</strong> 使用<code>BETWEEN…AND…</code>来代替<code>LIMIT</code>，直接指定查询的范围。</p>
<p><strong>底层原理：</strong></p>
<ul>
<li><code>BETWEEN…AND…</code>允许 MySQL 直接定位到查询的起始和结束点。</li>
<li>减少了扫描的行数，提高了查询效率。</li>
</ul>
<h3 id="什么是MySQL的主从同步？如何实现？"><a href="#什么是MySQL的主从同步？如何实现？" class="headerlink" title="什么是MySQL的主从同步？如何实现？"></a>什么是MySQL的主从同步？如何实现？</h3><p><strong>用到的日志： binlog（二进制日志）， relay log（中继日志）</strong></p>
<h4 id="什么是主从复制？作用"><a href="#什么是主从复制？作用" class="headerlink" title="什么是主从复制？作用"></a>什么是主从复制？作用</h4><p>MySQL主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL默认采用 <strong>异步复制方式</strong>，这样从节点可以复制主数据库中所有数据库或特定数据库，或者特定表。</p>
<p>MySQL支持的主从复制类型：</p>
<ul>
<li><strong>异步复制：</strong> 主库不需要等待从库的响应（性能较高，数据一致性低）</li>
<li><strong>同步复制：</strong> 主库等待所有从库确认收到数据（性能差，数据一致性高）</li>
<li><strong>半同步复制：</strong>主库等待至少一个从库确认收到数据（折中，数据一致性高）</li>
</ul>
<p><strong>作用</strong></p>
<ul>
<li><strong>数据备份</strong>：确保数据安全，做数据的备份，slave作为后备数据库，主数据库服务器故障后，可以切换到从数据库继续工作，避免数据的丢失。</li>
<li><strong>性能提升：</strong> 提升IO性能，随着业务的增大，IO访问频率增大，但库无法满足性能效率，通过多库的存储，有效的增加了IO访问的频率，减轻了单机的压力。</li>
<li><strong>读写分离：</strong> 将写操作放到master数据库，读操作放到slave数据库，实现读写分离，减轻了数据库的访问压力。</li>
</ul>
<h4 id="主从同步的原理"><a href="#主从同步的原理" class="headerlink" title="主从同步的原理"></a>主从同步的原理</h4><p>原理图：</p>
<p><img src="https://pic1.imgdb.cn/item/67bfd0bad0e0a243d4067f84.png"></p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250227104140364.png" alt="image-20250227104140364"></p>
<ol>
<li>master 服务器将数据的改变写入 <code>binlog</code>日志中</li>
<li>salve 服务器会在一定时间间隔内对 master 二进制日志进行探测是否有变化，若发生改变， 会开启一个IO Thread 请求master 的binlog事件</li>
<li>主节点为每个IO线程启动一个dump线程，用于向其发送二进制事件，并保存在本地中继日志（relay log）中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地进行重放，使得其数据库和主节点保持一致，最后IO Thread和SQL Thread将进入睡眠，等待下一次唤醒。</li>
</ol>
<p><strong>涉及线程</strong></p>
<p>主库：<strong>Binlog_Dump Thread</strong> -&gt; 发送binlog给从库</p>
<p>从库： <strong>SLAVE_IO_THREAD</strong> -&gt; 请求主库的binlog，并将得到的<strong>binlog</strong>写入到本地的<strong>relay log</strong>中。（定期向主库发送请求，判断是否有binlog更新，轮询）</p>
<p><strong>SLAVE_SQL_THREAD</strong> -&gt; 读取 中继日志 ，解析成sql语句进行执行，更新到 slave 的数据中。</p>
<p><strong>注意点：</strong></p>
<ul>
<li>每个slave只有一个master</li>
<li>每个slave只能有一个唯一的服务器ID</li>
<li>每个master可以有多个slave</li>
<li>master一定开启binlog二进制日志功能；通常为了数据库安全考虑，slave也要开启binlog</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li>主库宕机后，可能导致数据丢失<ul>
<li>MySQL 默认异步复制，写入binlog并发送后，不需要等待响应，一旦主库宕机，可能导致主库宕机。</li>
<li>使用 半同步复制（等待至少一个从库）</li>
<li>缺点： 性能稍微降低，网络异常会卡主主库。</li>
</ul>
</li>
<li>从库的SQL线程是<strong>单线程</strong>，或从库有大量的查询时，主从复制可能导致延迟。（可以尝试使用并行复制）</li>
</ol>
<h3 id="如何处理MySQL中的主从同步延迟问题？"><a href="#如何处理MySQL中的主从同步延迟问题？" class="headerlink" title="如何处理MySQL中的主从同步延迟问题？"></a>如何处理MySQL中的主从同步延迟问题？</h3><blockquote>
<p>主从同步问题无法避免，但可以降低延迟时间</p>
</blockquote>
<ul>
<li>二次查询： 从库查询不到数据时，在去主库进行查询，防止主从同步的数据不一致问题</li>
<li>强制主库操作： 把写后立即读的操作固定走主库。</li>
<li>按业务分区： 关键业务都走主库，从库采用读写分离的方式。</li>
<li>使用缓存： 主库写入后同步到缓存，查询先查缓存以避开延迟问题，可能会出现缓存数据一致性问题。</li>
</ul>
<p>优化硬件：</p>
<ul>
<li>优化网络：确保主从节点稳定</li>
<li>提高从服务器性能：增加硬件的资源处理能力</li>
<li>并行复制：利用MySQL并行复制功能提升效率，减少延迟。</li>
</ul>
<h2 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h2><h3 id="Redis-中常见的数据类型包括哪些？"><a href="#Redis-中常见的数据类型包括哪些？" class="headerlink" title="Redis 中常见的数据类型包括哪些？"></a>Redis 中常见的数据类型包括哪些？</h3><p>Redis中常见的数据类型包括： String、list、hash、Set、ZSet（也叫sort set）</p>
<p><strong>String</strong></p>
<p>字符串，最基本的数据类型，一个key对应一个value，value不仅可以是字符串，还可以是数字（整数或浮点数）。字符串类型是二进制安全的，这意味着可以包含任何数据类型，比如图片、序列化后的对象，最大大小为512MB</p>
<p><strong>应用场景</strong></p>
<ul>
<li>缓存： 存储临时数据，比如用户对话，页面缓存。</li>
<li>计数器： 用于统计访问量，点赞数等信息，可以通过原子操作增加或减少。</li>
</ul>
<p><strong>Hash</strong></p>
<p>Redis 哈希是一个包含键值对的无序列表，哈希特别适合存储对象，每个哈希可以存储 2^32-1 个键值对。Redis内部使用Hash表实现。</p>
<p><strong>使用场景：</strong> 常用来存储对象，如商品的相关属性</p>
<p><strong>List</strong></p>
<p>Redis列表是简单的字符串列表，按照插入顺序排序，可以在列表的头部（左边）或尾部（右边）添加元素，支持两端的推入和弹出。</p>
<p><strong>使用场景：</strong> </p>
<ul>
<li>消息队列： 用于简单的任务调度，消息传递场景。</li>
<li>历史消息记录： 存储用户的历史操作记录，便于快速访问。</li>
</ul>
<p><strong>Set</strong></p>
<p>Redis 的集合是一个无序的字符串集合，集合中的每个元素都是唯一的。集合中的元素没有重复，并且不保证顺序，支持快速查找和去重。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>标签系统： 为用户添加兴趣标签，将这些标签存储在一个集合中，通过集合的操作可以方便地进行标签的添加、删除和查询。</li>
<li>唯一用户集合：访问过某个页面的唯一用户，方便进行分析</li>
</ul>
<p><strong>ZSet</strong></p>
<p>有序集合，类似于集合，但是每个集合都有一个分数，用于排序，底层使用跳表实现，支持快速排序。</p>
<p><strong>应用场景:</strong> </p>
<ul>
<li>排行榜：存储用户的分数，并且根据分数进行实时排行</li>
<li>任务调度：根据任务优先级进行排序。</li>
</ul>
<p>以下是不常用的数据类型。</p>
<p><strong>BitMap</strong></p>
<p>位图， 不是一种独立的数据结构，而是在字符串类型的基础上定义的按位操作，它通过一个二进制数组类表示数据，每个元素对应一个二级制位，适合用来保存布尔值，或表示某一个状态。</p>
<p>用户签到，统计活跃用户状态</p>
<p><strong>HypeLogLog</strong></p>
<p>是一种<strong>用于估算集合基数（集合中不重复元素的数量）的数据结构</strong>。它使用极小的内存空间来实现对海量数据的基数估算，具有很高的空间效率。处理大规模数据的去重和计数。</p>
<p> <strong>GEO</strong></p>
<p>是Redis提供的一种用于存储地理位置信息的数据结构，可以存储经纬度信息并支持空间查询</p>
<p><strong>Stream</strong></p>
<p>Stream是Redis提供的一种日志数据结构，适合于存储时间序列数据或消息流。支持高效的消息和消费模式，具有持久和序列化特性。</p>
<h3 id="Redis为什么那么快？"><a href="#Redis为什么那么快？" class="headerlink" title="Redis为什么那么快？"></a>Redis为什么那么快？</h3><p>主要在三个方面，存储形式、线程和IO、数据结构</p>
<ul>
<li>存储形式：Redis是内存存储的，比起其他数据库，内存存储的速度会更快。</li>
<li>线程和IO: Redis采用了单线程的读写操作，避免的上线文切换的开销，通过对客户端连接采用了多路IO复用，可以同时监听多个客户端，提升了效率。</li>
<li>数据类型： Redis采用了高效的数据类型，这些数据类型经过优化，能够快速完成各种操作。</li>
</ul>
<h3 id="Redis为什么设计单线程？6-0为何又引入了多线程？"><a href="#Redis为什么设计单线程？6-0为何又引入了多线程？" class="headerlink" title="Redis为什么设计单线程？6.0为何又引入了多线程？"></a>Redis为什么设计单线程？6.0为何又引入了多线程？</h3><h4 id="Redis的系统观"><a href="#Redis的系统观" class="headerlink" title="Redis的系统观"></a>Redis的系统观</h4><p>从应用维度： 缓存使用，集群运用，数据结构的巧妙运用</p>
<p>从系统维度：</p>
<ul>
<li>高性能： 线程模型，网络IO模型，数据结构，持久化机制；</li>
<li>高可用：主从复制，哨兵机制；</li>
<li>高拓展： Cluster 分片集群</li>
</ul>
<h4 id="Redis快的原因"><a href="#Redis快的原因" class="headerlink" title="Redis快的原因"></a>Redis快的原因</h4><ul>
<li>Redis是基于内存操作的，需要的时候需要我们手动持久化到内存中。</li>
<li>Redis高效数据结构，对数据的操作也比较简单</li>
<li>Redis是单线程模型，从而避开了多线程的上下文频繁切换操作和锁的使用。</li>
<li>使用到了多路IO复用，非阻塞IO。</li>
</ul>
<h4 id="关于多线程"><a href="#关于多线程" class="headerlink" title="关于多线程"></a>关于多线程</h4><p>注意：这里的多线程是指 <strong>针对网络请求过程使用多线程，其数据读写命令的处理依旧是使用单线程</strong></p>
<p>Redis使用了IO多路复用，非阻塞 IO，使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，Redis 采用自己实现的事件分离器，效率比较高。</p>
<h4 id="这里是一些概念："><a href="#这里是一些概念：" class="headerlink" title="这里是一些概念："></a>这里是一些概念：</h4><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a><strong>多路复用</strong></h5><p>多路复用是一种IO模型，允许一个线程同时监听多个文件描述符，在某个文件描述符就绪时进行处理</p>
<p><strong>核心思想</strong>：</p>
<ul>
<li>使用功能一个线程管理多个IO模型，避免为每个连接创建单独的线程。</li>
<li>通过事件驱动的方式，高效处理大量并发连接。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>资源占用少</strong>：只需要一个线程即可管理多个连接，减少了线程创建和上下文切换的开销。</li>
<li><strong>高并发</strong>：适合处理大量并发连接（如网络服务器）。</li>
<li><strong>简单性</strong>：避免了多线程的复杂性（如锁竞争、线程同步）。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>CPU 密集型任务不适用</strong>：多路复用适合 I&#x2F;O 密集型任务，但如果任务是 CPU 密集型的，单线程会成为性能瓶颈。</li>
<li><strong>编程复杂度较高</strong>：需要处理事件循环和回调逻辑。</li>
</ul>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>多线程是指在一个进程中创建多个线程，每个线程可以独立执行工作。线程之间共享进程的内存空间，但每个线程有自己的栈和寄存器。</p>
<p><strong>核心思想</strong>：</p>
<ul>
<li>通过并行执行多个线程来提高程序的并发性能。</li>
<li>每个线程可以处理一个独立的任务或连接。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>并行计算</strong>：适合 CPU 密集型任务，可以充分利用多核 CPU 的性能。</li>
<li><strong>直观性</strong>：每个线程独立处理一个任务，逻辑清晰。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>资源占用高</strong>：每个线程都需要占用内存和 CPU 资源，线程过多会导致资源耗尽。</li>
<li><strong>复杂性</strong>：需要处理线程同步、锁竞争、死锁等问题。</li>
<li><strong>上下文切换开销</strong>：线程切换会消耗 CPU 资源。</li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li><strong>多路复用</strong>：适合 I&#x2F;O 密集型任务，资源占用少，适合高并发场景。</li>
<li><strong>多线程</strong>：适合 CPU 密集型任务，可以充分利用多核 CPU 的性能。</li>
</ul>
<h2 id="day11"><a href="#day11" class="headerlink" title="day11"></a>day11</h2><h3 id="跳表的实现原理是什么？"><a href="#跳表的实现原理是什么？" class="headerlink" title="跳表的实现原理是什么？"></a>跳表的实现原理是什么？</h3><h4 id="什么是跳跃表？"><a href="#什么是跳跃表？" class="headerlink" title="什么是跳跃表？"></a>什么是跳跃表？</h4><p>对于一个单链表来讲，即便链表中的存储是有序的，如果需要查找某个元素的时候，也只能从头到尾遍历。这样查找效率就会很低，时间复杂度会很高，这个时候，可以尝试在链表上建立索引，每几个结点之间提取一个结点到上一级，作为索引。</p>
<p><img src="https://pic1.imgdb.cn/item/679c374ad0e0a243d4f8ba4e.png"></p>
<p>在次建立，</p>
<p><img src="https://pic1.imgdb.cn/item/679c3776d0e0a243d4f8ba50.png"></p>
<p>通过建立索引的方式，提高查找效率，是一种空间换取时间的方式。</p>
<p><strong>像这种链表施加多级索引的方式，提高查询效率，这是一种通过空间换取时间的方式。</strong></p>
<blockquote>
<p>跳跃表主要是通过 <strong>多层链表实现</strong>， 底层链表	保存所有元素，而每一层链表都是下一层的子集</p>
</blockquote>
<p><strong>关于插入</strong></p>
<p>在插入时， 首先从最高层开始查找插入位置，然后随机决定新节点的层数，最后在相应的层中插入节点并更新指针。</p>
<p>例： 在三级索引插入数据时，会在第一二层里面插入相同的数据，从上往下。（最多的层数在Redis5.0中是64，在Redis7.0中是32）</p>
<p><strong>关于删除</strong></p>
<p>删除时，同样从最高层查找要删除的节点，并在各层中更新指针，以保证跳表的结构。</p>
<p><strong>关于查找</strong></p>
<p>查找时，从最高层开始，逐层向下，直到找到目标元素或确定元素不存在。查找效率高，时间复杂度为O（logn）</p>
<h4 id="为什么Redis跳表实现了多个回退指针？"><a href="#为什么Redis跳表实现了多个回退指针？" class="headerlink" title="为什么Redis跳表实现了多个回退指针？"></a>为什么Redis跳表实现了多个回退指针？</h4><p>回退指针主要是 <strong>为了提高跳表的操作效率和灵活性</strong></p>
<p>结构：</p>
<p>注意：只有最底层是双向链表，其他层都是单向链表。</p>
<p><strong>最底层：</strong></p>
<ul>
<li>这一层包含了所有节点，是一个完整的有序链表</li>
<li>每个节点有一个 <strong>回退指针</strong>，因此这一层是一个双向链表</li>
</ul>
<p><strong>其它层：</strong></p>
<ul>
<li>每一层都是一个单向链表，节点通过 <strong>前进指针</strong>指向下一个节点</li>
<li>高层链表是底层的快速通道，分配层级时，越高的层级概率越低</li>
<li>高层链表没有回退指针</li>
</ul>
<p>实现原因：</p>
<p><strong>设计目的</strong>：</p>
<ul>
<li>跳表的主要目标是实现高效的查找、插入和删除操作，而这些操作主要依赖于<strong>高层的前进指针</strong>来实现快速跳跃。</li>
<li>最底层的双向链表主要用于支持<strong>范围查询</strong>或<strong>从后向前遍历</strong>，但这些操作的使用频率较低，因此不需要在高层实现双向链表。</li>
</ul>
<p><strong>空间效率</strong>：</p>
<ul>
<li>如果每一层都实现双向链表，会增加额外的指针（回退指针），导致空间复杂度更高。</li>
<li>跳表的设计在空间和时间效率之间做了权衡，只有最底层实现双向链表，既满足了功能需求，又减少了空间开销。</li>
</ul>
<p><strong>功能需求</strong>：</p>
<ul>
<li>高层链表的主要作用是加速查找，单向链表已经足够。</li>
<li>最底层的双向链表主要用于支持一些特殊操作（如逆序遍历），而这些操作通常只需要在最底层完成。</li>
</ul>
<p><strong>结构代码</strong></p>
<p>c语言：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    robj *obj;                      <span class="comment">// 节点存储的对象</span></span><br><span class="line">    <span class="type">double</span> score;                   <span class="comment">// 节点的分数（用于排序）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 回退指针（仅在最底层使用）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 前进指针（每一层都有）</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;            <span class="comment">// 跨度（用于计算排名）</span></span><br><span class="line">    &#125; level[];                       <span class="comment">// 柔性数组，表示节点的层</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul>
<li><strong>最底层（第 0 层）是双向链表</strong>，支持双向遍历。</li>
<li><strong>高层（第 1 层及以上）是单向链表</strong>，仅支持单向遍历。</li>
<li>这种设计既满足了跳表的功能需求，又保证了空间效率。跳表的每一层并不是独立的双向链表，而是一个多层链表的组合结构。</li>
</ul>
<h3 id="Redis中的Hash"><a href="#Redis中的Hash" class="headerlink" title="Redis中的Hash"></a>Redis中的Hash</h3><p>Redis的hash是一种键值对集合，可以将多个字段和值存储在一个键中，便于管理一些关联数据。通常用来存储对象的键值对。</p>
<p><strong>数据结构</strong></p>
<p>Hash类型的底层数据结构7.0版本之前是由紧凑列表和哈希表组成，在此之前都是压缩列表和哈希表实现：</p>
<ul>
<li>哈希类型元素个数  小于  hash-max-ziplish-entiries（512）</li>
<li>哈希的key值大小（总大小） 小于 64</li>
</ul>
<p>以上条件成立的时候，Redis使用压缩列表或紧凑列表作为底层数据结构。</p>
<p>如果不满足其一，则使用哈希表</p>
<p><strong>注意：当列表转化成为hashtable时，便会一直使用hashtable，不会在退化。</strong></p>
<p><strong>关于紧凑列表（listpack） 和 压缩列表（ziplist）</strong></p>
<p>他们的结构类似数组，是由多个连续的内存块组成的。（通过偏移量计算来遍历数据）</p>
<p><strong>压缩列表</strong></p>
<p>压缩列表式Redis早起引入的一种紧凑型数据结构，用于存储小型列表，哈希表或有序集合。它的特点是将多个元素连续存储在一块连续的内存中，以减少内存碎片和提高内存利用率。</p>
<p><strong>紧凑列表</strong></p>
<p>紧凑列表是Redis 7.0引入的一种新的紧凑型数据结构，用于替代压缩列表。它的设计目标是解决压缩列表的一些缺陷，同时保持高效的内存利用率。</p>
<p><strong>区别</strong></p>
<img src="https://pic1.imgdb.cn/item/67c278b9d0e0a243d4087fbb.png" alt="image.png">

<p><strong>渐进式rehash</strong></p>
<blockquote>
<p>就是一点点地扩容，而不是直接一次性完成扩容。</p>
</blockquote>
<p>hashtable的结构中保存着两张表，一张是用来存储hashtable数据的表，另一张则是一张空表。</p>
<p>当触发扩容时</p>
<ol>
<li><p>首先为表2分配空间，新表的大小是第一大于等于原表的二次方幂。设置字典的标识，rehash的索引值从-1变成0</p>
</li>
<li><p>数据开始实现转移。每次对hahs记性增删改查是，都会将当前rehashidx的数据在哈希表1迁移到2上，然后rehashidx+1， 所以迁移的过程是分多次，渐进式完成的。</p>
<p>注意：插入数据会直接插入到2表中。</p>
</li>
<li><p>随着操作不断执行，最终哈希表1的数据都会别迁移到哈希表2中，这个时候，进行指针互换。并将表2设置成空表，渐进式rehash的过程就完成了。</p>
</li>
</ol>
<h3 id="ZSet的实现原理"><a href="#ZSet的实现原理" class="headerlink" title="ZSet的实现原理"></a>ZSet的实现原理</h3><p>有序集合，由 <code>跳表</code> 和 <code>哈希表</code> 组成。</p>
<blockquote>
<p>注意： Zset元素数量较少时，Redis会使用压缩列表来节省空间。</p>
</blockquote>
<ul>
<li>跳表： 用于存储数据的排序和快速查找</li>
<li>哈希表： 用于存储成员和其分数的映射，提供快速查找。</li>
</ul>
<p>编码选择：</p>
<p><img src="https://pic1.imgdb.cn/item/679c3c62d0e0a243d4f8bab8.png"></p>
<h4 id="明明跳表中已经存储了member和score了，为什么还需要hashtable？"><a href="#明明跳表中已经存储了member和score了，为什么还需要hashtable？" class="headerlink" title="明明跳表中已经存储了member和score了，为什么还需要hashtable？"></a>明明跳表中已经存储了member和score了，为什么还需要hashtable？</h4><p> <strong>哈希表的结构</strong>：</p>
<ul>
<li>哈希表的键（key）是元素的值（<code>member</code>）。</li>
<li>哈希表的值（value）是元素的分值（<code>score</code>）</li>
</ul>
<p>作用： </p>
<ol>
<li><ul>
<li><strong>优化查找性能</strong>：<ul>
<li>哈希表的 O(1) 查找性能比跳表的 O(n) 查找性能更好。</li>
<li>在实际应用中，<code>ZSCORE</code> 操作（查找某个 <code>member</code> 的 <code>score</code>）是非常常见的，哈希表可以显著提升这种操作的性能。</li>
</ul>
</li>
<li><strong>避免重复设计</strong>：<ul>
<li>哈希表的主要作用是快速查找 <code>score</code>。</li>
</ul>
</li>
<li><strong>空间换时间</strong>：<ul>
<li>哈希表虽然会占用额外的内存空间，但它带来的性能提升是非常值得的。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p> <strong>跳表的结构</strong>：</p>
<ul>
<li>元素的值（<code>member</code>）。</li>
<li>元素的分值（<code>score</code>）。</li>
<li>多层指针，用于快速跳跃。</li>
</ul>
<p>作用：</p>
<p>维护了元素的有序性，支持范围查找和排名操作。</p>
<h4 id="总结；"><a href="#总结；" class="headerlink" title="总结；"></a>总结；</h4><ul>
<li><strong>跳表</strong> 用于维护元素的有序性，支持范围查询和排名操作。</li>
<li><strong>哈希表</strong> 用于快速查找 <code>score</code>，时间复杂度为 O(1)。</li>
<li>虽然跳表中已经存储了 <code>member</code> 和 <code>score</code>，但哈希表的存在是为了优化查找性能，避免在跳表中进行低效的线性查找。</li>
<li>这种设计是典型的 <strong>空间换时间</strong> 策略，通过额外的内存开销换取更高的性能。</li>
</ul>
<h2 id="day12"><a href="#day12" class="headerlink" title="day12"></a>day12</h2><h3 id="Redis如何保证缓存和数据库的一致性"><a href="#Redis如何保证缓存和数据库的一致性" class="headerlink" title="Redis如何保证缓存和数据库的一致性"></a>Redis如何保证缓存和数据库的一致性</h3><h4 id="数据库的一致性"><a href="#数据库的一致性" class="headerlink" title="数据库的一致性"></a>数据库的一致性</h4><ul>
<li>缓存中有数据，必须和数据库中数据相同</li>
<li>缓存中没有数据，数据库中数据必须是最新的。</li>
</ul>
<p>不符合这两种情况的，就是缓存和数据库不一致。</p>
<p>当缓存的读写模式不一样时，缓存数据不一致发生的情况一样。</p>
<p><strong>1. redis作为读写缓存</strong></p>
<p>对于读写缓存来说，如果对数据库进行增删改查，就需要在缓存中进行，同时还需要根据需求采取写回策略，决定是否同步写回到数据库中。</p>
<ul>
<li>**同步只写策略： **写缓存时，同步写回数据库，保证缓存和数据库的一致性（写时必须保证缓存和数据库更新的原子性）（可以采取分布式锁，来保证并发状态下的不一致性问题）</li>
<li><strong>异步写回策略：</strong> 写缓存时不同步写回数据库，等到数据库从缓存中淘汰时，在写回数据库。（缺点：若缓存还未写回数据库，缓存就发生了故障，会导致数据库没有更新数据）</li>
</ul>
<p>总结: 想要保证缓存和数据库的一致性，就要使用同步直写策略，需要保证缓存和数据库同时更新（原子性），在实现业务时，通常使用事务的机制来保证。</p>
<p><strong>2. redis作为只读缓存</strong></p>
<p>只读缓存操作：</p>
<ul>
<li>如果需要添加数据，就会直接写入数据库</li>
<li>当数据修改时，需要把只读缓存中的数据标记为无效<ul>
<li>这样，在对数据进行增删改时，因为缓存中没有数据，就会发生缓存缺失</li>
<li>这时，就需要通过读取数据库来获取数据，并写入缓存。之后访问数据时，就可以直接从缓存中读取。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意： 在删除数据更新缓存时，也需要保证原子性。</p>
</blockquote>
<p>在更新数据库时，需要对缓存进行删除操作（只读缓存）</p>
<p>为保证缓存和数据库一致性</p>
<p><strong>重试机制：</strong>可以把要删除的缓存值或要更新的数据库值暂存到消息队列中。当应用没有能够成功的删除缓存或数据库时，可以从消息队列读取这些值，然后再次更新。成功，取出，失败，多次尝试，不然报错。</p>
<p><strong>两种数据不一致的情况</strong></p>
<p><strong>1. 先删除缓存，在更新数据库</strong></p>
<p>可能出现，在跟新数据库时，并发的其他线程读取数据库旧值，并将旧值重新写入缓存，导致缓存数据库不一致。</p>
<p>解决： 可以让线程1在完成数据库更新后sleep一段时间，然后再次删除redis中的缓存。</p>
<blockquote>
<p>休眠是保证线程2完成了对缓存的写入，然后线程1对缓存进行删除</p>
<p>因为这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，所以我们也把它叫做“<strong>延迟双删</strong>”。</p>
</blockquote>
<p><strong>2. 先更新数据库，在删除缓存</strong></p>
<p>在线程1更新数据库时，线程二读取到了缓存中的旧值。导致数据不一致。</p>
<p>不过缓存存在时间极短，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求请求到旧值。对于业务影响较小。基本可以忽略。</p>
<p>总结：</p>
<ul>
<li>对于读写缓存来说，如果我们采用同步写回策略，可以保证缓存和数据库的一致性。</li>
<li>对于只读缓存，有两种导致数据库不一致<ul>
<li>删除缓存和更新数据库失败导致的数据不一致，可以通过重试机制确保删除或更新操作成功。</li>
<li>同步更新，可以先更新数据库在删除缓存，（若先删除缓存在更新数据库，可以通过<strong>延迟双删</strong>的方式来保证）</li>
</ul>
</li>
</ul>
<h3 id="Redis中的缓存击穿、缓存雪崩和缓存穿透？"><a href="#Redis中的缓存击穿、缓存雪崩和缓存穿透？" class="headerlink" title="Redis中的缓存击穿、缓存雪崩和缓存穿透？"></a>Redis中的缓存击穿、缓存雪崩和缓存穿透？</h3><p>缓存击穿： 一个热点信息过期，导致大量请求请求数据库，导致数据库过载</p>
<ul>
<li>解决： 定期更新热点信息，把热点信息设置成永远存在。采用<strong>互斥锁</strong>，防止多个请求同时访问数据库，采用<strong>懒加载</strong><ul>
<li>懒加载： 通常指，在使用某个数据时，在加载到数据库中。</li>
<li>热点数据永不过期</li>
</ul>
</li>
</ul>
<p>缓存穿透： 访问一个缓存中不存在的数据，导致多次访问数据库</p>
<ul>
<li>解决： 对于多次访问不存在的信息时，可以缓存一个空值到redis中，防止访问数据库。或<strong>布隆过滤。</strong></li>
</ul>
<p>缓存雪崩：大量的缓存数据同时过期，导致多个请求同时访问数据库，导致数据库过载</p>
<ul>
<li>解决： 可以把缓存设置不同的过期时间（TTL)，防止同一时间多个数据更新。可以采用预加载策略，提前把可能过期的数据进行加载。</li>
<li>使用双缓存策略，将数据同时存储在两层缓存中，减少数据库直接请求。</li>
</ul>
<h3 id="Redis-String-类型的底层实现是什么？"><a href="#Redis-String-类型的底层实现是什么？" class="headerlink" title="Redis String 类型的底层实现是什么？"></a>Redis String 类型的底层实现是什么？</h3><p>String，是redis中的基本数据类型，可以存储任意类型的数据，比如文本，数字，图片或序列化的对象的等等。</p>
<p>注意： 一个String类型可以存储512MB的数据。</p>
<h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>底层实现是 <strong>SDS（simple dynamic string)</strong> ，翻译为<strong>简单动态字符</strong>。它是一个动态字符串结构，由<strong>长度，空闲空间和字节数组</strong>三部分组成。</p>
<p>SDS的三种编码类型：</p>
<ul>
<li>embstr： 占用64Bytes的空间，存储44Bytes</li>
<li>raw： 存储大于44Bytes的数据</li>
<li>int： 存储整数类型</li>
</ul>
<h2 id="day13"><a href="#day13" class="headerlink" title="day13"></a>day13</h2><h3 id="如何实现分布式锁？"><a href="#如何实现分布式锁？" class="headerlink" title="如何实现分布式锁？"></a>如何实现分布式锁？</h3><h4 id="为什么要使用分布式锁？"><a href="#为什么要使用分布式锁？" class="headerlink" title="为什么要使用分布式锁？"></a>为什么要使用分布式锁？</h4><p>在分布式系统中，多个服务实例可能会并发访问共享资源，导致资源竞争和数据一致性问题。例如，在秒杀场景下：</p>
<ul>
<li>如果多个用户同时请求库存仅为1的商品，未加锁会导致超卖。</li>
<li>分布式锁可以保证同一时刻只有一个线程或进程操作共享资源，从而避免并发问题。</li>
</ul>
<p>注意：分布式锁是分布式环境下的并发控制机制，确保某资源同一时刻仅能被一个资源使用。</p>
<h4 id="什么是分布式锁呢？"><a href="#什么是分布式锁呢？" class="headerlink" title="什么是分布式锁呢？"></a>什么是分布式锁呢？</h4><p><strong>两种方式：</strong></p>
<ul>
<li>单个Redis实例下：<code>SET NX PX + 重试 + Lua脚本</code></li>
<li>Redis集群模式下，采用Redlock</li>
</ul>
<p>这里着重讨论单个Redis实例下实现分布式锁</p>
<p>Redis实现分布式锁的核心是利用提供的原子操作命令，例如 set 和 nx（仅在键不存在时使用）和ex（是指键的过期时间），来实现加锁和解锁。</p>
<p>加锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 3000</span><br></pre></td></tr></table></figure>

<p>为保证解锁的操作删除的是指定加锁的客户端，需要判断加锁客户端并实现删锁。一般借助Lua脚本实现。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h5><ul>
<li><strong>互斥性</strong>： 通过 <code>SET NX</code> 保证同一时刻只能有一个客户端获取锁。</li>
<li><strong>避免死锁:</strong> 为锁设置过期时间（如 <code>px</code> 参数），防止客户端崩溃导致锁无法释放。</li>
<li><strong>防止误删</strong>: 通过唯一标识（UUID）确保只有持有锁的客户端才能释放锁。</li>
<li><strong>操作原子性</strong>: 加锁和解释删除操作必须是原子性，避免并发问题。解锁是可以使用Lua脚本保证原子性操作。</li>
</ul>
<h4 id="秒杀场景下实现分布式锁"><a href="#秒杀场景下实现分布式锁" class="headerlink" title="秒杀场景下实现分布式锁"></a>秒杀场景下实现分布式锁</h4><p><strong>数据库层面</strong></p>
<ol>
<li><p>数据库层面解决，查询商品库存的时候，加排他锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> stock <span class="keyword">FROM</span> goods <span class="keyword">WHERE</span> id <span class="operator">=</span> xxxx <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新数据库时，减去库存的时候，进行库存限制，防止超卖。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> goods <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> xxx <span class="keyword">AND</span> stock <span class="operator">&gt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>引入分布式锁</strong></p>
<ol>
<li>保证同一时间内仅有一个客户端获取到锁执行秒杀购买操作，但是由于分布式锁会导致串行化处理，没有办法同时处理同一个商品的大量下单请求。</li>
</ol>
<p><strong>利用Redis的INCR和DECR的原子性 + 异步队列</strong></p>
<ol>
<li>初始化时将商品的库存数量加载到Redis中</li>
<li>接收到秒杀请求时，Redis先预先减库存 DECR，如果预减库存不足时，直接返回秒杀失败。</li>
<li>将秒杀请求放到异步队列中，返回秒杀提示</li>
<li>服务端消费者消费队列中的秒杀信息，取出信息秒杀商品入库生成订单并扣除金额，若成功，响应客户端。</li>
<li>客户端进行轮询，一旦得到响应，则返回秒杀成功并且显示秒杀详细。</li>
</ol>
<h3 id="Redis的Red-Lock-是什么？-你了解吗？"><a href="#Redis的Red-Lock-是什么？-你了解吗？" class="headerlink" title="Redis的Red Lock 是什么？ 你了解吗？"></a>Redis的Red Lock 是什么？ 你了解吗？</h3><p><strong>Redis中的常用部署方式</strong></p>
<ul>
<li>单机模式</li>
<li>主从模式</li>
<li>哨兵模式</li>
<li>集群模式</li>
</ul>
<p>当我们使用redis时： 一般会采用主从集群+哨兵的模式部署，哨兵的作用就是监测redis的节点的运行状态，普通的主从模式当master崩溃时，需要手动切换让slave成为master，使用主从+哨兵结合的好处在于，当master异常宕机是，哨兵可以实现故障的自动切换，把slave切换成master，继续提升服务，以此保证可用性。</p>
<p>当master宕机时，若锁设置还未同步到slave上，可能导致锁丢失，无法保证进程的安全。</p>
<p><strong>解决</strong></p>
<p><strong>集群模式+Redlock实现高可靠的分布式锁</strong></p>
<p>为了避免redis实例故障导致的锁无法工作的问题，Redis的开发者 Antirez 提出来分布式锁算法 Redlock。</p>
<p>Redlock算法的基本思路，是<strong>让客户端与多个独立的Redis实例依次请求加锁，如果客户端能够和半数以上的实例成功的完成加锁操作，那么我们就认为，客户端成功的获取了分布式锁，否则加锁失败</strong>。</p>
<p>Redlock的实现需要在redis的集群模式下，无哨兵结点， </p>
<p>步骤</p>
<ol>
<li>客户端获取当前时间</li>
<li>给每个redis加锁，设置超时时间，过了直接跳过这个redis。</li>
<li>完成整个加锁后，客户端计算整个加锁时间。</li>
</ol>
<p><strong>满足加锁成功的两个条件</strong></p>
<ul>
<li>客户端超过半数加锁成功</li>
<li>客户端获取锁的总耗时，没有超过锁的过期时间。</li>
</ul>
<blockquote>
<p>目的： 只要存在的节点占大多数，那么整个系统就可以提供正常工作。</p>
</blockquote>
<p>满足以上两个条件之后</p>
<p><strong>重新计算这把锁的有效时间，计算的结果是锁的最初有效时间减去客户端为获取锁的总耗时。如果锁的有效时间已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成共享资源操作，锁就过期了的情况</strong>。</p>
<p>若为满足</p>
<p><strong>当然，如果客户端在和所有实例执行完加锁操作后，没能同时满足这两个条件，那么，客户端就要向所有Redis节点发起释放锁的操作。</strong></p>
<h3 id="Redis实现分布式锁时可能遇到的问题有哪些？"><a href="#Redis实现分布式锁时可能遇到的问题有哪些？" class="headerlink" title="Redis实现分布式锁时可能遇到的问题有哪些？"></a>Redis实现分布式锁时可能遇到的问题有哪些？</h3><p>问题</p>
<ul>
<li>redis宕机导致的死锁问题（保证加锁设设置过期时间的原子性）</li>
<li>未执行完操作锁过期（可以设置较长的过期时间，或设置守护进程，随时检测，快过期时增加过期时间，看门狗）</li>
<li>删除的不是自己的锁（在释放锁时，先检测是否是自己的锁在进行删除，检测和删除必须保证原子性Lua)</li>
<li>主从集群+哨兵模式下的锁失效（采用redlock解决，集群模式）</li>
</ul>
<h2 id="day14"><a href="#day14" class="headerlink" title="day14"></a>day14</h2><h3 id="Redis的持久化机制有哪些？"><a href="#Redis的持久化机制有哪些？" class="headerlink" title="Redis的持久化机制有哪些？"></a>Redis的持久化机制有哪些？</h3><h3 id="Redis的主从复制实现原理是什么？"><a href="#Redis的主从复制实现原理是什么？" class="headerlink" title="Redis的主从复制实现原理是什么？"></a>Redis的主从复制实现原理是什么？</h3><h3 id="Redis数据过期后的删除策略是什么？"><a href="#Redis数据过期后的删除策略是什么？" class="headerlink" title="Redis数据过期后的删除策略是什么？"></a>Redis数据过期后的删除策略是什么？</h3><h2 id="day15"><a href="#day15" class="headerlink" title="day15"></a>day15</h2><h3 id="如何解决Redis中的热点key问题？"><a href="#如何解决Redis中的热点key问题？" class="headerlink" title="如何解决Redis中的热点key问题？"></a>如何解决Redis中的热点key问题？</h3><h3 id="Redis集群的实现原理是什么？"><a href="#Redis集群的实现原理是什么？" class="headerlink" title="Redis集群的实现原理是什么？"></a>Redis集群的实现原理是什么？</h3><h3 id="Redis中的Big-Key问题是什么？如何解决？"><a href="#Redis中的Big-Key问题是什么？如何解决？" class="headerlink" title="Redis中的Big Key问题是什么？如何解决？"></a>Redis中的Big Key问题是什么？如何解决？</h3><h2 id="day16"><a href="#day16" class="headerlink" title="day16"></a>day16</h2><h3 id="单例模式有几种实现？如何保证线程安全？"><a href="#单例模式有几种实现？如何保证线程安全？" class="headerlink" title="单例模式有几种实现？如何保证线程安全？"></a>单例模式有几种实现？如何保证线程安全？</h3><p>对于单例模式的理解：一个类只能创建一个对象（或实例)，那这个类就是一个单例类，这种设计模式就叫做单例模式。（主要关注与对象的创建过程）</p>
<p><strong>常见的单例模式</strong></p>
<ul>
<li><strong>饿汉式：</strong> 实例在类加载时就创建，线程安全，但是如果实例初始化比价重或没有被使用就会浪费资源。</li>
<li><strong>懒汉式：</strong> 实例在首次访问时创建，节省资源，但需要确保线程安全。</li>
<li><strong>双重检查锁定：</strong> 在懒汉模式基础上进行优化，在第一次检查实例为空时加锁。</li>
<li><strong>静态内部类：</strong> 利用类加载机制实现懒加载和现场安全，推荐使用。</li>
<li><strong>枚举单例（Java）：</strong> 通过实现实例，简单防止反射和序列化攻击。</li>
</ul>
<h4 id="关于懒汉式解决线程安全问题"><a href="#关于懒汉式解决线程安全问题" class="headerlink" title="关于懒汉式解决线程安全问题"></a>关于懒汉式解决线程安全问题</h4><p><strong>懒汉式</strong>：在首次访问资源时，加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式单例类.在第一次调用的时候实例化自己 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Singleton single=<span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//静态工厂方法 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (single == <span class="literal">null</span>) &#123;  </span><br><span class="line">             single = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">         &#125;  </span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程环境下，可能出现出现线程安全问题，例如实例的多次创建</p>
<p>可以尝试对<code>getInstance</code> 方法加锁</p>
<p>方式一：在方法上加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (single == <span class="literal">null</span>) &#123;  </span><br><span class="line">             single = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">         &#125;  </span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>缺点：</p>
<ul>
<li>每次调用 <code>getInstance（）</code> 方法都要加锁，影响的运行效率，实际上只需要在第一次创建时加锁就能避免这种方式。</li>
</ul>
</blockquote>
<p>方式二：在方法内部加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">               <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">                  singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">               &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>减少了加锁范围，避免了每次获取实例时都要加锁。</li>
</ul>
</blockquote>
<p><code>volatile</code> 是 Java 中的一个关键字，用于修饰变量，主要作用是确保变量的可见性和禁止指令重排序。它在多线程编程中非常重要，尤其是在处理共享变量时。</p>
<ul>
<li><strong>可见性</strong>： <code>volatile</code> 保证了变量的可见性。当一个线程修改了一个 <code>volatile</code> 变量的值，这个新值会立即被写入主内存，而不是仅仅保存在线程的本地缓存中。其他线程在读取这个变量时，会直接从主内存中获取最新的值，而不是使用本地缓存中的旧值。</li>
<li><strong>禁止指令重排序：</strong> <code>volatile</code> 还禁止了指令重排序。编译器或处理器可能会对指令进行重排序以优化性能，但这种重排序在多线程环境下可能会导致问题。<code>volatile</code> 关键字确保了对该变量的读写操作不会被重排序。</li>
</ul>
<p><strong>双重检查锁</strong></p>
<p>类似于方法二，需要在变量上加 <code>volatile</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance; <span class="comment">// 就是这里</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span> &#123;  <span class="comment">// 静态内部类</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  <span class="comment">// 通过static final来修饰</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> LazyHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过静态内部类来创建，静态常量，在类加载时创建</p>
<p>特点： 延迟加载，线程安全，利用类加载机制实现，推荐使用。</p>
<h4 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingle</span> &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EnumSingle <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点： 不会被反射破坏。</p>
<h3 id="什么是策略模式？一般用在什么场景？"><a href="#什么是策略模式？一般用在什么场景？" class="headerlink" title="什么是策略模式？一般用在什么场景？"></a>什么是策略模式？一般用在什么场景？</h3><p>策略模式： 是一种行为设计模式，它允许在运行时，选择算法的行为。策略模式定义了一些列算法，并将每一个算法封装起来，使他们可以互相替换，。策略模式使得算法可以独立于使用它的客户端而变化。</p>
<p>定义思想：</p>
<p>策略模式的核心思想是将算法的定义与使用分离。通过将算法封装在独立的类中，客户端可以在运行时根据需要选择不同的策略，而不需要修改客户端的代码。</p>
<p>结构：</p>
<ul>
<li><strong>策略接口（Strategy Interface）</strong>：定义所有支持的算法或行为的公共接口。</li>
<li><strong>具体策略类（Concrete Strategy）</strong>：实现策略接口，提供具体的算法或行为。</li>
<li><strong>上下文类（Context）</strong>：持有一个策略对象的引用，并通过策略接口与具体策略类进行交互。</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>多种算法可互换：需要动态选择算法，例如排序算法。</li>
<li>避免条件语句： 通过策略模式替代代码中大量的 if-else 或 switch语句</li>
<li>与上下文独立：客户端不需要知道具体的算法实现细节，只需要依赖抽象策略。</li>
</ul>
<h3 id="什么是模版方法模式？一般用在什么场景？"><a href="#什么是模版方法模式？一般用在什么场景？" class="headerlink" title="什么是模版方法模式？一般用在什么场景？"></a>什么是模版方法模式？一般用在什么场景？</h3><p><strong>模版模式：</strong> 是一种行为设计模式，它定义了一个算法框架，并允许子类在不改变算法结构的情况下重新定义某些步骤。模板模式通过将算法的通用部分放在父类中，而将可变的部分留给子类来实现，从而实现了代码的复用和扩展。</p>
<p>定义思想：</p>
<p>模板模式的核心思想是将一个算法的结构固定下来，而将其中一些步骤的具体实现延迟到子类中。这样，父类可以控制算法的流程，而子类可以灵活地实现具体的步骤。</p>
<p>结构：</p>
<ul>
<li><strong>抽象类（Abstract Class）</strong>：定义算法的框架，并包含一些抽象方法或钩子方法，这些方法由子类实现。</li>
<li><strong>具体类（Concrete Class）</strong>：实现抽象类中的抽象方法，完成算法中特定步骤的具体实现。</li>
</ul>
<p>特点：</p>
<ul>
<li><strong>代码复用</strong>：将算法的通用部分放在父类中，避免了代码重复。</li>
<li><strong>扩展性</strong>：子类可以通过实现抽象方法来扩展算法的具体步骤，而不需要修改算法的结构。</li>
<li><strong>控制流程</strong>：父类控制算法的流程，子类只需关注具体的实现细节。</li>
</ul>
<h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li>当一个算法的步骤是固定的，但某些步骤的具体实现可能不同时。</li>
<li>当需要在多个类中复用相同的算法框架时。</li>
<li>当需要控制子类的扩展方式，确保子类遵循特定的算法结构时</li>
</ul>
<h2 id="day17"><a href="#day17" class="headerlink" title="day17"></a>day17</h2><h3 id="谈谈你最常用的设计模式，并说一下使用场景"><a href="#谈谈你最常用的设计模式，并说一下使用场景" class="headerlink" title="谈谈你最常用的设计模式，并说一下使用场景"></a>谈谈你最常用的设计模式，并说一下使用场景</h3><p>常见的设计模式包括，单例模式，简单工厂模式，策略模式，模版模式</p>
<p>单例模式：保证系统中一个对象只能有一个实例，如全局配置，连接池等</p>
<p>策略模式： 封装一组算法让他们之间能够互相替代，能够有效避免if else，如用户选择支付策略。</p>
<p>模版模式： 提炼核心流程封装成一个模版方法，如支付逻辑中支付，前置和后置检查是公用，让子类实现即可，调用父类支付方法将流程整合。</p>
<p>简单工厂：获取不同对象是可以使用，将对象的创建逻辑抽离复用。</p>
<p>外观模式： 为子系统提供一组统一接口，隐藏内部细节，方便子系统使用。</p>
<h3 id="好的代码应该具备什么？"><a href="#好的代码应该具备什么？" class="headerlink" title="好的代码应该具备什么？"></a>好的代码应该具备什么？</h3><p>我认为好的代码必须条理清晰，结构间接，并且互相之间分工明确，不相影响。</p>
<p>总结来讲就是：</p>
<ol>
<li>良好的扩展性</li>
<li>易读性</li>
<li>实现代码复用</li>
<li>良好的可维护性</li>
<li>简洁性</li>
<li>各种命名规范</li>
<li>减少硬代码</li>
</ol>
<h3 id="工厂模式和抽象工厂模式有什么区别？"><a href="#工厂模式和抽象工厂模式有什么区别？" class="headerlink" title="工厂模式和抽象工厂模式有什么区别？"></a>工厂模式和抽象工厂模式有什么区别？</h3><p>工厂模式<strong>关注的是创建单一类型对象</strong>，定义一个抽象方法，由子类实现具体对象的实例（单个）</p>
<p>抽象工厂模式 <strong>关注的是创建一族相关对象</strong>， 提供一个接口来创建一组相关的或相互依赖的对象，而无需指定他们的具体类。（一些列相关）</p>
<p><strong>适用场景</strong></p>
<ul>
<li><strong>工厂模式</strong>：适用于创建单一产品对象的场景。例如，一个日志记录器工厂可以创建文件日志记录器或数据库日志记录器。</li>
<li><strong>抽象工厂模式</strong>：适用于创建一系列相关或依赖的产品对象的场景。例如，一个跨平台的UI组件工厂可以创建Windows风格的按钮和文本框，或者Mac风格的按钮和文本框。</li>
</ul>
<blockquote>
<p>注意：Spring使用的是工厂模式，虽然管理多个Bean，但是这些 Bean 之间并不一定具有相关性或依赖性。（不是抽象工厂）</p>
</blockquote>
<h2 id="day18"><a href="#day18" class="headerlink" title="day18"></a>day18</h2><h3 id="常见的-HTTP-状态码有哪些？"><a href="#常见的-HTTP-状态码有哪些？" class="headerlink" title="常见的 HTTP 状态码有哪些？"></a>常见的 HTTP 状态码有哪些？</h3><p><strong>1XX</strong>: <strong>信息性状态码</strong></p>
<ul>
<li>100 Contionue： 客户端应继续发送请求</li>
<li>101 Switching Protocols： 服务器要求客户端切换协议；</li>
</ul>
<p><strong>2XX: 成功状态码</strong></p>
<ul>
<li>200 OK： 请求成功</li>
<li>201 Created： 请求已成功并创建了新的资源。</li>
<li>204 No Content: 服务器成功处理了请求，但没有返回任何信息</li>
</ul>
<p><strong>3XX: 重定向状态码</strong></p>
<ul>
<li>301 Moved Permanently：资源的URL已永久更改，需要更新链接。</li>
<li>302 Found：资源的URL临时性更改。</li>
<li>304 Not Modified：客户端缓存的资源仍然有效，无需重新传输。</li>
</ul>
<p><strong>4XX： 客户端错误状态码</strong></p>
<ul>
<li>400 Bad Request：服务器无法理解请求的语法。</li>
<li>403 Forbidden：服务器拒绝请求。</li>
<li>404 Not Found：请求的资源不存在。</li>
</ul>
<p><strong>5XX: 服务器错误状态码</strong></p>
<ul>
<li>500 Internal Server Error：服务器遇到了意外情况。</li>
<li>503 Service Unavailable：服务器当前无法处理请求</li>
</ul>
<h3 id="HTTP请求包含哪些内容？-请求头和请求体有哪些内容？"><a href="#HTTP请求包含哪些内容？-请求头和请求体有哪些内容？" class="headerlink" title="HTTP请求包含哪些内容？ 请求头和请求体有哪些内容？"></a>HTTP请求包含哪些内容？ 请求头和请求体有哪些内容？</h3><p>请求行， 请求头， 请求体</p>
<p>请求头：</p>
<ul>
<li>Host： url地址中的主机</li>
<li>User-Agent：客户端的信息描述（我是谁？）</li>
<li>Content-Type： 请求体的消息格式</li>
</ul>
<p>请求体：表单数据</p>
<h3 id="GET和POST区别是什么？"><a href="#GET和POST区别是什么？" class="headerlink" title="GET和POST区别是什么？"></a>GET和POST区别是什么？</h3><ul>
<li>get 是HTTP协议中的一种请求方式，主要用于服务获取信息</li>
<li>post 是HTTP协议中的一种请求方式，主要用于向服务器发送数据</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li><strong>传输方式不同</strong>， get请求方式数据被包含在URL中，数据在网络上以明文的形式传输，数据量小；post数据存放在请求体里面，可以传输数据量大。</li>
<li><strong>数据量大小不同：</strong> get小，浏览器对长度有限制；post理论上没有限制，大。</li>
<li><strong>安全性不同：</strong> 由于get请求在URL中是可见的，不安全，不适合传输敏感信息。post方法的数据在请求体中，相对较为安全</li>
<li><strong>幂等性不同：</strong> get方法是幂等的，也就是说多次请求同一个URL，服务器的状态不会改变。而post方法不是幂等的，每次请求可能得到不同的结果。</li>
<li><strong>缓存方式不同：</strong> get方法通常可以被浏览器缓存，而post方法无法缓存。</li>
</ul>
<h2 id="day19"><a href="#day19" class="headerlink" title="day19"></a>day19</h2><h3 id="HTTP1-0和2-0有什么区别？"><a href="#HTTP1-0和2-0有什么区别？" class="headerlink" title="HTTP1.0和2.0有什么区别？"></a>HTTP1.0和2.0有什么区别？</h3><p>主要区别如下：</p>
<p><strong>1. 连接管理</strong></p>
<ul>
<li><strong>HTTP&#x2F;1.0</strong>：每个请求都需要建立和关闭一个独立的TCP连接，增加了延迟和资源消耗。</li>
<li><strong>HTTP&#x2F;2.0</strong>：支持多路复用，允许在单个TCP连接上同时发送多个请求和响应，减少了连接开销。</li>
</ul>
<p><strong>2. 多路复用</strong></p>
<ul>
<li><strong>HTTP&#x2F;1.0</strong>：请求和响应必须按顺序处理，容易导致队头阻塞。</li>
<li><strong>HTTP&#x2F;2.0</strong>：通过多路复用，请求和响应可以并行处理，避免了队头阻塞，提升了性能。</li>
</ul>
<p><strong>3. 二进制格式</strong></p>
<ul>
<li><strong>HTTP&#x2F;1.0</strong>：使用文本格式传输数据，解析效率较低。</li>
<li><strong>HTTP&#x2F;2.0</strong>：采用二进制格式，解析更高效，减少了错误。</li>
</ul>
<p> <strong>4.头部压缩</strong></p>
<ul>
<li><strong>HTTP&#x2F;1.0</strong>：每次请求和响应都发送完整的头部信息，增加了开销。</li>
<li><strong>HTTP&#x2F;2.0</strong>：使用HPACK压缩头部，减少了数据传输量。</li>
</ul>
<p><strong>5. 服务器推送</strong></p>
<ul>
<li><strong>HTTP&#x2F;1.0</strong>：服务器只能响应客户端请求。</li>
<li><strong>HTTP&#x2F;2.0</strong>：服务器可以主动推送资源，减少客户端请求次数，提升加载速度。</li>
</ul>
<p><strong>6. 流控制</strong></p>
<ul>
<li><strong>HTTP&#x2F;1.0</strong>：缺乏流控制机制。</li>
<li><strong>HTTP&#x2F;2.0</strong>：支持流控制，允许客户端和服务器管理数据流，优化资源使用。</li>
</ul>
<p><strong>7. 优先级</strong></p>
<ul>
<li><strong>HTTP&#x2F;1.0</strong>：无优先级机制。</li>
<li><strong>HTTP&#x2F;2.0</strong>：允许为请求设置优先级，确保重要资源优先传输。</li>
</ul>
<h3 id="HTTP2-0和3-0区别"><a href="#HTTP2-0和3-0区别" class="headerlink" title="HTTP2.0和3.0区别"></a>HTTP2.0和3.0区别</h3><p>HTTP&#x2F;2.0 和 HTTP&#x2F;3.0 的主要区别在于底层传输协议和性能优化。以下是它们的核心差异：</p>
<p><strong>1. 传输协议</strong></p>
<ul>
<li><strong>HTTP&#x2F;2.0</strong>：基于 <strong>TCP</strong> 协议。<ul>
<li>虽然通过多路复用解决了队头阻塞问题，但 TCP 的固有特性（如丢包重传）仍可能导致性能下降。</li>
</ul>
</li>
<li><strong>HTTP&#x2F;3.0</strong>：基于 <strong>QUIC</strong> 协议（运行在 UDP 上）。<ul>
<li>QUIC 解决了 TCP 的队头阻塞问题，丢包只影响单个流，而不是整个连接。</li>
<li>内置加密（基于 TLS 1.3），减少了握手延迟。</li>
</ul>
</li>
</ul>
<p><strong>2. 建立连接的速度</strong></p>
<ul>
<li><strong>HTTP&#x2F;2.0</strong>：<ul>
<li>需要 TCP 三次握手 + TLS 握手，通常需要 2-3 个 RTT（往返时间）才能建立安全连接。</li>
</ul>
</li>
<li><strong>HTTP&#x2F;3.0</strong>：<ul>
<li>QUIC 将传输和加密合二为一，首次连接只需 1 RTT，甚至通过连接恢复实现 0 RTT。</li>
</ul>
</li>
</ul>
<p><strong>3. 队头阻塞问题</strong></p>
<ul>
<li><strong>HTTP&#x2F;2.0</strong>：<ul>
<li>在 TCP 层仍然存在队头阻塞。如果某个数据包丢失，后续数据包会被阻塞，直到丢失的包重传成功。</li>
</ul>
</li>
<li><strong>HTTP&#x2F;3.0</strong>：<ul>
<li>QUIC 在传输层解决了队头阻塞问题。每个流（stream）独立处理，丢包不会影响其他流。</li>
</ul>
</li>
</ul>
<p><strong>4. 连接迁移</strong></p>
<ul>
<li><p><strong>HTTP&#x2F;2.0</strong>：</p>
<ul>
<li>基于 TCP 的连接依赖于 IP 和端口，切换网络（如从 Wi-Fi 到移动网络）时连接会中断。</li>
</ul>
</li>
<li><p><strong>HTTP&#x2F;3.0</strong>：</p>
<ul>
<li>QUIC 使用连接 ID 而不是 IP 和端口来标识连接，支持无缝切换网络，适合移动设备。</li>
</ul>
</li>
</ul>
<h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><p><strong>1. 数据传输安全性</strong></p>
<ul>
<li>HTTP：数据以明文的方式传输容易被窃听，篡改。</li>
<li>HTTPS： 通过SSL&#x2F;TLS协议对数据进行加密传输，提供数据机密性和完整性保障</li>
</ul>
<p><strong>2. 端口号</strong></p>
<ul>
<li>HTTP：默认端口号80</li>
<li>HTTPS；默认端口号443</li>
</ul>
<p><strong>3. 性能</strong></p>
<ul>
<li>HTTP： 无加密过程，连接建立速度稍快</li>
<li>HTTPS: 基于HTTP上又加了SSL或TLS协议来实现的加密传输，加密过程增加了计算开销，握手时间较长，但现代硬件和协议优化已使性能差距减小。</li>
</ul>
<p><strong>4. SEO影响</strong></p>
<ul>
<li>HTTP：搜索引擎一般会降低未加密站点的排名。</li>
<li>HTTPS：搜索引擎更倾向于优先展示HTTPS网站。</li>
</ul>
<h2 id="day20"><a href="#day20" class="headerlink" title="day20"></a>day20</h2><h3 id="TCP和UDP有什么区别？"><a href="#TCP和UDP有什么区别？" class="headerlink" title="TCP和UDP有什么区别？"></a>TCP和UDP有什么区别？</h3><p>关于TCP和UDP，连接、可靠性、传输方式、最后总结，这两个协议的优劣势</p>
<ul>
<li>TCP是面向连接的协议，在发送数据的时候，需要先建立TCP三次握手，而UDP无连接协议，直接就可以发送数据</li>
<li>TCP会通过超时重传、流量控制、拥塞控制保证数据的可靠传输，而UDP并没有这些特性，UDP不考虑数据的可靠性。</li>
<li>TCP发送的数据是以字节流的形式、没有边界。而UDP是一个包一个包的发送，是有边界的。</li>
</ul>
<p>综合来看：</p>
<ul>
<li>TCP的优势在于可以保证数据的可靠性，但是缺陷就是实时性没有UDP协议好。</li>
<li>UDP的优势在于足够简单，不用建立连接，数据直接丢过去即可，并且UDP包头比TCP包头小很多，所以UDP实时性和速度方面是比TCP好的。</li>
</ul>
<p><strong>TCP（传输控制协议）</strong></p>
<p>面向连接的协议，通过建立可靠的连接来传输数据；TCP提供了可靠的传输，利用序号和重传机制确保数据的完整性和可靠性。传输数据慢，消耗资源多</p>
<p><strong>UDP（用户数据报协议）</strong></p>
<p>无连接协议，数据包发送前不需要建立连接；不提供可靠性保证，数据发送后不能得到确认和重传，UDP相对于TCP更加轻量，传输数据快，消耗资源少</p>
<h3 id="说说TCP的三次握手"><a href="#说说TCP的三次握手" class="headerlink" title="说说TCP的三次握手"></a>说说TCP的三次握手</h3><p>客户端会先向服务器发送一个SYN（同步序列编号) 消息给服务器，服务器收到后回复一个SYN-ACK（同步序列编号-确认）消息，最后客户端再发送一个ACK（确认）消息确认服务器已经收到SYN-ACK消息，从而完成了三次握手，建立起一个可靠的TCP连接。</p>
<p><img src="https://pic1.imgdb.cn/item/67a9508dd0e0a243d4fdbe38.png"></p>
<p>三次握手是建立连接的，目的是解决网络信道不可靠的问题。</p>
<p><img src="https://pic1.imgdb.cn/item/67a95118d0e0a243d4fdbe42.png"></p>
<h3 id="TCP是用来解决什么问题的？"><a href="#TCP是用来解决什么问题的？" class="headerlink" title="TCP是用来解决什么问题的？"></a>TCP是用来解决什么问题的？</h3><p>TCP通过提供可靠传输、流量控制、拥塞控制和连接管理，解决了数据在不可靠的IP网络上的传输问题：</p>
<ol>
<li><strong>可靠传输</strong>：TCP确保数据包在网络传输过程中不丢失、不重复，并且按顺序到达。通过确认（ACK），重传机制以及序列号，TCP能够保证数据在不可靠的IP网络上可靠传输。</li>
<li><strong>流量控制</strong>：TCP通过滑动窗口机制调节发送方的数据发送速率，防止接收方因为处理能力有限而别数据流淹没。</li>
<li><strong>拥塞控制：</strong> TCP是通过拥塞算法（如慢启动、拥塞避免、快速重传和快速恢复）来防止网络过载，确保网络资源的公平性和稳定性。</li>
<li><strong>连接管理：</strong> TCP是面向连接的协议,采用三次握手（建立连接）和四次挥手（断开连接）机制来管理会话，确保通信的可靠性和状态的同步。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/18/spring%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/18/spring%E9%9D%A2%E8%AF%95/" class="post-title-link" itemprop="url">spring面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-18 08:44:14" itemprop="dateCreated datePublished" datetime="2025-02-18T08:44:14+08:00">2025-02-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-24 15:14:25" itemprop="dateModified" datetime="2025-02-24T15:14:25+08:00">2025-02-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h2><p>存在两个Bean，且这两个Bean互相依赖，（或自己依赖自己），就会出现循环依赖（类似死锁）</p>
<h2 id="循环依赖怎么解决？"><a href="#循环依赖怎么解决？" class="headerlink" title="循环依赖怎么解决？"></a>循环依赖怎么解决？</h2><h3 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h3><p>一级缓存（单例池）： 放置创建好的Bean（完整的）</p>
<p>二级缓存： 用来保存Bean的代理或普通对象，不完整</p>
<p>三级缓存： Bean的创建工厂，用来初始化bean</p>
<p><img src="https://pic1.imgdb.cn/item/67b5dbfad0e0a243d400cfd6.png"></p>
<p><img src="https://pic1.imgdb.cn/item/67b5dd96d0e0a243d400d012.png"></p>
<p>注意： </p>
<ul>
<li>Mysql只支持单例的循环依赖。</li>
<li>不全是构造器注入</li>
</ul>
<h3 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h3><h4 id="Lazy-的作用"><a href="#Lazy-的作用" class="headerlink" title="@Lazy 的作用"></a><strong><code>@Lazy</code> 的作用</strong></h4><p><code>@Lazy</code> 注解的作用是延迟 Bean 的初始化，直到第一次被使用时才会创建 Bean 实例。通过延迟初始化，可以打破循环依赖的初始化顺序，从而间接解决循环依赖问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里，<code>A</code> 中的 <code>B</code> 被标记为 <code>@Lazy</code>，因此 <code>B</code> 不会在 <code>A</code> 初始化时立即创建，而是在第一次使用时才会初始化</li>
</ul>
<h4 id="Lazy-解决循环依赖的原理"><a href="#Lazy-解决循环依赖的原理" class="headerlink" title="@Lazy 解决循环依赖的原理"></a><strong><code>@Lazy</code> 解决循环依赖的原理</strong></h4><ol>
<li><strong>打破初始化顺序</strong>：<ul>
<li>通过延迟初始化，Spring 不需要在初始化 <code>A</code> 时立即初始化 <code>B</code>，从而打破了循环依赖的初始化顺序。</li>
</ul>
</li>
<li><strong>代理对象的创建</strong>：<ul>
<li>当使用 <code>@Lazy</code> 时，Spring 会为目标 Bean 创建一个代理对象（通常是基于 CGLIB 或 JDK 动态代理）。</li>
<li>在第一次访问该 Bean 时，代理对象会触发实际的 Bean 初始化。</li>
</ul>
</li>
<li><strong>避免死锁</strong>：<ul>
<li>由于延迟初始化，Spring 不会在初始化过程中陷入死锁状态，从而避免了循环依赖问题。</li>
</ul>
</li>
</ol>
<h2 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h2><p>AOP全程（Aspact-Oriented Programming) 面相切面编程是一种编程范式，常用于日志记录，安全检查，事务管理等与业务逻辑分离开来。</p>
<ul>
<li><strong>核心思想：</strong> AOP的核心思想是将与业务逻辑无关的关注点抽取出来，通过声明的方式动态的应用到业务方法上，而不是将这些代码直接嵌入到业务逻辑中。</li>
<li><strong>主要组成部分：</strong> 切面，连接点，通知，切入点，织入</li>
</ul>
<p>通常是通过代理的对象来实现动态切入的</p>
<p>代理可以分成两个类</p>
<ul>
<li>动态代理： 在<strong>运行时</strong>将切面的逻辑写入，程序会自动的在运行时生成类似上面的代理类。</li>
<li>静态代理： 在<strong>编译时或者类加载时</strong> 进行切面的织入，典型的<strong>AspactJ</strong>就是静态代理。</li>
</ul>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul>
<li>切面（Aspact）</li>
<li>连接点（Join Point）</li>
<li>通知（Advice）<ul>
<li>前置通知（Before）</li>
<li>后置通知（After)</li>
<li>环绕通知（Around）</li>
<li>异常通知（AfterThrowing）</li>
<li>返回通知（AfterReturing)</li>
</ul>
</li>
<li>切入点（Poincut)</li>
<li>织入（Weaving）织入是将切面应用到目标对象的过程。可以在编译时，类加载是或运行时进行织入。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>日志记录</p>
<p>事务管理</p>
<p>安全检查</p>
<p>性能监控</p>
<h2 id="SpringAop和AspectJ区别？"><a href="#SpringAop和AspectJ区别？" class="headerlink" title="SpringAop和AspectJ区别？"></a>SpringAop和AspectJ区别？</h2><p>springAop 基于动态代理</p>
<p>没有自己定义动态代理，通过Aspect，注解的定义。技术是自己实现的，底层的技术是不一样的。</p>
<p>AspectJ 基于编译期</p>
<p>在编译成字节码时，将额外的逻辑织入到字节码中。</p>
<p>更强</p>
<p><strong>SpringAOP：</strong> 是Spring框架提供的一种AOP实现，主要用于运行时的代理机制</p>
<ul>
<li><strong>特点：</strong> Spring AOP是基于<strong>动态代理</strong>实现的，适用于spring容器管理的Bean，较轻量级，使用方便。</li>
<li><strong>使用场景</strong>： 适合大部分业务场景，尤其是简单AOP功能的Spring应用。</li>
</ul>
<p><strong>AspectJ：</strong>AspectJ是功能更强大的AOP框架，支持编译时，类加载时和运行时的AOP功能。</p>
<ul>
<li><strong>特点：</strong>AspectJ是支持更加灵活的切点和增强操作，提供<strong>编译时和加载期和运行时</strong>的织入方式，性能较高。</li>
<li>使用场景： 适合对性能要求较高或需要复杂切入点匹配的场景，如日志，监控等。</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="Spring事务的隔离级别？"><a href="#Spring事务的隔离级别？" class="headerlink" title="Spring事务的隔离级别？"></a>Spring事务的隔离级别？</h3><p>Spring提供了5种隔离级别</p>
<ul>
<li><strong>DEFAULT（默认）</strong>： 使用底层数据库的默认隔离级别，如果数据库没有特定的设置，通常默认为READ_COMMITTED（读已提交）</li>
<li><strong>READ_UNCOMMITTED（读未提交）</strong>：最低的隔离级别，允许事务读取尚未提交的数据，可能会导致出现脏读，不可重复读，幻读。</li>
<li><strong>READ_COMMITTED（读已提交）</strong>： 仅允许读取已经提交的数据，避免了脏读，可能会导致出现不可重复读和幻读问题。</li>
<li><strong>REPEATABLE_READ（可重复读）</strong>： 确保在同一个事务内的多次读取结果一致，避免了脏读和不可重复读，会出现幻读的问题。</li>
<li>**SERIALIZABLE(可串行化)**： 最高的隔离级别，通过强制事务按顺序执行，完全避免脏读，不可重复读和幻读，代价是性能显著下降。</li>
</ul>
<h3 id="Spring事务的传播行为有几种？分别是什么？"><a href="#Spring事务的传播行为有几种？分别是什么？" class="headerlink" title="Spring事务的传播行为有几种？分别是什么？"></a>Spring事务的传播行为有几种？分别是什么？</h3><p>答：有七种。</p>
<p><strong>1. REQUIRED（默认）</strong></p>
<ul>
<li>定义： 如果当前存在事务，则加入事务；如果当前没有事务，则创建一个新事务。</li>
<li>使用场景： 大多数场景下使用，适用于需要事务支持的操作。</li>
</ul>
<p><strong>2. REQUIRES_NEW</strong></p>
<ul>
<li>定义： 无论当前是否存在事务，都创建一个新事物。如果当前存在事务，则将当前事务挂起。</li>
<li>使用场景: 适用于需要独立事务的操作，不受外部事务影响。</li>
</ul>
<p><strong>3. SUPPORTS</strong></p>
<ul>
<li>如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</li>
<li>使用场景： 适用于不需要强制事务支持的操作。</li>
</ul>
<p><strong>4. NOT_SUPPORTD</strong></p>
<ul>
<li>以非事务方式执行操作，如果当前存在事务，则将当前事务挂起。</li>
<li>使用场景：适用于不需要事务支持的操作，且不希望受外部事务影响。</li>
</ul>
<p> <strong>5. MANDATORY</strong></p>
<p>强制性的</p>
<ul>
<li>如果当前存在事务，则加入该事务，如果当前没有存在事务，则抛出异常。</li>
<li>使用场景： 必须在一个已有事务中执行操作。</li>
</ul>
<p><strong>6. NEVER</strong></p>
<p>never</p>
<ul>
<li>以非事务方式执行操作，如果当前存在事务，则抛出异常。</li>
<li>使用场景：适用于绝对不能在一个事务中执行的操作。</li>
</ul>
<p><strong>7. NESTED</strong></p>
<p>nested</p>
<ul>
<li>如果当前存在事务，则在嵌套事务中执行；如果当前没有事务，则创建一个事务。</li>
<li>嵌套事务： 嵌套事务是外部事务的子事务，如果外部事务回滚，嵌套事务也会回滚；但嵌套事务可以独立提交或回滚，而不影响外部事务。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li><strong>REQUIRED</strong>：默认方式，支持当前事务，不存在则创建新事务。</li>
<li><strong>REQUIRES_NEW</strong>：总是创建新事务，挂起当前事务（如果有）。</li>
<li><strong>SUPPORTS</strong>：支持当前事务，不存在则以非事务方式执行。</li>
<li><strong>NOT_SUPPORTED</strong>：以非事务方式执行，挂起当前事务（如果有）。</li>
<li><strong>MANDATORY</strong>：必须在一个已有事务中执行，否则抛出异常。</li>
<li><strong>NEVER</strong>：必须不在事务中执行，否则抛出异常。</li>
<li><strong>NESTED</strong>：在嵌套事务中执行，支持部分回滚。</li>
</ul>
<h3 id="事务的传播行为有什么作用？"><a href="#事务的传播行为有什么作用？" class="headerlink" title="事务的传播行为有什么作用？"></a>事务的传播行为有什么作用？</h3><p>作用：定义事务方法在调用其他事务方法时，事务应该如何传播。</p>
<h4 id="1-控制事务的创建和加入"><a href="#1-控制事务的创建和加入" class="headerlink" title="1. 控制事务的创建和加入"></a>1. 控制事务的创建和加入</h4><ul>
<li>传播行为决定了当前方法是否需要创建一个新事务，或者是否加入一个已有事务。</li>
<li>例如：<ul>
<li><strong>REQUIRED</strong>：如果当前没有事务，则创建一个新事务；如果当前有事务，则加入该事务。</li>
<li><strong>REQUIRES_NEW</strong>：无论当前是否有事务，都创建一个新事务，并挂起当前事务（如果有）。</li>
</ul>
</li>
</ul>
<h4 id="2-管理事务的独立性"><a href="#2-管理事务的独立性" class="headerlink" title="2. 管理事务的独立性"></a>2. 管理事务的独立性</h4><ul>
<li>传播行为可以控制事务的独立性，确保某些操作不受外部事务的影响。</li>
<li>例如：<ul>
<li><strong>REQUIRES_NEW</strong>：创建一个独立的新事务，即使外部事务回滚，也不会影响当前事务。</li>
<li><strong>NOT_SUPPORTED</strong>：以非事务方式执行操作，挂起当前事务（如果有），确保操作不受事务影响。</li>
</ul>
</li>
</ul>
<h4 id="3-支持事务的嵌套"><a href="#3-支持事务的嵌套" class="headerlink" title="3. 支持事务的嵌套"></a>3. 支持事务的嵌套</h4><ul>
<li>传播行为支持嵌套事务，允许在一个事务中执行另一个事务，并实现部分回滚。</li>
<li>例如：<ul>
<li><strong>NESTED</strong>：在嵌套事务中执行，如果外部事务回滚，嵌套事务也会回滚；但嵌套事务可以独立提交或回滚，而不影响外部事务。</li>
</ul>
</li>
</ul>
<h4 id="4-强制事务约束"><a href="#4-强制事务约束" class="headerlink" title="4. 强制事务约束"></a>4. 强制事务约束</h4><ul>
<li>传播行为可以强制某些操作必须在事务中执行，或者绝对不能在一个事务中执行。</li>
<li>例如：<ul>
<li><strong>MANDATORY</strong>：必须在一个已有事务中执行，否则抛出异常。</li>
<li><strong>NEVER</strong>：必须不在事务中执行，否则抛出异常。</li>
</ul>
</li>
</ul>
<h4 id="5-优化性能"><a href="#5-优化性能" class="headerlink" title="5. 优化性能"></a>5. 优化性能</h4><ul>
<li>传播行为可以通过减少不必要的事务创建和提交，优化系统性能。</li>
<li>例如：<ul>
<li><strong>SUPPORTS</strong>：如果当前没有事务，则以非事务方式执行，避免创建不必要的事务。</li>
</ul>
</li>
</ul>
<h4 id="6-实现复杂的业务逻辑"><a href="#6-实现复杂的业务逻辑" class="headerlink" title="6. 实现复杂的业务逻辑"></a>6. 实现复杂的业务逻辑</h4><ul>
<li>传播行为可以帮助实现复杂的业务逻辑，例如：<ul>
<li>在一个事务中执行多个操作，但某些操作需要独立事务。</li>
<li>部分操作需要回滚，而其他操作需要提交。</li>
</ul>
</li>
</ul>
<h4 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. <strong>总结</strong></h4><ul>
<li><strong>控制事务的创建和加入</strong>：决定是否需要创建新事务或加入已有事务。</li>
<li><strong>管理事务的独立性</strong>：确保某些操作不受外部事务影响。</li>
<li><strong>支持事务的嵌套</strong>：实现部分回滚的能力。</li>
<li><strong>强制事务的约束</strong>：确保某些操作必须在事务中执行，或者绝对不能在一个事务中执行。</li>
<li><strong>优化性能</strong>：减少不必要的事务创建和提交。</li>
<li><strong>实现复杂的业务逻辑</strong>：支持复杂的业务场景。</li>
</ul>
<p>reqired</p>
<p>reqires_new</p>
<p>supports</p>
<p>not_supports</p>
<h3 id="事务在什么情况下会失效？"><a href="#事务在什么情况下会失效？" class="headerlink" title="事务在什么情况下会失效？"></a>事务在什么情况下会失效？</h3><p>注意：只会回滚RuntimeException</p>
<p>一般情况而言，失效的情况都是使用了声明式事务<code>@Transactional</code> 注解，如果使用了这个注解那么在以下几个情况下会导致事务的失效。</p>
<ol>
<li><p><strong>异常被捕获</strong>，比如代码抛出，但是被catch了，事务无法捕获到错误，因此就不会回滚。</p>
</li>
<li><p><strong>设置rollbackFor错误</strong>，前面提到，事务只会处理RuntimeException和Error，对于其他的异常需要自己设置rollbackFor。</p>
<img src="https://pic1.imgdb.cn/item/67bc1a1fd0e0a243d40343af.png" alt="image.png">
</li>
<li><p><strong>同一个类中方法调用</strong>，因为事务是基于动态代理机制实现的，同类的方法调用不会走代理，因此事务自然就失效了。</p>
</li>
<li><p>@Transactional 应用在 **非public修饰的方法 **上，Spring事务判断非公共方法则不应用事务。</p>
</li>
<li><p>@Transactional 应用在 <strong>final 和static 方法</strong>上，因为aop默认 cglib代理，无法对final方法子类化。static是静态方法，属于类不属于实例对象，无法被代理</p>
</li>
<li><p>propagation传播机制配置错误</p>
</li>
<li><p>多线程环境，因为 @Transactional 是基于 ThreadLocal 存储上下问的，多线程情况下每个线程都有自己的上下文，那么之间如何保持事务同步？保持不了，因此事务失效。</p>
</li>
<li><p>用的是MySQL MyISAM，这个引擎本身不支持事务。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/14/jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/14/jvm/" class="post-title-link" itemprop="url">jvm</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-14 16:55:52" itemprop="dateCreated datePublished" datetime="2025-02-14T16:55:52+08:00">2025-02-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-15 10:08:22" itemprop="dateModified" datetime="2025-02-15T10:08:22+08:00">2025-02-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>JVM跨平台原理：</p>
<p>不同操作系统上运行的JVM是不一样的，这才是JVM跨平台的本质。	</p>
<h2 id="字节码的作用"><a href="#字节码的作用" class="headerlink" title="字节码的作用"></a>字节码的作用</h2><p><img src="https://pic1.imgdb.cn/item/67aff707d0e0a243d4ff7cd8.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZhangYuHao</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
