<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一个小人物的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Zhang&#39;Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Zhang&#39;Blog">
<meta property="og:description" content="一个小人物的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZhangYuHao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zhang'Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhang'Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZhangYuHao"
      src="/images/111.png">
  <p class="site-author-name" itemprop="name">ZhangYuHao</p>
  <div class="site-description" itemprop="description">一个小人物的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/2567821933" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;2567821933" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:103903Zyh@gmail.com" title="E-Mail → mailto:103903Zyh@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/23/JWT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/03/23/JWT/" class="post-title-link" itemprop="url">JWT</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-03-23 19:47:30 / 修改时间：20:53:43" itemprop="dateCreated datePublished" datetime="2025-03-23T19:47:30+08:00">2025-03-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="JWT-是什么？"><a href="#JWT-是什么？" class="headerlink" title="JWT 是什么？"></a>JWT 是什么？</h3><p>JWT（JSON Web Token）是一种开放标准（RFC 7519），用于在网络应用间安全地传输信息。它由三部分组成：<strong>Header</strong>、<strong>Payload</strong> 和 <strong>Signature</strong>，通常以紧凑的 URL 安全字符串形式表示。</p>
<h4 id="JWT-的结构"><a href="#JWT-的结构" class="headerlink" title="JWT 的结构"></a>JWT 的结构</h4><ol>
<li><p><strong>Header</strong>：</p>
<ul>
<li><p>包含令牌类型（如 JWT）和签名算法（如 HMAC SHA256 或 RSA）。</p>
</li>
<li><p>示例：</p>
<p>json</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Payload</strong>：</p>
<ul>
<li><p>包含声明（claims），声明是关于实体（通常是用户）和其他数据的声明。</p>
</li>
<li><p>示例：</p>
<p>json</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Signature</strong>：</p>
<ul>
<li><p>用于验证消息在传输过程中没有被篡改。</p>
</li>
<li><p>签名是通过将编码后的 Header 和 Payload 与一个密钥一起使用指定的算法生成的。</p>
</li>
<li><p>示例：</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="JWT-的工作流程"><a href="#JWT-的工作流程" class="headerlink" title="JWT 的工作流程"></a>JWT 的工作流程</h4><ol>
<li><strong>用户登录</strong>：用户提供凭证（如用户名和密码），服务器验证凭证并生成 JWT。</li>
<li><strong>返回 JWT</strong>：服务器将 JWT 返回给客户端。</li>
<li><strong>客户端存储 JWT</strong>：客户端通常将 JWT 存储在本地存储或 cookie 中。</li>
<li><strong>发送 JWT</strong>：客户端在每次请求时发送 JWT，通常在 <code>Authorization</code> 头中。</li>
<li><strong>服务器验证 JWT</strong>：服务器验证 JWT 的签名和声明，如果有效则处理请求。</li>
</ol>
<p>WT（JSON Web Token）的刷新机制用于在访问令牌过期后获取新的令牌，以延长用户的认证状态，而无需重新登录。</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ol>
<li><strong>访问令牌（Access Token）</strong>：<ul>
<li>用于访问受保护资源，有效期较短，通常几分钟到几小时。</li>
</ul>
</li>
<li><strong>刷新令牌（Refresh Token）</strong>：<ul>
<li>用于获取新的访问令牌，有效期较长，通常几天到几周。</li>
</ul>
</li>
</ol>
<h3 id="刷新机制流程"><a href="#刷新机制流程" class="headerlink" title="刷新机制流程"></a>刷新机制流程</h3><ol>
<li><strong>用户登录</strong>：<ul>
<li>认证成功后，服务器返回访问令牌和刷新令牌。</li>
</ul>
</li>
<li><strong>访问资源</strong>：<ul>
<li>客户端使用访问令牌访问资源。</li>
</ul>
</li>
<li><strong>访问令牌过期</strong>：<ul>
<li>当访问令牌失效时，客户端使用刷新令牌请求新的访问令牌。</li>
</ul>
</li>
<li><strong>刷新令牌</strong>：<ul>
<li>服务器验证刷新令牌，若有效则返回新的访问令牌，有时还会返回新的刷新令牌。</li>
</ul>
</li>
<li><strong>继续访问</strong>：<ul>
<li>客户端使用新的访问令牌继续访问资源。</li>
</ul>
</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><strong>安全性</strong>：访问令牌有效期短，减少被盗风险。</li>
<li><strong>用户体验</strong>：无需频繁登录，刷新令牌可延长会话。</li>
</ul>
<h2 id="关于令牌刷新机制"><a href="#关于令牌刷新机制" class="headerlink" title="关于令牌刷新机制"></a>关于令牌刷新机制</h2><p>令牌刷新机制需要<strong>手动实现</strong>，JWT 本身并不提供自动刷新功能。刷新机制的设计是为了在访问令牌（Access Token）过期后，用户无需重新登录，而是通过刷新令牌（Refresh Token）获取新的访问令牌。</p>
<hr>
<h3 id="1-为什么需要刷新机制？"><a href="#1-为什么需要刷新机制？" class="headerlink" title="1. 为什么需要刷新机制？"></a><strong>1. 为什么需要刷新机制？</strong></h3><ul>
<li><strong>访问令牌有效期短</strong>：为了安全，访问令牌通常设置较短的有效期（如 15 分钟）。</li>
<li><strong>用户体验</strong>：如果每次访问令牌过期都要求用户重新登录，体验会很差。</li>
<li><strong>安全性</strong>：刷新令牌的有效期较长，但只能用于获取新的访问令牌，不能直接访问资源。</li>
</ul>
<hr>
<h3 id="2-刷新机制的核心流程"><a href="#2-刷新机制的核心流程" class="headerlink" title="2. 刷新机制的核心流程"></a><strong>2. 刷新机制的核心流程</strong></h3><ol>
<li><strong>用户登录</strong>：<ul>
<li>服务器返回访问令牌和刷新令牌。</li>
</ul>
</li>
<li><strong>访问令牌过期</strong>：<ul>
<li>客户端使用刷新令牌请求新的访问令牌。</li>
</ul>
</li>
<li><strong>服务器验证刷新令牌</strong>：<ul>
<li>如果刷新令牌有效，返回新的访问令牌（和可选的新的刷新令牌）。</li>
</ul>
</li>
<li><strong>客户端使用新令牌</strong>：<ul>
<li>客户端使用新的访问令牌继续访问资源。</li>
</ul>
</li>
</ol>
<h3 id="3-刷新机制-vs-长有效期访问令牌"><a href="#3-刷新机制-vs-长有效期访问令牌" class="headerlink" title="3. 刷新机制 vs 长有效期访问令牌"></a><strong>3. 刷新机制 vs 长有效期访问令牌</strong></h3><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>刷新机制</strong></th>
<th align="left"><strong>长有效期访问令牌</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">高（访问令牌有效期短，泄露风险低）</td>
<td align="left">低（访问令牌有效期长，泄露风险高）</td>
</tr>
<tr>
<td align="left"><strong>用户体验</strong></td>
<td align="left">好（无需频繁登录）</td>
<td align="left">差（需要频繁登录）</td>
</tr>
<tr>
<td align="left"><strong>实现复杂度</strong></td>
<td align="left">较高（需要实现刷新逻辑）</td>
<td align="left">低（无需额外逻辑）</td>
</tr>
<tr>
<td align="left"><strong>令牌撤销</strong></td>
<td align="left">支持（可撤销刷新令牌）</td>
<td align="left">不支持（无法主动撤销）</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">高安全性要求的系统（如金融、医疗）</td>
<td align="left">低安全性要求的系统（如内部测试）</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/23/%E5%85%B3%E4%BA%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/03/23/%E5%85%B3%E4%BA%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" class="post-title-link" itemprop="url">关于定时任务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-03-23 10:31:11 / 修改时间：10:47:06" itemprop="dateCreated datePublished" datetime="2025-03-23T10:31:11+08:00">2025-03-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="关于定时任务的选择"><a href="#关于定时任务的选择" class="headerlink" title="关于定时任务的选择"></a>关于定时任务的选择</h1><h2 id="Scheduled注解"><a href="#Scheduled注解" class="headerlink" title="@Scheduled注解"></a>@Scheduled注解</h2><ul>
<li>适用场景： 简单的定时任务</li>
<li>使用方法：<ul>
<li>在Spring Boot项目中，启用定时任务功能，在启动类或配置类上添加<code>@EnableScheduling</code>注解。</li>
<li>在需要定时执行的方法上添加<code>@Scheduled</code>注解，并配置执行时间。</li>
</ul>
</li>
</ul>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledTasks</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 5000)</span> <span class="comment">// 每5秒执行一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskWithFixedRate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fixed rate task - &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 0 12 * * ?&quot;)</span> <span class="comment">// 每天中午12点执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">taskWithCronExpression</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cron task - &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Quartez-框架"><a href="#Quartez-框架" class="headerlink" title="Quartez 框架"></a>Quartez 框架</h2><ul>
<li>适用场景：复杂的定时任务，支持分布式调度、任务持久化等。</li>
<li>使用方法：<ul>
<li>引入Quartz依赖（Spring Boot中可以使用<code>spring-boot-starter-quartz</code>）。</li>
<li>配置Quartz的<code>JobDetail</code>和<code>Trigger</code>，定义任务执行逻辑。</li>
</ul>
</li>
</ul>
<p>使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JobDetail <span class="title function_">sampleJobDetail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JobBuilder.newJob(SampleJob.class)</span><br><span class="line">                .withIdentity(<span class="string">&quot;sampleJob&quot;</span>)</span><br><span class="line">                .storeDurably()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Trigger <span class="title function_">sampleJobTrigger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SimpleScheduleBuilder</span> <span class="variable">scheduleBuilder</span> <span class="operator">=</span> SimpleScheduleBuilder.simpleSchedule()</span><br><span class="line">                .withIntervalInSeconds(<span class="number">10</span>)</span><br><span class="line">                .repeatForever();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .forJob(sampleJobDetail())</span><br><span class="line">                .withIdentity(<span class="string">&quot;sampleTrigger&quot;</span>)</span><br><span class="line">                .withSchedule(scheduleBuilder)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleJob</span> <span class="keyword">implements</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext context)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Quartz job executed - &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spring-TaskExecutor"><a href="#Spring-TaskExecutor" class="headerlink" title="Spring TaskExecutor"></a>Spring TaskExecutor</h2><ul>
<li>适用场景：需要异步执行的任务。</li>
<li>使用方法：<ol>
<li>配置<code>TaskExecutor</code>，定义线程池。</li>
<li>使用<code>@Async</code>注解标记需要异步执行的方法。</li>
</ol>
</li>
</ul>
<p>使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">5</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">10</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">25</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncTasks</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Async task executed - &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spring-Batch"><a href="#Spring-Batch" class="headerlink" title="Spring Batch"></a>Spring Batch</h2><ul>
<li>使用场景：批处理任务，适合处理大量数据。</li>
<li>使用方法：<ol>
<li>引入Spring Batch依赖。</li>
<li>配置<code>Job</code>、<code>Step</code>和<code>ItemReader</code>、<code>ItemProcessor</code>、<code>ItemWriter</code>等组件。</li>
</ol>
</li>
</ul>
<p>使用代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableBatchProcessing</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BatchConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JobBuilderFactory jobBuilderFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StepBuilderFactory stepBuilderFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Job <span class="title function_">sampleJob</span><span class="params">(Step sampleStep)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jobBuilderFactory.get(<span class="string">&quot;sampleJob&quot;</span>)</span><br><span class="line">                .start(sampleStep)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Step <span class="title function_">sampleStep</span><span class="params">(ItemReader&lt;String&gt; reader,</span></span><br><span class="line"><span class="params">                          ItemProcessor&lt;String, String&gt; processor,</span></span><br><span class="line"><span class="params">                          ItemWriter&lt;String&gt; writer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stepBuilderFactory.get(<span class="string">&quot;sampleStep&quot;</span>)</span><br><span class="line">                .&lt;String, String&gt;chunk(<span class="number">10</span>)</span><br><span class="line">                .reader(reader)</span><br><span class="line">                .processor(processor)</span><br><span class="line">                .writer(writer)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="第三方调度框架（如XXL-JOB、Elastic-Job）"><a href="#第三方调度框架（如XXL-JOB、Elastic-Job）" class="headerlink" title="第三方调度框架（如XXL-JOB、Elastic-Job）"></a>第三方调度框架（如XXL-JOB、Elastic-Job）</h2><ul>
<li>适用场景： 分布式环境下的定时任务调度。</li>
<li>使用方法：<ol>
<li>引入相应的依赖。</li>
<li>配置调度中心和执行器。</li>
<li>定义任务逻辑并注册到调度中心。</li>
</ol>
</li>
</ul>
<p><strong>示例</strong>（以XXL-JOB为例）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobSampleHandler</span> <span class="keyword">extends</span> <span class="title class_">IJobHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">execute</span><span class="params">(String param)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;XXL-JOB executed - &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="keyword">return</span> ReturnT.SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>简单任务</strong>：使用<code>@Scheduled</code>注解。</li>
<li><strong>复杂任务</strong>：使用Quartz框架。</li>
<li><strong>异步任务</strong>：使用<code>TaskExecutor</code>和<code>@Async</code>。</li>
<li><strong>批处理任务</strong>：使用Spring Batch。</li>
<li><strong>分布式任务</strong>：使用XXL-JOB或Elastic-Job等第三方框架。</li>
</ul>
<h2 id="关于XXLJOB和-Scheduled-分布式锁"><a href="#关于XXLJOB和-Scheduled-分布式锁" class="headerlink" title="关于XXLJOB和@Scheduled+分布式锁"></a>关于XXLJOB和@Scheduled+分布式锁</h2><h3 id="与XXL-JOB的对比"><a href="#与XXL-JOB的对比" class="headerlink" title="与XXL-JOB的对比"></a><strong>与XXL-JOB的对比</strong></h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left"><code>@Scheduled</code> + 分布式锁</th>
<th align="left">XXL-JOB</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>实现复杂度</strong></td>
<td align="left">较低</td>
<td align="left">较高</td>
</tr>
<tr>
<td align="left"><strong>分布式支持</strong></td>
<td align="left">需要自己实现锁机制</td>
<td align="left">内置分布式调度支持</td>
</tr>
<tr>
<td align="left"><strong>任务分片</strong></td>
<td align="left">不支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left"><strong>故障转移</strong></td>
<td align="left">需要自己实现</td>
<td align="left">内置支持</td>
</tr>
<tr>
<td align="left"><strong>动态调度</strong></td>
<td align="left">不支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left"><strong>任务监控</strong></td>
<td align="left">无</td>
<td align="left">提供可视化监控界面</td>
</tr>
<tr>
<td align="left"><strong>适用场景</strong></td>
<td align="left">小规模、简单的分布式任务</td>
<td align="left">大规模、复杂的分布式任务</td>
</tr>
</tbody></table>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>如果你只是需要一个简单的分布式任务调度，并且任务逻辑不复杂，使用<code>@Scheduled</code> + 分布式锁是一个可行的方案。</li>
<li>如果你的项目需要更强大的分布式调度功能（如任务分片、动态调度、故障转移、监控等），建议直接使用XXL-JOB或类似的分布式调度框架。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/22/RibbitMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/03/22/RibbitMQ/" class="post-title-link" itemprop="url">RabbitMQ</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-22 12:29:37" itemprop="dateCreated datePublished" datetime="2025-03-22T12:29:37+08:00">2025-03-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-23 10:41:45" itemprop="dateModified" datetime="2025-03-23T10:41:45+08:00">2025-03-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="day01"><a href="#day01" class="headerlink" title="day01"></a>day01</h2><h3 id="RabbitMQ是什么？使用在什么场景？"><a href="#RabbitMQ是什么？使用在什么场景？" class="headerlink" title="RabbitMQ是什么？使用在什么场景？"></a>RabbitMQ是什么？使用在什么场景？</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>Rabbit是一个消息中间件（Message Broker），用于在分布式系统中传递消息。它的核心功能是接受、存储和转发消息，确保消息能从生产者（Producer） 传递到消费者（Consumer）。</p>
<p><strong>核心概念</strong></p>
<ul>
<li><strong>Producer(生产者):</strong> 发送消息的程序。</li>
<li><strong>Consumer（消费者）：</strong> 接受消息的应用程序。</li>
<li><strong>Queue（队列）：</strong> 存储消息的缓冲区。</li>
<li><strong>Exchange（交换机）：</strong> 接受生产者发送的消息，并根据规则将消息路由到队列。</li>
<li><strong>Binding(绑定）：</strong> 定义交换机和队列之间的关系。</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><strong>可靠性：</strong> 支持消息持久化、确认机制和事务，确保消息不丢失。</li>
<li><strong>灵活性：</strong> 支持多种消息路由模式（如直连、主题、广播等）</li>
<li><strong>扩展性：</strong> 可通过集群实现高可用性和负载均衡。</li>
<li><strong>跨平台：</strong> 支持多种编程语言和操作系统。</li>
<li><strong>易用性：</strong> 提供友好的管理界面和丰富的客户端库。</li>
</ul>
<p><strong>主要应用场景</strong></p>
<h4 id="1-异步处理"><a href="#1-异步处理" class="headerlink" title="1. 异步处理"></a><strong>1. 异步处理</strong></h4><ul>
<li>场景描述：将耗时的任务（如发送邮件、生成报表）放入消息队列，有后台服务异步处理。</li>
<li>优点：提供系统的响应速度，避免用户等待。</li>
</ul>
<p>异步处理的本质：<br>异步处理的核心思想是将任务提交后立即返回，而不是等待任务完成。任务的执行有后台的消费者（Consumer）处理，生产者（Producer）不需要阻塞等待结果。</p>
<p>实现流程：</p>
<ul>
<li><strong>生产者发送消息：</strong><ul>
<li>生产者将任务数据（如Java对象）序列化成二进制数据（如字节流）。</li>
<li>生产者将消息发送到RabbitMQ的队列中，然后立即返回，继续执行其他操作。</li>
</ul>
</li>
<li><strong>RabbitMQ存储消息</strong>：<ul>
<li>RabbitMQ将消息存储在队列中，等待消息处理。</li>
</ul>
</li>
<li><strong>消费者处理消息：</strong><ul>
<li>消费者从队列中获取消息，并将其反序列化为原始数据</li>
<li>消费者在后台处理消息，执行具体的业务逻辑。</li>
</ul>
</li>
</ul>
<h5 id="秒杀异步处理"><a href="#秒杀异步处理" class="headerlink" title="秒杀异步处理"></a>秒杀异步处理</h5><p>问题：使用ssm+springboot+RabbitMQ+Redis完成一个秒杀逻辑的处理</p>
<p>思路：</p>
<ul>
<li>用户发起秒杀请求后，通过后端Redis的原子操作（如DECR）减少库存</li>
<li>成功则生成订单到RabbitMQ中。</li>
<li>RabbitMQ异步处理订单消息。</li>
</ul>
<p>实现：</p>
<p>配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br></pre></td></tr></table></figure>

<p>订单类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderMessage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId; <span class="comment">// 订单ID</span></span><br><span class="line">    <span class="keyword">private</span> String userId;  <span class="comment">// 用户ID</span></span><br><span class="line">    <span class="keyword">private</span> String productId; <span class="comment">// 商品ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> quantity;   <span class="comment">// 购买数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数、Getter 和 Setter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderMessage</span><span class="params">(String orderId, String userId, String productId, <span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">        <span class="built_in">this</span>.userId = userId;</span><br><span class="line">        <span class="built_in">this</span>.productId = productId;</span><br><span class="line">        <span class="built_in">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter 和 Setter 方法</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 定义订单队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">orderQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;order.queue&quot;</span>, <span class="literal">true</span>); <span class="comment">// true 表示持久化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写消费者代码，并监听RabbitMQ队列并处理订单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听订单队列</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;order.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleOrder</span><span class="params">(OrderMessage orderMessage)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received order: &quot;</span> + orderMessage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理订单逻辑</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 发送订单通知（如邮件、短信）</span></span><br><span class="line">            sendNotification(orderMessage);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 更新订单状态到数据库</span></span><br><span class="line">            updateOrderStatus(orderMessage);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Order processed: &quot;</span> + orderMessage.getOrderId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Failed to process order: &quot;</span> + orderMessage.getOrderId());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟发送通知</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendNotification</span><span class="params">(OrderMessage orderMessage)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sending notification for order: &quot;</span> + orderMessage.getOrderId());</span><br><span class="line">        <span class="comment">// 实际中可以调用邮件服务或短信服务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟更新订单状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateOrderStatus</span><span class="params">(OrderMessage orderMessage)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Updating order status for: &quot;</span> + orderMessage.getOrderId());</span><br><span class="line">        <span class="comment">// 实际中可以更新数据库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者代码，将订单发送到RabbitMQ中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送订单消息到 RabbitMQ</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendOrderMessage</span><span class="params">(OrderMessage orderMessage)</span> &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;order.queue&quot;</span>, orderMessage);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sent order: &quot;</span> + orderMessage.getOrderId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>秒杀逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeckillService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderProducer orderProducer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 秒杀逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">seckill</span><span class="params">(String userId, String productId)</span> &#123;</span><br><span class="line">        <span class="comment">// Redis 中存储商品库存的 key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stockKey</span> <span class="operator">=</span> <span class="string">&quot;seckill:stock:&quot;</span> + productId;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Redis 的 DECR 原子操作减少库存</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">stock</span> <span class="operator">=</span> redisTemplate.opsForValue().decrement(stockKey);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stock != <span class="literal">null</span> &amp;&amp; stock &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 库存充足，生成订单</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> generateOrderId();</span><br><span class="line">            <span class="type">OrderMessage</span> <span class="variable">orderMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderMessage</span>(orderId, userId, productId, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送订单消息到 RabbitMQ</span></span><br><span class="line">            orderProducer.sendOrderMessage(orderMessage);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 库存不足，恢复库存</span></span><br><span class="line">            redisTemplate.opsForValue().increment(stockKey);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成订单ID</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">generateOrderId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ORDER_&quot;</span> + System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-应用解耦"><a href="#2-应用解耦" class="headerlink" title="2. 应用解耦"></a><strong>2. 应用解耦</strong></h5><ul>
<li>场景描述： 在微服务架构中，不同服务器之间通过消息队列通信，而不是直接调用。</li>
<li>优点： 降低服务之间的耦合度，提高系统的可维护性和扩展性</li>
</ul>
<h5 id="3-流量消峰"><a href="#3-流量消峰" class="headerlink" title="3. 流量消峰"></a><strong>3. 流量消峰</strong></h5><ul>
<li>场景描述：在高并发场景下，将请求放入消息队列，由系统按照处理能力逐步消费。</li>
<li>优点： 避免系统因瞬时高流量而崩溃</li>
</ul>
<p><strong>注意：秒杀场景中使用RabbitMQ是一种典型的流量消峰手段。</strong></p>
<p>优势：</p>
<p>保护了核心服务；提高系统稳定性；提升了用户体验。</p>
<h5 id="4-日志收集"><a href="#4-日志收集" class="headerlink" title="4. 日志收集"></a><strong>4. 日志收集</strong></h5><ul>
<li>场景描述： 将分布式系统中的日志发送到消息队列，由专门的日志处理服务消费和存储。</li>
<li>优点：集中管理日志，便于分析和监控。</li>
</ul>
<p><strong>5. 任务分发</strong></p>
<ul>
<li>场景描述： 将任务分发给多个消费者并行处理。</li>
<li>优点： 提高任务处理效率。</li>
</ul>
<p><strong>6. 事件驱动</strong></p>
<ul>
<li>场景描述： 在事件驱动架构中，使用消息队列传递事件，触发相关服务执行操作。</li>
<li>优点： 实现松耦合的事件处理机制。</li>
</ul>
<h4 id="RabbitMQ的其他替代方案"><a href="#RabbitMQ的其他替代方案" class="headerlink" title="RabbitMQ的其他替代方案"></a>RabbitMQ的其他替代方案</h4><p>虽然RabbitMQ功能强大，但在某些场景下，可以选择其他消息队列：</p>
<ul>
<li>Kafka：适用于高吞吐量、实时数据流处理的场景。</li>
<li>ActiveMQ： 基于JM5（Java Message Service）的消息队列</li>
<li>RocketMQ： 阿里巴巴开源的分布式消息队列，适用于大规模的分布式系统。</li>
</ul>
<h3 id="Rabbit的基本架构和核心组件"><a href="#Rabbit的基本架构和核心组件" class="headerlink" title="Rabbit的基本架构和核心组件"></a>Rabbit的基本架构和核心组件</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/19/%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/03/19/%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B/" class="post-title-link" itemprop="url">要做的事</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-03-19 11:47:47 / 修改时间：11:49:32" itemprop="dateCreated datePublished" datetime="2025-03-19T11:47:47+08:00">2025-03-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="2025"><a href="#2025" class="headerlink" title="2025"></a>2025</h2><h3 id="3月"><a href="#3月" class="headerlink" title="3月"></a>3月</h3><h4 id="19日"><a href="#19日" class="headerlink" title="19日"></a>19日</h4>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/03/02/OJ%E5%88%A4%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/03/02/OJ%E5%88%A4%E9%A2%98/" class="post-title-link" itemprop="url">OJ判题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-03-02 15:16:19" itemprop="dateCreated datePublished" datetime="2025-03-02T15:16:19+08:00">2025-03-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-16 09:18:04" itemprop="dateModified" datetime="2025-03-16T09:18:04+08:00">2025-03-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="OJ判题系统"><a href="#OJ判题系统" class="headerlink" title="OJ判题系统"></a>OJ判题系统</h1><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>OJ &#x3D; Online Judge 在线判题评测系统</p>
<p>用户可以选择题目，在线做题，编写代码并提交代码；系统会对用户提交的代码，根据我们出题人设置答案。</p>
<p>来判断用户的提交结果是否正确</p>
<p>最大难点： <strong>判题逻辑</strong></p>
<p>介绍： 用于在线评测编程题目代码的系统，能够根据用户提交的代码、出题人预先设置的题目输入和输出用例。进行编译代码，运行代码，判断代码运行结果是否正确。</p>
<p>判断题系统作为一个开发API提供给大家，便于大家开发自己的OJ系统。</p>
<h3 id="OJ常用概念"><a href="#OJ常用概念" class="headerlink" title="OJ常用概念"></a>OJ常用概念</h3><p>ac表示你的题目通过，结果正确</p>
<p>题目限制；</p>
<p>题目介绍</p>
<p>题目输入</p>
<p>题目输出</p>
<p>题目输入用例</p>
<p>题目输出用例</p>
<p>普通测评：管理员设置题目的输入和输出用例，交给判题机；给判题机去执行用户的代码，给用户的代码喂输入用例，看用户程序的执行结果是否和标准答案输出一致。</p>
<p>特殊测评（SPJ）： 管理员设置题目的输入和输出，比如我输入1，用户的答案只要是 &gt;0 或 &lt;2 都正确；特判程序，不是通过对比用例文件是否一致这种死板的程序来检验，而是要专门根据这道题来写一个特殊的判断程序。程序接收题目的输入，标准输出用例，用户结果，特判程序根据这些值来比较是否正确。</p>
<p>交互测评： 让用户输入一个例子，就给出一个输出结果，交互比较灵活，没办法通过简单的，死板的输入输出文件来搞定。 </p>
<p>不能让用户随便引入包，随便遍历，暴力破译，需要使用正确的算法 &#x3D;》 安全性</p>
<p>判题过程是异步的 &#x3D;》 异步化</p>
<p>提交之后会生成一个提交记录，有运行的结果以及运行信息（时间限制，内存限制）</p>
<h2 id="做项目流程"><a href="#做项目流程" class="headerlink" title="做项目流程"></a>做项目流程</h2><ol>
<li>项目介绍，项目调研，需求分析</li>
<li>核心业务流程</li>
<li>项目要做的功能（功能模块）</li>
<li>技术选型（技术预演）</li>
<li>项目初始化</li>
<li>项目开发</li>
<li>测试</li>
<li>优化</li>
<li>代码提交、代码审查</li>
<li>产品验收</li>
<li>上线</li>
</ol>
<p>写文档，持续调研，持续记录总结</p>
<h2 id="现有系统调研"><a href="#现有系统调研" class="headerlink" title="现有系统调研"></a>现有系统调研</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol>
<li>题目浏览</li>
<li>在线做题，在线提交</li>
</ol>
<h3 id="项目扩展思路"><a href="#项目扩展思路" class="headerlink" title="项目扩展思路"></a>项目扩展思路</h3><ol>
<li>支持多种语言</li>
<li>远程评测</li>
<li>普通测评、特殊测评、交互测评、在线自测、子任务分组测评、文件IO</li>
<li>统计分析，用户判题记录</li>
<li>权限校验</li>
</ol>
<h2 id="实现核心"><a href="#实现核心" class="headerlink" title="实现核心"></a>实现核心</h2><ol>
<li><p>权限校验：谁能提代码，谁不能提代码</p>
</li>
<li><p>代码沙箱（安全沙箱）：用户代码藏毒，写个木马，修改系统权限</p>
<p>沙箱：用户的代码不能影响到沙箱之外的系统运行。</p>
<p>资源分配： 系统内存就2个G，用户疯狂占用资源占满内存。所以要限制占用资源。</p>
</li>
<li><p>判题规则：题目用例的比对，结果调用</p>
</li>
<li><p>任务调度：服务器资源有限，用户要排队，按照顺序去执行判题，而不是拒绝。</p>
</li>
</ol>
<h2 id="核心业务流程"><a href="#核心业务流程" class="headerlink" title="核心业务流程"></a>核心业务流程</h2><img src="https://pic1.imgdb.cn/item/67d544af88c538a9b5bec3b8.png" alt="image.png">

<p>时序图：</p>
<img src="https://pic1.imgdb.cn/item/67d546a388c538a9b5bec434.png" alt="image.png">

<img src="https://pic1.imgdb.cn/item/67d546e188c538a9b5bec440.png" alt="image.png">

<p>判题服务：获取题目信息，预计的输入输出结果，返回给主业务后端：用户的答案是否正确</p>
<p>代码沙箱：只负责运行代码，给出结果，不管什么结果是正确的</p>
<p><strong>实现了解耦</strong></p>
<h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><ol>
<li>题目模块<ul>
<li>创建题目（管理员）</li>
<li>删除题目（管理员）</li>
<li>修改题目（管理员）</li>
<li>搜索题目（用户）</li>
<li>在线做题</li>
<li>提价代码</li>
</ul>
</li>
<li>用户模块：<ul>
<li>注册</li>
<li>登录</li>
</ul>
</li>
<li>判题模块<ul>
<li>提交判断（结果是否正确或错误）</li>
<li>错误处理（内存溢出，安全性，超时）</li>
<li>自主实现（代码沙箱，安全沙箱）</li>
<li>开放接口（提供一个独立的新服务）</li>
</ul>
</li>
</ol>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>前后：</p>
<p>Vue3、项目模版 Arco Design，在线代码编辑器，在线文档浏览</p>
<p>Java进程控制，Java安全管理器、部分JVM知识点</p>
<p>虚拟机（云服务）、Docker（代码沙箱实现）</p>
<p>Spring Cloud微服务（改造成微服务）、消息队列</p>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><img src="https://pic1.imgdb.cn/item/67d54a7888c538a9b5bec4ff.png" alt="image.png">

<h2 id="OJ系统实现方案"><a href="#OJ系统实现方案" class="headerlink" title="OJ系统实现方案"></a>OJ系统实现方案</h2><p>开发原则： 能用别人现成的，就不要自己写</p>
<p>1）用现成的OJ系统，比如judge0（github）</p>
<p>2） 用现成的判题API，现成的代码沙箱。</p>
<p>3） 自主开发</p>
<p>4） 把AI来当做代码沙箱。</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/27/mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/27/mybatis/" class="post-title-link" itemprop="url">mybatis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-27 19:17:21" itemprop="dateCreated datePublished" datetime="2025-02-27T19:17:21+08:00">2025-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-20 10:36:07" itemprop="dateModified" datetime="2025-03-20T10:36:07+08:00">2025-03-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h2><h3 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h3><p>ORM（Object Relational Mapping，对象关系映射）是一种编程技术，用于在面对对象编程语言时，实现 <strong>对象</strong> 与 <strong>关系数据库数据</strong> 之间的映。它允许开发者通过操作对象来间接操作数据库，而无需直接编写SQL语句。</p>
<h3 id="ORM的核心功能"><a href="#ORM的核心功能" class="headerlink" title="ORM的核心功能"></a>ORM的核心功能</h3><p><strong>1. 表与类的映射</strong></p>
<ul>
<li>数据库中的每张表对应程序中的一个类。</li>
<li>表中的每列对应类的一个属性。</li>
<li>表中的每一行对应类的一个实例。</li>
</ul>
<p><strong>2. CRUD操作</strong></p>
<ul>
<li>插入数据</li>
<li>查询数据</li>
<li>更新数据</li>
<li>删除数据</li>
</ul>
<p><strong>3. 关系映射</strong></p>
<ul>
<li>处理表与表之间的关系</li>
<li>例如，用户表和订单表之间的一对多关系可以通过ORM框架自动映射</li>
</ul>
<p><strong>4. 事务管理</strong></p>
<ul>
<li>提供了事务支持，确保了数据的一致性和完整性。</li>
</ul>
<p><strong>5. 数据库迁移</strong></p>
<ul>
<li>支持数据库的版本控制，方便升级和回滚。</li>
</ul>
<h3 id="常见的ORM框架"><a href="#常见的ORM框架" class="headerlink" title="常见的ORM框架"></a>常见的ORM框架</h3><p>Java：</p>
<ul>
<li>Hibernate：功能强大，支持多种数据库，广泛用于企业级应用。</li>
<li>MyBatis：更接近SQL，灵活性高，适合复杂查询。</li>
</ul>
<h2 id="Mybatis-执行流程"><a href="#Mybatis-执行流程" class="headerlink" title="Mybatis 执行流程"></a>Mybatis 执行流程</h2><p>mybatis通常是通过SqlSession获取Mapper，通过Mapper来执行查找操作的。</p>
<p>以下是最外层的执行逻辑</p>
<img src="https://pic1.imgdb.cn/item/67c2f887d0e0a243d4092336.png" alt="image.png">

<p>通过读取mybatis配置信息，获取sqlSession来执行对应的方法。</p>
<p>这里是getSqlSession（）方法的里面</p>
<p>通过读取配置信息，获取SqlSessionFactoryBuilder这个类，通过这个类来获取对应的SqlSessionFactory</p>
<img src="https://pic1.imgdb.cn/item/67c2f902d0e0a243d4092370.png" alt="image.png">

<p>看到底下的getSqlSession了吗？可以通过这个方法来让SqlSessionFactory获取SqlSession</p>
<p>之后获取SqlSession后，就可以通过SqlSession来调用对应的方法，查询数据了</p>
<img src="https://pic1.imgdb.cn/item/67c2f995d0e0a243d40923de.png" alt="image.png">

<p>注意：通常情况下不会直接调用查找的方法，而且获取Mapper，通过Mapper来调用需要的方法。（通过Mapper来代理）</p>
<p>当sqlSession执行查找方法时：</p>
<p>Mybatis会根据传入的SQL映射语句的ID来寻找对应的SQL语句执行。对于通过 <code>namespace</code> 和 <code>id</code> 进行定位，MyBatis会将映射文件解析成一个 <code>MapperStatement</code> 对象</p>
<img src="https://pic1.imgdb.cn/item/67c2fbccd0e0a243d4092536.png" alt="image.png">

<blockquote>
<p><strong>MapperStatement</strong> ，里面保存了 SQL语句、参数类型、返回类型信息。</p>
</blockquote>
<img src="https://pic1.imgdb.cn/item/67c2fc95d0e0a243d4092591.png" alt="image.png">



<p>在SQL执行之前，MyBatis会根据映射文件中配置的<code>parameterType</code> 类型，将传入的参数封装成适当的对象。<strong>（StatementHandler，处理Sql语句的具体执行，包括SQL的预处理，绑定参数，执行查询等）</strong></p>
<p>执行SQL语句</p>
<p>并将查询到的结构通过映射文件中配置的 <code>resultType</code> 类型返回，并将查询类型转换成Java对象。**(通过调用ResultSetHandler， 处理得到的结果集。)**</p>
<p>事务管理：MyBatis的事务管理通过SqlSession来处理，SqlSession提供了事务的提交和回滚方式，当调用<code>SqlSession.commit()</code>时，SQL执行的结果会被提交到数据库；若发生异常，调用<code>SqlSession.rollback()</code>事务会回滚。</p>
<p>关闭：<code>close()</code></p>
<h3 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h3><img src="https://pic1.imgdb.cn/item/67c30078d0e0a243d40927ef.png" alt="image.png">

<h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><ul>
<li><strong>SqlSessionFactory：</strong> 负责创建<code>sqlSession</code>对象</li>
<li><strong>SqlSession：</strong>负责执行SQL操作，管理事务</li>
<li><strong>Configuration：</strong> 保存MyBatis的全员配置信息，维护映射器，插件，类型处理器等</li>
<li><strong>MappedStatement：</strong> 表示映射的SQL语句及其相关信息，如SQL，参数类型，返回类型等</li>
<li><strong>Executor：</strong> 用于执行SQL语句的组件，根据<code>MapperStatement</code> 中的SQL配置信息，通过数据库连接执行SQL语句，提供缓存支持。</li>
<li><strong>StatementHandler:</strong> <code>StatementHandler</code>负责处理SQL语句的具体执行，包括SQL的预处理，绑定参数，执行查询等</li>
<li><strong>ResultSetHandler：</strong> <code>ResultSetHandler</code> 负责处理查询结果的映射，将结果集转换成Java对象。</li>
</ul>
<blockquote>
<p>注意： 获取MapperStatement在创建SqlSession之前</p>
<p>在执行SQL之前的MapperStatement是获取，不是创建。</p>
</blockquote>
<p>之后会创建PrepareStatement（在JDBC中）</p>
<p><strong>创建 PreparedStatement</strong>：</p>
<ul>
<li>MyBatis 通过 JDBC 的 <code>Connection</code> 对象创建 <code>PreparedStatement</code>。</li>
<li>如果 SQL 中使用的是 <code>#&#123;&#125;</code>，MyBatis 会将 <code>#&#123;&#125;</code> 替换为 <code>?</code>，并通过 <code>PreparedStatement</code> 设置参数。</li>
</ul>
<p><strong>执行 SQL</strong>：</p>
<ul>
<li>调用 <code>PreparedStatement.execute()</code> 执行 SQL。</li>
<li>如果是查询操作，MyBatis 会将结果映射为 Java 对象。</li>
</ul>
<h2 id="关于MyBatis的缓存"><a href="#关于MyBatis的缓存" class="headerlink" title="关于MyBatis的缓存"></a>关于MyBatis的缓存</h2><p>Mybatis中有两类缓存，分别是一级缓存和二级缓存</p>
<p><strong>一级缓存（SqlSession）</strong>： 仅在同一个<code>sqlsession</code> 中生效，基于命名空间，sql语句和参数作为唯一标识</p>
<ul>
<li>默认开启，生命周期和sqlsession一致</li>
<li>当执行 <code>commit</code> <code>rollback</code> 或手动清理时会清空</li>
</ul>
<p><strong>二级缓存（Mapper级别）：</strong> 夸Sqlsession共享缓存，基于Mapper缓存。</p>
<ul>
<li>需要手动配置开启</li>
<li>生命周期和 SqlSessionFactory一致</li>
<li>数据的更新、插入和删除会使相关的缓存失效</li>
<li>支持定制化存储。</li>
</ul>
<blockquote>
<p><strong>注意: 开启缓存后，会先去二级缓存中查找，之后再去一级</strong></p>
</blockquote>
<p><strong>两个缓存都是，基于PerpetualCache的HashMap本地缓存</strong></p>
<h2 id="MyBatis和Hibernate有哪些不同？"><a href="#MyBatis和Hibernate有哪些不同？" class="headerlink" title="MyBatis和Hibernate有哪些不同？"></a>MyBatis和Hibernate有哪些不同？</h2><ul>
<li>ORM模型<ul>
<li>Hibernate 是全自动ORM框架，会自动生成SQL并管理实体对象的生命周期，<strong>强调对象模型</strong></li>
<li>MyBatis是半自动ORM工具，需要开发者手写SQL。<strong>强调SQL控制</strong></li>
</ul>
</li>
<li>灵活性<ul>
<li>Mybatis提供了更灵活的SQL定制能力</li>
<li>Hibernate 更注重对象和数据库的映射，适合复杂的实体关系模型</li>
</ul>
</li>
<li>性能<ul>
<li>在复杂查询场景下，Mybatis的性能通常优于Hibernate，因为SQl可控。</li>
</ul>
</li>
</ul>
<img src="https://pic1.imgdb.cn/item/67c31079d0e0a243d4093439.png" alt="image.png">

<h2 id="关于-和"><a href="#关于-和" class="headerlink" title="关于#{} 和 ${}"></a>关于#{} 和 ${}</h2><p>​	在mybatis中， <code>#&#123;&#125;</code> 和 <code>\$&#123;&#125;</code> 都是用来处理SQL语句中的占位符，但他们的作用域和使用功能场景有显著的不同</p>
<p> <code>#&#123;&#125;</code>（PreparedStatement 占位符）： 传入SQL查询语句参数，它会将传入的参数进行类型处理，并使用功能PreparedStatement进行SQL绑定，从而避免SQL注入攻击。**#{} 会将数据作为参数传递给数据库，而不是直接拼接到SQL中**</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>预编译处理</strong>：<ul>
<li>MyBatis 会将 <code>#&#123;&#125;</code> 替换为 <code>?</code>，并使用 <code>PreparedStatement</code> 进行参数绑定。</li>
<li>参数值会被安全地传递给数据库，防止 SQL 注入。</li>
</ul>
</li>
<li><strong>自动类型转换</strong>：<ul>
<li>MyBatis 会根据参数的类型自动进行 JDBC 类型转换（如 String 转 VARCHAR）。</li>
</ul>
</li>
<li><strong>安全性高</strong>：<ul>
<li>由于使用预编译机制，<code>#&#123;&#125;</code> 可以有效防止 SQL 注入攻击。</li>
</ul>
</li>
</ul>
<p><code>\$&#123;&#125;</code> (字符拼接) ： 用于 <strong>直接将参数拼接到SQL中</strong>，可能会导致sql注入问题。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li><strong>直接替换</strong>：<ul>
<li>MyBatis 会将 <code>$&#123;&#125;</code> 中的内容直接替换为参数值，生成完整的 SQL 语句。</li>
<li>不会使用 <code>PreparedStatement</code>，而是直接拼接 SQL 字符串。</li>
</ul>
</li>
<li><strong>无类型转换</strong>：<ul>
<li>参数值会直接以字符串形式拼接到 SQL 中，不会进行 JDBC 类型转换。</li>
</ul>
</li>
<li><strong>安全性低</strong>：<ul>
<li>如果参数值来自用户输入，可能会导致 SQL 注入攻击。</li>
</ul>
</li>
</ul>
<img src="https://pic1.imgdb.cn/item/67c3125dd0e0a243d4093517.png" alt="image.png">

<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>**<code>#&#123;&#125;</code>**：<ul>
<li>安全、预编译，适合传递动态参数值。</li>
<li>推荐在大多数场景中使用。</li>
</ul>
</li>
<li>**<code>$&#123;&#125;</code>**：<ul>
<li>直接替换，适合动态表名、列名等非用户输入部分。</li>
<li>使用时需谨慎，避免 <strong>SQL 注入风险</strong>。</li>
</ul>
</li>
</ul>
<h4 id="关于-的具体操作"><a href="#关于-的具体操作" class="headerlink" title="关于#{} 的具体操作"></a>关于#{} 的具体操作</h4><p><strong>1. 预编译占位符</strong></p>
<p>MyBatis 会将 <code>#&#123;&#125;</code> 替换为 <code>?</code>，这是一个 JDBC 的预编译占位符。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> #&#123;userId&#125;</span><br></pre></td></tr></table></figure>

<p>会被转换为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>

<p><strong>2. 参数传递</strong></p>
<p>MyBatis 会将 <code>#&#123;&#125;</code> 中的参数值通过 <code>PreparedStatement</code> 的 <code>setXxx()</code> 方法传递给数据库。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement ps <span class="operator">=</span> connection.prepareStatement(&quot;SELECT * FROM user WHERE id = ?&quot;);</span><br><span class="line">ps.setInt(<span class="number">1</span>, userId); # 第一个参数表示第几个占位符</span><br></pre></td></tr></table></figure>

<p>这种方式可以防止 SQL 注入，因为参数值不会被直接拼接到 SQL 语句中。</p>
<h2 id="xml和dao接口原理"><a href="#xml和dao接口原理" class="headerlink" title="xml和dao接口原理"></a>xml和dao接口原理</h2><p>核心原理是 <strong>JDBC的能力</strong> 和 <strong>动态代理</strong> ，通过解析XML映射文件和动态生成“DAO接口实现类来完成SQL</p>
<ol>
<li><strong>加载配置和Mapper</strong><ul>
<li>mybatis启动，读取配置文件mapper.xml ,</li>
<li>xml信息被解析成 MapperStatement，包含SQL，配置信息，参数规则映射结果映射</li>
</ul>
</li>
<li><strong>动态代理DAO接口：</strong><ul>
<li>Mybatis为每个DAO生成一个动态代理类（MapperProxy），拦截接口方法调用。</li>
<li>动态代理的核心是根据方法名和参数匹配到对应的<code>MapperStatement</code> ,然后调用功能JDBC</li>
</ul>
</li>
<li><strong>通过JDBC来执行SQL</strong><ul>
<li>mybatis的SqlSession是对JDBC的一个封装，它的核心是使用PreparedStatement来完成SQL的执行</li>
<li>解析sql时，对#{}进行？处理，并通过prepareStatement.setXXX来设置参数</li>
<li>JDBC执行sql，并获取ResultSet</li>
</ul>
</li>
<li><strong>获取结果映射集</strong><ul>
<li>JDBC的查询结果（ResultSet）会被Mybatis的<code>ResultMap</code> 或<code>ResultType</code> 映射为DAO接口方法的返回类型（如POJO，Map或list）</li>
</ul>
</li>
</ol>
<h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>是mybatis根据不同的条件，需求动态生成SQL语句的一种机制。主要目的：提高SQL的灵活性和复用性，在复杂的查询语句或更新场景中，根据参数动态构建不同SQL语句</p>
<p>原理：</p>
<p>动态SQL基于XML映射文件中定义的SQL判断和标签，这些标签被解析后转化成SQL被执行。</p>
<p>解析流程：</p>
<ul>
<li>解析动态SQL：在映射文件加载时，mybatis会解析动态sql</li>
<li>参数绑定：当执行sql语句时，mybatis会根据传入的参数绑定具体的值</li>
<li>生成最终的sql</li>
<li>执行sql，并返回结果集</li>
</ul>
<h2 id="是否支持懒加载"><a href="#是否支持懒加载" class="headerlink" title="是否支持懒加载"></a>是否支持懒加载</h2><p>支持</p>
<h2 id="关于MyBatsi如何实现数据库类型转化的？"><a href="#关于MyBatsi如何实现数据库类型转化的？" class="headerlink" title="关于MyBatsi如何实现数据库类型转化的？"></a>关于MyBatsi如何实现数据库类型转化的？</h2><p>主要依赖于 <strong>TypeHandler</strong> 机制</p>
<p>作用：</p>
<ul>
<li>将java对象转化为JDBC类型，用于SQL参数</li>
<li>将JDBC类型转换为Java对象，用于查询结果集</li>
</ul>
<p>具体操作流程：</p>
<ul>
<li>Mybatis在加载映射文件时，根据字段类型和java类型确定使用TypeHandler</li>
<li>在执行SQL时，<code>Parameterhandler</code> 会使用TypeHandler将Java参数转化为JDBC类型</li>
<li>在解析结果集时，<code>ResultHandler</code>会使用 TypeHandler将JDBC对象转换成Java对象。</li>
</ul>
<h2 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis-Plus"></a>Mybatis-Plus</h2><p>是对Mybatis的增强框架，它对Mybatis进行了二次封装，只做增强不做改变。通过提供一系列API方法和代码生成器，使重复的CRUD操作更加简单，无需手动编写SQL，从而大幅度提高了开发效率。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/24/springboot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/24/springboot/" class="post-title-link" itemprop="url">springboot</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-24 15:21:43" itemprop="dateCreated datePublished" datetime="2025-02-24T15:21:43+08:00">2025-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-26 22:05:55" itemprop="dateModified" datetime="2025-02-26T22:05:55+08:00">2025-02-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><img src="https://pic1.imgdb.cn/item/67bc74e9d0e0a243d403add7.png" alt="image.png">

<p>首先需要@SpringBootApplication这个注解。</p>
<p>通过SpringApplication.run来启动。</p>
<p>阶段</p>
<p><img src="https://pic1.imgdb.cn/item/67bc7543d0e0a243d403ae21.png"></p>
<p>2</p>
<p><img src="https://pic1.imgdb.cn/item/67bc75f0d0e0a243d403aeec.png"></p>
<h2 id="自己写的"><a href="#自己写的" class="headerlink" title="自己写的"></a>自己写的</h2><p>整体结构：</p>
<p><img src="https://pic1.imgdb.cn/item/67bd2b64d0e0a243d4043f9d.png"></p>
<p>首先看启动函数</p>
<p><img src="https://pic1.imgdb.cn/item/67bd2a29d0e0a243d4043f07.png"></p>
<p>点进去之后是这个：</p>
<p><img src="https://pic1.imgdb.cn/item/67bd2a4cd0e0a243d4043f1c.png"></p>
<p>这个时候就要分成两部分了，一个是 <code>new SpringApplication(primarySources)</code> 另一个是 <code>.run()</code></p>
<h4 id="new-springApplication"><a href="#new-springApplication" class="headerlink" title="new springApplication()"></a>new springApplication()</h4><p>在这个构造器里面，通常是用来初始化的。</p>
<p>具体构造是：</p>
<p><img src="https://pic1.imgdb.cn/item/67bd2b26d0e0a243d4043f85.png"></p>
<p>这里我把代码复制下来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">        <span class="built_in">this</span>.bannerMode = Mode.CONSOLE;</span><br><span class="line">        <span class="built_in">this</span>.logStartupInfo = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.addCommandLineProperties = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.addConversionService = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.headless = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.registerShutdownHook = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">this</span>.additionalProfiles = Collections.emptySet();</span><br><span class="line">        <span class="built_in">this</span>.isCustomEnvironment = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.lazyInitialization = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">this</span>.applicationContextFactory = ApplicationContextFactory.DEFAULT;</span><br><span class="line">        <span class="built_in">this</span>.applicationStartup = ApplicationStartup.DEFAULT;</span><br><span class="line">        <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">        Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>(Arrays.asList(primarySources)); <span class="comment">// 将启动类放入primarySources（初级来源）</span></span><br><span class="line">        <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath(); <span class="comment">// 推算当前web的类型</span></span><br><span class="line">        <span class="built_in">this</span>.bootstrapRegistryInitializers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="built_in">this</span>.getSpringFactoriesInstances(BootstrapRegistryInitializer.class)); </span><br><span class="line">        <span class="built_in">this</span>.setInitializers(<span class="built_in">this</span>.getSpringFactoriesInstances(ApplicationContextInitializer.class));<span class="comment">// 读取初始化器</span></span><br><span class="line">        <span class="built_in">this</span>.setListeners(<span class="built_in">this</span>.getSpringFactoriesInstances(ApplicationListener.class)); <span class="comment">//读取监听器</span></span><br><span class="line">        <span class="built_in">this</span>.mainApplicationClass = <span class="built_in">this</span>.deduceMainApplicationClass(); <span class="comment">// 将main方法所在的类放入mainApplicationClass。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总结：整个过程就是初始化阶段，扩展，和保存main方法。</p>
<p>可扩展接口：</p>
<ul>
<li>ApplicationContextInitializers； 初始化器</li>
<li>ApplicationListener； 监听器</li>
</ul>
<h4 id="运行run（）"><a href="#运行run（）" class="headerlink" title="运行run（）"></a>运行run（）</h4><p>运行run方法的话会进入这个函数</p>
<p><img src="https://pic1.imgdb.cn/item/67bd2d7dd0e0a243d40440e5.png"></p>
<p>这里把run()方法的实现复制下来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.nanoTime(); <span class="comment">// 记录启动开始时间</span></span><br><span class="line">    <span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> <span class="built_in">this</span>.createBootstrapContext(); <span class="comment">// 创建引导上下文（BootstrapContext）</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 初始化Spring应用上下文</span></span><br><span class="line">    <span class="built_in">this</span>.configureHeadlessProperty(); <span class="comment">// 配置Headless模式（无图形界面模式）</span></span><br><span class="line">    <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> <span class="built_in">this</span>.getRunListeners(args); <span class="comment">// 获取SpringApplicationRunListeners，用于发布启动事件</span></span><br><span class="line">    listeners.starting(bootstrapContext, <span class="built_in">this</span>.mainApplicationClass); <span class="comment">// 发布应用启动事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args); <span class="comment">// 封装命令行参数</span></span><br><span class="line">        <span class="comment">// 准备环境（读取配置文件、环境变量等），并发布环境准备事件</span></span><br><span class="line">        <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> <span class="built_in">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);</span><br><span class="line">        <span class="built_in">this</span>.configureIgnoreBeanInfo(environment); <span class="comment">// 配置需要忽略的Bean信息</span></span><br><span class="line">        <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> <span class="built_in">this</span>.printBanner(environment); <span class="comment">// 打印Banner（启动时的Logo）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Spring应用上下文（AnnotationConfigApplicationContext或AnnotationConfigServletWebServerApplicationContext）</span></span><br><span class="line">        context = <span class="built_in">this</span>.createApplicationContext();</span><br><span class="line">        context.setApplicationStartup(<span class="built_in">this</span>.applicationStartup); <span class="comment">// 设置应用启动指标（用于性能监控）</span></span><br><span class="line">        <span class="comment">// 准备应用上下文：设置环境、注册BeanDefinition、发布上下文准备事件</span></span><br><span class="line">        <span class="built_in">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="built_in">this</span>.refreshContext(context); <span class="comment">// 刷新上下文（加载IOC容器，初始化Bean）</span></span><br><span class="line">        <span class="built_in">this</span>.afterRefresh(context, applicationArguments); <span class="comment">// 刷新后的扩展点（可用于自定义逻辑）</span></span><br><span class="line">        <span class="type">Duration</span> <span class="variable">timeTakenToStartup</span> <span class="operator">=</span> Duration.ofNanos(System.nanoTime() - startTime); <span class="comment">// 计算启动耗时</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="comment">// 打印启动信息（如启动时间、应用名称等）</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">StartupInfoLogger</span>(<span class="built_in">this</span>.mainApplicationClass)).logStarted(<span class="built_in">this</span>.getApplicationLog(), timeTakenToStartup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listeners.started(context, timeTakenToStartup); <span class="comment">// 发布应用启动完成事件</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">this</span>.callRunners(context, applicationArguments); <span class="comment">// 调用ApplicationRunner和CommandLineRunner</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var12) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handleRunFailure(context, var12, listeners); <span class="comment">// 处理启动失败</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var12);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Duration</span> <span class="variable">timeTakenToReady</span> <span class="operator">=</span> Duration.ofNanos(System.nanoTime() - startTime); <span class="comment">// 计算应用就绪耗时</span></span><br><span class="line">        listeners.ready(context, timeTakenToReady); <span class="comment">// 发布应用就绪事件</span></span><br><span class="line">        <span class="keyword">return</span> context; <span class="comment">// 返回初始化完成的Spring应用上下文</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var11) &#123;</span><br><span class="line">        <span class="built_in">this</span>.handleRunFailure(context, var11, (SpringApplicationRunListeners)<span class="literal">null</span>); <span class="comment">// 处理就绪失败</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(var11);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="关于-this-refreshContext-context"><a href="#关于-this-refreshContext-context" class="headerlink" title="关于 this.refreshContext(context)"></a>关于 this.refreshContext(context)</h5><p>点进去的话是这个：</p>
<p><img src="https://pic1.imgdb.cn/item/67bd31e1d0e0a243d40442a4.png"></p>
<p>最主要的还是底下的 <code>this.refresh(context)</code></p>
<p><img src="https://pic1.imgdb.cn/item/67bd3225d0e0a243d40442bd.png"></p>
<p>这里面就是加载IOC容器，类似Spring的加载</p>
<p><img src="https://pic1.imgdb.cn/item/67bd330cd0e0a243d404430a.png"></p>
<p>在这里会解析自动配置类，是在SpringIOC容器中加载。</p>
<p><img src="https://pic1.imgdb.cn/item/67bd3456d0e0a243d40443a5.png"></p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250225110644414.png" alt="image-20250225110644414"></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><strong>简化配置</strong>： SpringBoot通过自动配置（<code>@EnableAutoconfig</code>），根据项目中的类路径依赖，环境变量等自动为应用配置适当的Spring模块，避免了大量的XML</li>
<li><strong>内置服务器</strong>： Springboot内置了 Tomcat，Jetty, Undertow等服务器，应用程序可以直接通过 java -jar 启动，而不需要部署到外部的web服务器中。</li>
<li><strong>快速开发</strong>： SpringBoot提供了开箱即用的项目结构，默认资源配置和依赖管理，支持快速原型开发。它还提供了许多常用的开发工具</li>
<li><strong>独立运行</strong>: Springboot应用打包成一个独立的jar或war包，可以通过命令直接运行，简化了部署过程。</li>
</ul>
<h2 id="核心注解"><a href="#核心注解" class="headerlink" title="核心注解"></a>核心注解</h2><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>@SpringBootApplication 是Spring boot的核心注解，它是一下三个注解的组合：</p>
<ul>
<li>@configuration: 表示该类是Spring配置类</li>
<li>@EnableAutoConfigruation: 启用Springboot的自动配置功能。</li>
<li>@ComponenScan: 自动扫描当前包及其子类包带有的Spring注解类</li>
</ul>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>@EnableAutoConfiguration 是SpringBoot的自动配置核心注解，它会根据类路径中的依赖自动配置Spring应用中的各种组件。</p>
<p>例子：</p>
<p>如果应用中引入了 <code>spring-boot-starter-web</code> 依赖，SpringBoot会自动为应用配置嵌入Tomcat服务器，MVC框架等。</p>
<h2 id="Spring-Boot-的启动器（starters）"><a href="#Spring-Boot-的启动器（starters）" class="headerlink" title="Spring Boot 的启动器（starters）"></a>Spring Boot 的启动器（starters）</h2><p>Spring boot提供了一系列 <strong>Starters(启动器)</strong> ，这些启动器是预定的依赖包集合，涵盖了常用的Spring和第三方库。通过引入一个简单的启动器依赖，开发者可以快速整合需要的功能。</p>
<p>常用的starter</p>
<ul>
<li><code>spring-boot-starter-web</code> : 用于构建Web应用，包含了springMVC和嵌入式Tomcat。</li>
<li><code>spring-boot-starter-data-jpa</code>: 用于集成Spring Data JPA 和 Hibernate, 简化数据库访问</li>
<li><code>spring-boot-starter-security</code>:  用于集成Spring Security，实现身份验证和授权。</li>
<li><code>spring-boot-starter-thymeleaf</code>: 集成Thymeleaf模版引擎，适用于MVC模式下的视图层渲染。</li>
</ul>
<h2 id="Spring-Boot的自动配置"><a href="#Spring-Boot的自动配置" class="headerlink" title="Spring Boot的自动配置"></a>Spring Boot的自动配置</h2><p>SpringBoot自动配置机制依赖于 <code>spring-boot-autoconfigure</code> 模块，他会根据classpath下的 **META&#x2F;INF&#x2F;spring.factories **配置相关的Bean服务。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>Springboot自动配置的核心原理是 <code>EnableAutoConfiguration</code> 注解，根据classpath下的 **META&#x2F;INF&#x2F;spring.factories **配置相关的Bean服务。</p>
<p>这个注解包含了<code>@Import(AutoConfigurationSelector.class)</code>这个注解，通过这个注解</p>
<p>它根据项目中的依赖和 <code>application.properties</code> 和<code>application.yml</code>文件中的配置，判断需要加载哪些Bean，通过条件注解（如 @ConditionalOnClass、 @ConditionalOnMissingBean等),SpringBoot可以有选择的加载相关配置。</p>
<h2 id="SpringBoot支持的嵌入web容器"><a href="#SpringBoot支持的嵌入web容器" class="headerlink" title="SpringBoot支持的嵌入web容器"></a>SpringBoot支持的嵌入web容器</h2><ul>
<li>Tomcat(默认)<ul>
<li>Tomcat是SpringBoot默认的嵌入式Web容器。Tomcat是一种轻量级，广泛使用的Servlet容器，Spring会自动将Tomcat内嵌到应用程序中。</li>
</ul>
</li>
<li>Jetty：<ul>
<li>Jetty是一个高效的Web服务器和Servlet容器，通常用于嵌入式系统或资源占用较敏感的环境。它比Tomcat更加轻量，并且适合长连接应用（如WebSocket，Comet)</li>
</ul>
</li>
<li>Undertow:<ul>
<li>Undertow 是一个轻量级的高性能Web服务器和Servlet服务器，适合用于处理高并发的Http请求，它支持异步IO和HTTP2，是一种灵活性能出色的选择。</li>
</ul>
</li>
<li>Netty（仅限WebFlux)<ul>
<li>对于使用SpringWebFlux的响应式Web应用，SpringBoot支持Netty作为嵌入式Web容器，Netty是一个非阻塞的异步事件驱动框架，非常适合响应式编程模型和高并发应用。</li>
</ul>
</li>
</ul>
<h2 id="如何在Spring中定义和读取定义配置？"><a href="#如何在Spring中定义和读取定义配置？" class="headerlink" title="如何在Spring中定义和读取定义配置？"></a>如何在Spring中定义和读取定义配置？</h2><p><strong>1. @Value</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;my.custom.property&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String myProperty;</span><br></pre></td></tr></table></figure>

<p><strong>2. @ConfigurationProperties</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my.custom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3. Environment接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> env.getProperty(<span class="string">&quot;my.custom.property&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Boot-打成的jar-和普通的-jar有什么区别？"><a href="#Spring-Boot-打成的jar-和普通的-jar有什么区别？" class="headerlink" title="Spring Boot 打成的jar 和普通的 jar有什么区别？"></a>Spring Boot 打成的jar 和普通的 jar有什么区别？</h2><p>Spring boot 打成的jar包不仅包含了应用程序的源代码和依赖库，还包含了程序运行需要的配置，脚本和服务依赖（内嵌的服务器），<strong>可以直接部署运行</strong></p>
<p>普通jar包，只有源码和依赖，通常需要外部的服务器或容器来运行。</p>
<h4 id="如何打包成-Spring-Boot-jar包"><a href="#如何打包成-Spring-Boot-jar包" class="headerlink" title="如何打包成 Spring Boot jar包"></a>如何打包成 Spring Boot jar包</h4><p>通常可以通过这个插件来进行配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意： 主要是springboot内嵌了服务器（tomcat），所以打包的时候会带上，所以只需要有个jdk就可以运行这个jar包了。而普通的需要启动tomcat才能运行这个jar包。</p>
<h2 id="连接数和处理请求"><a href="#连接数和处理请求" class="headerlink" title="连接数和处理请求"></a>连接数和处理请求</h2><p>最大连接数8192 + 100等待， 处理请求 200</p>
<h2 id="SpringBoot如何处理跨域请求？"><a href="#SpringBoot如何处理跨域请求？" class="headerlink" title="SpringBoot如何处理跨域请求？"></a>SpringBoot如何处理跨域请求？</h2><p>CORS： （Cross-Origin Resource Sharing）</p>
<p><strong>1. 配置局部CORS</strong>， 需要使用<code>@CrossOrigin</code> 这个注解，只需要写在Controller上，参数是要跨域的地址。</p>
<p>具体实现：</p>
<p><img src="https://pic1.imgdb.cn/item/67bf0db4d0e0a243d406267e.png"></p>
<p><strong>2. 配置全局CORS</strong>， 通过实现WebMvcConfigurer，来配置跨域请求</p>
<p>具体实现：</p>
<p><img src="https://pic1.imgdb.cn/item/67bf0e50d0e0a243d406271c.png"></p>
<p><strong>3. 还可以添加CorsFilter</strong> 来处理跨域请求。（可以自定义Filter，但是没必要）</p>
<p>具体实现：</p>
<p><img src="https://pic1.imgdb.cn/item/67bf0ebfd0e0a243d406278b.png"></p>
<p>注意：</p>
<ol>
<li>跨域成功后，响应会出现一个跨域成功的响应头。</li>
<li><strong>CorsFilter -&gt; Interceptor -&gt; CorsInterceptor</strong> ，这是执行顺序，当请求在进入Cors前被拦截的话，会报跨域错误，可以使用CorsFilter解决。</li>
</ol>
<h2 id="SpringBoot中实现拦截器的操作？"><a href="#SpringBoot中实现拦截器的操作？" class="headerlink" title="SpringBoot中实现拦截器的操作？"></a>SpringBoot中实现拦截器的操作？</h2><ol>
<li>创建拦截器类，继承HandlerInterceptor接口。</li>
<li>在配置类，WebMvcConfigurer中注册拦截器addInterceptors。</li>
</ol>
<p><strong>拦截器方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;面试鸭请求开始前&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 返回 true 继续处理，false 则拦截请求</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;面试鸭请求后&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;面试鸭请求完成&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注册拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">       registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>()).addPathPatterns(<span class="string">&quot;/api/**&quot;</span>);  <span class="comment">// 拦截指定路径</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于过滤器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 过滤逻辑</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>关于过滤器和拦截器的执行顺序</strong></p>
<p><img src="https://pic1.imgdb.cn/item/67bf115fd0e0a243d40629cf.png"></p>
<p>可以通过@Order注解或配置类中加入的顺序定义执行顺序。</p>
<p><strong>区别对比：</strong></p>
<ol>
<li>执行时机<ul>
<li>拦截器在SpringMVC中处理请求之前或之后执行，主要拦截控制方法。</li>
<li>过滤器则在Servlet层面工作，它拦截了所有HTTP请求，不局限于SpringMVC</li>
</ul>
</li>
<li>应用场景<ul>
<li>拦截器适用于处理与控制器相关的逻辑，例如权限校验，日志记录等</li>
<li>过滤器适合处理所有HTTP请求相关操作，如字符编码设置，CORS处理等</li>
</ul>
</li>
<li>优先级<ul>
<li>过滤器的执行优先级高于拦截器，过滤器先于拦截器处理请求。</li>
</ul>
</li>
</ol>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><h2 id="SpringBoot-Actuator是什么？"><a href="#SpringBoot-Actuator是什么？" class="headerlink" title="SpringBoot Actuator是什么？"></a>SpringBoot Actuator是什么？</h2><p>actuator 执行器，驱动器</p>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Spring Actuator 是Spring Boot的一个子项目，提供了一套用于监控和管理SpringBoot应用程序的的功能。这些功能包括不但限于<strong>应用程序健康检查，指标收集，应用程序信息和环境配置等</strong>。Actuator通过提供多种可定制的端点来实现这些功能，这些端点可以通过HTTP，JMX来进行访问。具有简便性，可扩展性，安全性，易于集成。</p>
<h2 id="SpringBoot中如何实现异步处理？"><a href="#SpringBoot中如何实现异步处理？" class="headerlink" title="SpringBoot中如何实现异步处理？"></a>SpringBoot中如何实现异步处理？</h2><p><strong>1. <code>@Async</code> 注解</strong></p>
<p>它是Spring提供的注解，通过这个注解指定某个方法在另一个线程中异步执行。</p>
<p>注意：需要再启动类中配置 <code>@EableAsync</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 异步执行的代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Executing method asynchronously. &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2. 使用CompletableFuture</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">asyncMethodWithReturn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 异步执行的代码</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">&quot;Hello, mianshiya.com!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3. 使用定时任务</strong></p>
<p><code>@Scheduled</code></p>
<p>注意：同样需要再主类中，设置<code>@EableScheduled</code></p>
<p><strong>4. 使用线程池</strong></p>
<p>可以将任务显示的提交到线程池中，进行任务的异步处理，推荐使用自定义线程池，可以根据项目和任务的情况设置对应的线程池参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置代码</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;taskExecutor&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">taskExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">2</span>); <span class="comment">// 执行者</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">2</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">500</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;Thread-&quot;</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程池的注意事项</strong></p>
<ul>
<li>合理配置线程池：根据应用的具体需求，合理的配置线程池的大小和其他参数，，以保证系统的性能和稳定性。（即使使用了@Async，本质也是利用线程池执行异步任务）</li>
<li>注意异常处理：任务中的异常处理需要关注，避免出现异常未捕获直接丢失且没有发现的情况。</li>
</ul>
<h2 id="Spring-Boot-的事件机制"><a href="#Spring-Boot-的事件机制" class="headerlink" title="Spring Boot 的事件机制"></a>Spring Boot 的事件机制</h2><p>通过 发布-订阅模式</p>
<p>作用：</p>
<ul>
<li>解耦： 通过事件机制，可以在不同组件之间传递消息，而不需要他们之间有直接的依赖关系，从而提高了代码的可维护性和扩展性。</li>
<li>异步处理： 某些事件可以异步处理，从而提高应用程序的响应速度和性能。</li>
<li>状态通知：通过事件，可以通知应用应用程序的不同部分发生某些特定的状态变化。</li>
</ul>
<p><strong>具体</strong></p>
<p>基于 <strong>观察者模式实现</strong> 。</p>
<p>需要： 事件（继承了ApplicationEvent）， 事件发布者（ApplicationEventPublisher）， 监听器（@EventListener）</p>
<p>自定义实现：</p>
<p><strong>事件定义</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">MyCustomEvent</span><span class="params">(Object source, String message)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(source);</span><br><span class="line">       <span class="built_in">this</span>.message = message;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> message;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>发布事件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventPublisher</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> ApplicationEventPublisher eventPublisher; <span class="comment">// 直接依赖注入</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(String message)</span> &#123;</span><br><span class="line">       <span class="type">MyCustomEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCustomEvent</span>(<span class="built_in">this</span>, message);</span><br><span class="line">       eventPublisher.publishEvent(event);发布</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>监听事件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span> <span class="comment">// 表示是异步处理</span></span><br><span class="line">   <span class="meta">@EventListener</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleCustomEvent</span><span class="params">(MyCustomEvent event)</span> &#123; <span class="comment">// 参数是要监听的事件</span></span><br><span class="line">       System.out.println(<span class="string">&quot;mianshiya Received event - &quot;</span> + event.getMessage());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SpringBoot中的内置事件"><a href="#SpringBoot中的内置事件" class="headerlink" title="SpringBoot中的内置事件"></a>SpringBoot中的内置事件</h4><ul>
<li>ApplicationStartingEvent: 在运行时发布</li>
<li>ApplicationEnvironmentPrepareEvent：在环境信息已准备但上下文还未创建时发布</li>
<li>ApplicationPreparedEvent：在上下文创建完成但未刷新是发布。</li>
<li>ApplicationRedyEvent：在任何相关的代码都已准备好运行时发布。</li>
<li>ApplicationFailedEvent：在启动时遇到错误是发布。</li>
</ul>
<h2 id="如何在SpringBoot启动时执行特定的代码？"><a href="#如何在SpringBoot启动时执行特定的代码？" class="headerlink" title="如何在SpringBoot启动时执行特定的代码？"></a>如何在SpringBoot启动时执行特定的代码？</h2><p>答： 一共有六种</p>
<p><strong>1. 实现接口 CommandLineRunner接口</strong></p>
<p>command 命令  line 线 runner 跑步者</p>
<p>实现这个接口后，用于在SpringBoot应用启动完成后，执行特定的代码逻辑，具体可以看springboot的启动流程。可以有多个实现类，通过 @Order来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCommandLineRunner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;www.mianshiya.com: Application started!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2. 实现ApplicationRunner接口</strong></p>
<p>ApplicationRunner接口和CommandLineRunner接口类似，不过有一个ApplicationArguments参数，就是应用启动参数。</p>
<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ApplicationRunner: mianshiya.com started with arguments: &quot;</span> + args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用@PostConstruct注解</strong></p>
<p>Spring容器初始化bean后，会执行初始化方法。这个注解适用于需要在bean初始化后立即执行的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPostConstructBean</span> &#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;PostConstruct: Bean initialized!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// construct 构建</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>4. 使用InitializingBean接口</strong></p>
<p>提供了方法，用于在Spring容器初始化bean的属性后执行，执行特定的初始化逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInitializingBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;InitializingBean: Properties set!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>5. 使用Spring 事件监听器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventListener</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;EventListener: Context refreshed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p><strong>6. 自定义BeanFactoryPostProcessor 和 BeanPostProcessor</strong></p>
<p>他们都是Spring容器给的扩展点，可以在Spring容器初始化bean之前或之后执行特定的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">         <span class="comment">// bean 初始化前</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MySpecificBean) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BeanPostProcessor: Before initialization of &quot;</span> + mianshiya.com);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">       <span class="comment">// bean 初始化后</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MySpecificBean) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;BeanPostProcessor: After initialization of &quot;</span> + mianshiya.com);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/23/springMVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/23/springMVC/" class="post-title-link" itemprop="url">springMVC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-23 15:15:29" itemprop="dateCreated datePublished" datetime="2025-02-23T15:15:29+08:00">2025-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-21 11:25:01" itemprop="dateModified" datetime="2025-03-21T11:25:01+08:00">2025-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="结果流程图"><a href="#结果流程图" class="headerlink" title="结果流程图"></a>结果流程图</h2><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250223151556493.png" alt="image-20250223151556493"></p>
<p><img src="https://pic1.imgdb.cn/item/67bacd78d0e0a243d402794b.png"></p>
<p>介绍：</p>
<p>首先，SpringMVC 是属于 <strong>SpringFramework</strong> 生态里面的一个模块， 它是在 Serlet 的基础上构建，并且使用了<strong>MVC模式</strong>，设计的一个Web框架，它的目的是为了简化传统的 <strong>Servlet+JSP</strong> 模式下的Web开发方式，其次 SpringMVC 的整个架构设计是对Java Web里面的MVC框架模式做了一些<strong>增强和扩展</strong>，主要体现在以下几个方面：</p>
<ul>
<li>把传统MVC框架里面的Controller控制器做了拆分，分成了<strong>前端控制器Dispactcherservlet</strong>和<strong>后端控制器Controller</strong>。</li>
<li>把Model模型拆分成了<strong>业务层的Service和数据访问层的Repository</strong>。</li>
<li>在视图层面，可以支持不同的视图<strong>Freemark,velocity,JSP</strong>等</li>
</ul>
<h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p><strong>Dispatcherservlet:</strong> 它是SpringMVC的核心，他是一个Servlet，负责接受HTTP请求并调度请求到适当的处理器。</p>
<p><strong>@Controller和@RequestMapping：</strong> 前者用于标记控制类，后者则用于定义控制类中的方法和URL请求的映射关系。</p>
<p><strong>ModelAndView</strong> : 控制返回的数据和视图封装在 ModelAndView 对象中。</p>
<p><strong>ViewResolver（视图解析器）</strong>: 它负责将逻辑视图名称解析为物理视图，Spring提供了多种视图解析器。</p>
<p><strong>@RequestParam和@PathVariable</strong>： 用于获取请求参数，后者用于获取URL中的路径变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> String userId)</span> &#123;</span><br><span class="line">  <span class="comment">// 使用请求参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String userId)</span> &#123;</span><br><span class="line">  <span class="comment">// 使用路径变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表单处理和数据绑定"><a href="#表单处理和数据绑定" class="headerlink" title="表单处理和数据绑定"></a>表单处理和数据绑定</h2><p>SpringMVC提供了强大的表单处理和数据绑定，允许将表单数据直接绑定到模型对象中。</p>
<p><strong>数据绑定：</strong> 通过 <code>@ModelAttroibute</code> 注解，Spring自动将表单数据绑定到模型对象上，并将其传递给控制方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/submitForm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">submitForm</span><span class="params">(<span class="meta">@ModelAttribute(&quot;user&quot;)</span> User user)</span> &#123;</span><br><span class="line">  <span class="comment">// 处理表单提交的数据</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>表单校验：</strong> <code>@Valid</code>  和  <code>BindingResult</code></p>
<h2 id="SpringMVC的全局异常处理"><a href="#SpringMVC的全局异常处理" class="headerlink" title="SpringMVC的全局异常处理"></a>SpringMVC的全局异常处理</h2><p><strong>全局异常处理：</strong> 通过 <code>@ControllerAdvice</code> 和<code>@ExceptionHandler</code> 注解可以定义全局异常处理器，捕获应用中抛出的异常，并进行统一的异常处理。</p>
<p>注意：这里处理的是传到控制层的异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">  <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">handleException</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">      <span class="comment">// 处理异常</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringMVC的拦截器"><a href="#SpringMVC的拦截器" class="headerlink" title="SpringMVC的拦截器"></a>SpringMVC的拦截器</h2><h3 id="1-Spring-MVC-请求处理流程"><a href="#1-Spring-MVC-请求处理流程" class="headerlink" title="1. Spring MVC 请求处理流程"></a>1. <strong>Spring MVC 请求处理流程</strong></h3><p>Spring MVC 的请求处理流程大致如下：</p>
<ol>
<li>**请求到达 <code>DispatcherServlet</code>**：<ul>
<li><code>DispatcherServlet</code> 是 Spring MVC 的核心组件，负责接收所有的 HTTP 请求。</li>
</ul>
</li>
<li>**调用 <code>HandlerMapping</code>**：<ul>
<li><code>DispatcherServlet</code> 通过 <code>HandlerMapping</code> 找到与请求匹配的处理器（Handler），通常是控制器方法。</li>
</ul>
</li>
<li><strong>执行拦截器的 <code>preHandle</code> 方法</strong>：！！<ul>
<li>在找到处理器之后，<code>DispatcherServlet</code> 会调用拦截器链中的 <code>preHandle</code> 方法。</li>
<li>如果某个拦截器的 <code>preHandle</code> 方法返回 <code>false</code>，则请求处理终止，后续的拦截器和控制器方法都不会执行。</li>
</ul>
</li>
<li><strong>执行控制器方法</strong>：<ul>
<li>如果所有拦截器的 <code>preHandle</code> 方法都返回 <code>true</code>，则 <code>DispatcherServlet</code> 会调用控制器方法处理请求。</li>
</ul>
</li>
<li><strong>执行拦截器的 <code>postHandle</code> 方法</strong>：！！<ul>
<li>在控制器方法执行完成后，<code>DispatcherServlet</code> 会调用拦截器链中的 <code>postHandle</code> 方法。</li>
</ul>
</li>
<li><strong>渲染视图</strong>：<ul>
<li>如果控制器方法返回了一个视图名称，<code>DispatcherServlet</code> 会调用 <code>ViewResolver</code> 解析视图并渲染。</li>
</ul>
</li>
<li><strong>执行拦截器的 <code>afterCompletion</code> 方法</strong>：！！<ul>
<li>在视图渲染完成后，<code>DispatcherServlet</code> 会调用拦截器链中的 <code>afterCompletion</code> 方法。</li>
</ul>
</li>
</ol>
<h3 id="2-设置拦截器"><a href="#2-设置拦截器" class="headerlink" title="2. 设置拦截器"></a>2. 设置拦截器</h3><p>实现HandlerInterceptor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 在处理器方法调用前进行拦截</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 处理器方法执行后，但视图渲染前执行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 视图渲染后执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在配置类中注册拦截器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>) <span class="comment">// 拦截所有路径</span></span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/error&quot;</span>); <span class="comment">// 排除某些路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringMVC的父子容器"><a href="#SpringMVC的父子容器" class="headerlink" title="SpringMVC的父子容器"></a>SpringMVC的父子容器</h2><p>在 Spring MVC 中，<strong>父子容器</strong>是一种常见的架构设计，用于将 <strong>Spring MVC 容器</strong>（子容器）和 <strong>Spring 根容器</strong>（父容器）分离。这种设计有助于清晰地划分职责，并解决 Bean 的重复加载和冲突问题。</p>
<hr>
<h3 id="1-父子容器的概念"><a href="#1-父子容器的概念" class="headerlink" title="1. 父子容器的概念"></a>1. <strong>父子容器的概念</strong></h3><ul>
<li><strong>父容器（Root ApplicationContext）</strong>：<ul>
<li>通常用于管理业务逻辑层的 Bean，例如 Service、Repository、DataSource 等。</li>
<li>父容器由 <code>ContextLoaderListener</code> 初始化，加载的配置文件通常是 <code>applicationContext.xml</code> 或通过 Java 配置类。</li>
<li>父容器是全局的，可以被多个子容器共享。</li>
</ul>
</li>
<li><strong>子容器（Web ApplicationContext）</strong>：<ul>
<li>通常用于管理 Web 层的 Bean，例如 Controller、HandlerMapping、ViewResolver 等。</li>
<li>子容器由 <code>DispatcherServlet</code> 初始化，加载的配置文件通常是 <code>spring-servlet.xml</code> 或通过 Java 配置类。</li>
<li>子容器可以访问父容器中的 Bean，但父容器不能访问子容器中的 Bean。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-父子容器的关系"><a href="#2-父子容器的关系" class="headerlink" title="2. 父子容器的关系"></a>2. <strong>父子容器的关系</strong></h3><ul>
<li><strong>继承关系</strong>：<ul>
<li>子容器是父容器的子容器，子容器可以访问父容器中的 Bean，但父容器不能访问子容器中的 Bean。</li>
<li>这种设计使得 Web 层可以共享业务逻辑层的 Bean，同时保持职责分离。</li>
</ul>
</li>
<li><strong>Bean 查找规则</strong>：<ul>
<li>当子容器查找一个 Bean 时，会先在子容器中查找。如果找不到，则会到父容器中查找。</li>
<li>这种机制避免了 Bean 的重复定义和冲突。</li>
</ul>
</li>
</ul>
<h3 id="3-父子容器的优点5"><a href="#3-父子容器的优点5" class="headerlink" title="3. *父子容器的优点5"></a>3. *<em>父子容器的优点</em>5</h3><ul>
<li><strong>职责分离</strong>：<ul>
<li>父容器负责业务逻辑层的 Bean，子容器负责 Web 层的 Bean，职责清晰。</li>
</ul>
</li>
<li><strong>避免 Bean 冲突</strong>：<ul>
<li>父子容器的设计避免了 Bean 的重复定义和冲突。</li>
</ul>
</li>
<li><strong>共享 Bean</strong>：<ul>
<li>子容器可以访问父容器中的 Bean，方便共享业务逻辑层的组件。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-父子容器的注意事项"><a href="#4-父子容器的注意事项" class="headerlink" title="4. 父子容器的注意事项"></a>4. <strong>父子容器的注意事项</strong></h3><ul>
<li><strong>Bean 的作用范围</strong>：<ul>
<li>如果某个 Bean 在父容器和子容器中都定义了，子容器会优先使用自己定义的 Bean。</li>
</ul>
</li>
<li><strong>AOP 配置</strong>：<ul>
<li>如果需要在父子容器中共享 AOP 配置，建议将 AOP 配置放在父容器中。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>父容器</strong>：管理业务逻辑层的 Bean，由 <code>ContextLoaderListener</code> 初始化。</li>
<li><strong>子容器</strong>：管理 Web 层的 Bean，由 <code>DispatcherServlet</code> 初始化。</li>
<li><strong>父子容器的关系</strong>：子容器可以访问父容器中的 Bean，但父容器不能访问子容器中的 Bean。</li>
<li><strong>优点</strong>：职责分离、避免 Bean 冲突、共享 Bean。</li>
</ul>
<p>父子容器的设计是 Spring MVC 中一种常见的架构模式，能够有效组织和管理应用程序的组件。</p>
<h2 id="关于applicationcontext的初始化"><a href="#关于applicationcontext的初始化" class="headerlink" title="关于applicationcontext的初始化"></a>关于applicationcontext的初始化</h2><hr>
<h3 id="1-ApplicationContext-的初始化方式"><a href="#1-ApplicationContext-的初始化方式" class="headerlink" title="1. ApplicationContext 的初始化方式"></a>1. <strong><code>ApplicationContext</code> 的初始化方式</strong></h3><p><code>ApplicationContext</code> 可以通过多种方式初始化，具体取决于项目的类型和配置：</p>
<ul>
<li><p><strong>手动初始化</strong>：通过代码显式地创建 <code>ApplicationContext</code>，例如：</p>
<p>java</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure>

<p>这种方式通常用于独立的 Java 应用程序（非 Web 应用）。</p>
</li>
<li><p><strong>自动初始化</strong>：在 Web 应用中，<code>ApplicationContext</code> 通常由 Spring 的相关组件（如 <code>ContextLoaderListener</code> 或 <code>DispatcherServlet</code>）自动初始化。</p>
</li>
</ul>
<hr>
<h3 id="2-Web-应用中的-ApplicationContext-初始化"><a href="#2-Web-应用中的-ApplicationContext-初始化" class="headerlink" title="2. Web 应用中的 ApplicationContext 初始化"></a>2. <strong>Web 应用中的 <code>ApplicationContext</code> 初始化</strong></h3><p>在 Spring MVC 的 Web 应用中，<code>ApplicationContext</code> 的初始化通常分为两部分：</p>
<ul>
<li><p><strong>父容器（Root ApplicationContext）</strong>：</p>
<ul>
<li><p>由 <code>ContextLoaderListener</code> 初始化。</p>
</li>
<li><p>负责加载业务逻辑层的 Bean（如 Service、Repository 等）。</p>
</li>
<li><p>在 <code>web.xml</code> 中配置：</p>
<p>xml</p>
<p>复制</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>运行 HTML</p>
</li>
</ul>
</li>
<li><p><strong>子容器（Web ApplicationContext）</strong>：</p>
<ul>
<li><p>由 <code>DispatcherServlet</code> 初始化。</p>
</li>
<li><p>负责加载 Web 层的 Bean（如 Controller、HandlerMapping 等）。</p>
</li>
<li><p>在 <code>web.xml</code> 中配置：</p>
<p>xml</p>
<p>复制</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>运行 HTML</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-为什么说-ApplicationContext-是由-ContextLoaderListener-初始化的？"><a href="#3-为什么说-ApplicationContext-是由-ContextLoaderListener-初始化的？" class="headerlink" title="3. 为什么说 ApplicationContext 是由 ContextLoaderListener 初始化的？"></a>3. <strong>为什么说 <code>ApplicationContext</code> 是由 <code>ContextLoaderListener</code> 初始化的？</strong></h3><ul>
<li>在 Web 应用中，<code>ContextLoaderListener</code> 是一个 Servlet 监听器，它会在 Web 应用启动时自动初始化父容器（Root ApplicationContext）。</li>
<li>这种设计是为了将 Spring 容器的初始化与 Web 容器的生命周期绑定，避免手动管理 <code>ApplicationContext</code> 的创建和销毁。</li>
<li>通过 <code>ContextLoaderListener</code>，Spring 可以自动加载配置文件并初始化父容器，而不需要开发者显式地调用 <code>new</code> 来创建 <code>ApplicationContext</code>。</li>
</ul>
<hr>
<h3 id="4-手动初始化-vs-自动初始化"><a href="#4-手动初始化-vs-自动初始化" class="headerlink" title="4. 手动初始化 vs 自动初始化"></a>4. <strong>手动初始化 vs 自动初始化</strong></h3><ul>
<li><p><strong>手动初始化</strong>：</p>
<ul>
<li><p>适用于独立的 Java 应用程序。</p>
</li>
<li><p>开发者需要显式地创建 <code>ApplicationContext</code>，并管理其生命周期。</p>
</li>
<li><p>示例：</p>
<p>java</p>
<p>复制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>自动初始化</strong>：</p>
<ul>
<li>适用于 Web 应用程序。</li>
<li>由 <code>ContextLoaderListener</code> 或 <code>DispatcherServlet</code> 自动初始化 <code>ApplicationContext</code>。</li>
<li>开发者只需在 <code>web.xml</code> 或 Java 配置类中定义配置，Spring 会自动完成容器的初始化和销毁。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. <strong>总结</strong></h3><ul>
<li>在 <strong>Web 应用</strong> 中，<code>ApplicationContext</code> 通常是由 <code>ContextLoaderListener</code> 或 <code>DispatcherServlet</code> 自动初始化的，而不是通过 <code>new</code> 手动创建的。</li>
<li>这种设计是为了将 Spring 容器的生命周期与 Web 容器的生命周期绑定，简化开发者的工作。</li>
<li>在 <strong>独立应用</strong> 中，开发者可以手动创建 <code>ApplicationContext</code>。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/23/springcloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/23/springcloud/" class="post-title-link" itemprop="url">springcloud</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-23 13:05:04" itemprop="dateCreated datePublished" datetime="2025-02-23T13:05:04+08:00">2025-02-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/21/spring%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/21/spring%E6%BA%90%E7%A0%81/" class="post-title-link" itemprop="url">spring源码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-21 14:36:18" itemprop="dateCreated datePublished" datetime="2025-02-21T14:36:18+08:00">2025-02-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-21 11:34:59" itemprop="dateModified" datetime="2025-03-21T11:34:59+08:00">2025-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><img src="https://pic1.imgdb.cn/item/67ceff5a066befcec6e27f31.png" alt="Spring.png">

<h2 id="Spring的启动流程"><a href="#Spring的启动流程" class="headerlink" title="Spring的启动流程"></a>Spring的启动流程</h2><p>什么是spring容器？</p>
<p>管理Bean对象，通过依赖注入组织Bean之间关系，从而降低业务对象之间耦合性， -IOC</p>
<p>学习Spring容器的启动流程，就是去学校application context 的创建过程</p>
<img src="https://pic1.imgdb.cn/item/67b98643d0e0a243d401e754.png" alt="image.png">

<p>创建：ApplicationContext</p>
<img src="https://pic1.imgdb.cn/item/67b98688d0e0a243d401e7a7.png" alt="image.png">

<p>创建容器后，通过getBean来获取Bean对象</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222161328079.png" alt="image-20250222161328079"></p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222163135114.png" alt="image-20250222163135114"></p>
<h3 id="读取配置类"><a href="#读取配置类" class="headerlink" title="读取配置类"></a>读取配置类</h3><p>读取配置类，通过配置类来找到要读取的xml文件，来加载Bean。</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222161521409.png" alt="image-20250222161521409"></p>
<p>上：读取配置类，来加载Bean信息</p>
<p>下：读取Xml文件，来读取Bean信息</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>读取完配置信息后，这些配置就会存储到<strong>BeanDefinition</strong>的对象中。</p>
<p>他是个接口，查看它的实现类，里面会存储配置的信息</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222162024143.png" alt="image-20250222162024143"></p>
<p>这些都是将配置信息复制到实现类中。</p>
<p>通常情况下， 有一个Bean 就会有一个 <strong>BeanDefinition</strong>。</p>
<p>这些保存在一个集合中， <strong>BeanDefinitionMap &lt; beanName, BeanDefiniton&gt;</strong> </p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222162449029.png" alt="image-20250222162449029"> </p>
<h3 id="创建Bean"><a href="#创建Bean" class="headerlink" title="创建Bean"></a>创建Bean</h3><p>循环BeanDefinition，获取Bean信息，懒加载则不会创建，判断是不是多例Bean</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222162829953.png" alt="image-20250222162829953"></p>
<p>可以通过@Scope 改变Bean的类型。</p>
<p>singlenObjects&lt;beanName, Object&gt; 存储Bean对象的map。从里面获取bean。</p>
<h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222164210750.png" alt="image-20250222164210750"></p>
<p>未获取到则创建Bean - 》 拿 BeanDfinitio。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>实例化， 通过反射的方式获取对象实例。</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222164559415.png" alt="image-20250222164559415"></p>
<h4 id="初始化方法回调"><a href="#初始化方法回调" class="headerlink" title="初始化方法回调"></a>初始化方法回调</h4><p>初始化方法回调的方式有三种</p>
<ul>
<li>实现接口InitializingBean，通过实现里面的初始化方法来初始化。</li>
<li>通过注解 @PostConstruct，来把注解的方法变成初始化方法。</li>
<li>通过xml来初始化。</li>
</ul>
<p>初始化完成后，会将Bean放入单例池中。</p>
<h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p>实例化 -》 依赖注入 -》 初始化 -》 放入单例池中 -&gt; 销毁</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222165416502.png" alt="image-20250222165416502"></p>
<p>销毁方法回调的三种方式</p>
<ul>
<li>DisposableBean接口来实现销毁方法回调。</li>
</ul>
<p>实例化时， 会通过反射的方式，去推断构造函数，默认会调用无参函数。</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222165809114.png" alt="image-20250222165809114"></p>
<p>通过反射的方式获取工厂方法，来获取对应的Bean。</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222165930034.png" alt="image-20250222165930034"></p>
<p>初始化这里会调用初始化方法，还会调用Aware。</p>
<p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222170905614.png" alt="image-20250222170905614"></p>
<p>会调用9次后置处理器。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222171307910.png" alt="image-20250222171307910"></p>
<p>BeanFactory没有读取配置的功能，需要传入BenaDefinition。</p>
<h3 id="不使用applicationcontext读取配置类"><a href="#不使用applicationcontext读取配置类" class="headerlink" title="不使用applicationcontext读取配置类"></a>不使用applicationcontext读取配置类</h3><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250222172029850.png" alt="image-20250222172029850"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZhangYuHao</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
