<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一个小人物的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Zhang&#39;Blog">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Zhang&#39;Blog">
<meta property="og:description" content="一个小人物的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZhangYuHao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zhang'Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zhang'Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZhangYuHao"
      src="/images/111.png">
  <p class="site-author-name" itemprop="name">ZhangYuHao</p>
  <div class="site-description" itemprop="description">一个小人物的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/2567821933" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;2567821933" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:103903Zyh@gmail.com" title="E-Mail → mailto:103903Zyh@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/14/%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/14/%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-14 08:21:53" itemprop="dateCreated datePublished" datetime="2025-02-14T08:21:53+08:00">2025-02-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-10 21:04:31" itemprop="dateModified" datetime="2025-03-10T21:04:31+08:00">2025-03-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><img src="https://pic1.imgdb.cn/item/67cee345066befcec6e2791c.png" alt="集合.png">

<h2 id="CopyOnWriteArraylist"><a href="#CopyOnWriteArraylist" class="headerlink" title="CopyOnWriteArraylist"></a>CopyOnWriteArraylist</h2><p>是线程安全的Arraylist，并且没有用到锁。</p>
<ul>
<li>是线程安全的Arraylist的实现类，是写时复制。</li>
<li>写操作会加锁，但是读操作不会加锁。</li>
<li>进行写操作时，先复制原数组，在原数组的副本上进行修改， 将原数组改成原数组的副本，最后读操作读取原数组的副本。</li>
<li>由于在写操作时创建了新的副本，所以会占用更多的内存</li>
<li>Collections.synchronizedList是对集合List加锁，会对所有的操作都加锁。（包装方法，可以临时的把一个list转化成并发安全的类）</li>
<li>Collections.synchronizedList的效率是没有CopyOnWriteArraylist高的。</li>
</ul>
<h2 id="List接口的实现类"><a href="#List接口的实现类" class="headerlink" title="List接口的实现类"></a>List接口的实现类</h2><p>Arraylist(基于动态数组)</p>
<p>Linkedlist（基于链表）</p>
<p>Vector（线程安全，开销大，加了synchroonized锁）每个方法</p>
<p>Stack</p>
<p>CopyOnWriteArraylist（线程安全，开销小，没用锁）复制副本数组</p>
<h2 id="Arraylist"><a href="#Arraylist" class="headerlink" title="Arraylist"></a>Arraylist</h2><p>底层使用到了数组，默认初始容量为10, Arraylist没有负载因子概念。</p>
<p>在触发扩容时，1.5倍扩容，并将数组复制到新的数组中</p>
<p>注意：</p>
<p>初始容量：1.7和1.8的区别</p>
<p>默认容量都是10</p>
<p>1.7：是在调用构造函数时，开辟空间。</p>
<p>1.8：之后是在调用add方法的时候，开辟空间，节约内存，只有真正使用的时候，才创建数组。</p>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>线程安全，并发安全，全局锁（synchronized），效率低，无法并发访问。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>线程安全，并发安全，锁的是结点（CAS和synchronized）</p>
<p>如果某个节点为为空，则通过CAS将数组插入节点。如果不为空，则会退化到synchronized</p>
<h2 id="concurrentSkipListMap"><a href="#concurrentSkipListMap" class="headerlink" title="concurrentSkipListMap"></a>concurrentSkipListMap</h2><p>线程安全，使用CAS，不使用锁（Compare And Swap）比较替换，并发跳表。</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>基于HashMap实现，不允许重复元素，存储无序的一组唯一元素。</p>
<p>本质就是封装了一下HashMap，用键来存储值，值存储的是默认元素。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>基于hash表结构，存储的是键值对，键唯一，值可以重复。</p>
<p>JDK1.8改动：</p>
<ul>
<li><strong>改进了哈希函数的运算</strong>：JDK1.8中优化了哈希函数，使得哈希值的分布更加均匀，减少了哈希冲突的发生。通过在生成哈希值时，使用“扰动函数“，确保哈希值的高低位都能参与到桶的选择中。</li>
<li><strong>扩容机制优化</strong>： JDK1.8改进了扩容时的元素迁移机制，在扩容过程中，不再对每个元素重新计算哈希值，而是根据原数组长度的高位来判断元素是留在原位置，还是迁移到新数组中的新位置。这一改动减少了不必要的计算，提升了扩容效率。（高位判断：新位置 &#x3D; 原位置+数组长度）</li>
<li><strong>头插法变为了尾插法</strong>： 头插法的好处是插入时，不需要遍历链表，直接替换成头结点，但是缺点是扩容时，会逆序，而逆序在多线程操作下可能出现死循环，于是改成了尾插法。</li>
</ul>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p>是java集合框架中的一个实现类，继承自HashMap，并且保留了键值对的插入顺序或访问顺序。</p>
<p>它的内部是通过维护一个双向链表来记录元素的插入或访问顺序。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>缓存实现： 可以根据访问顺序移除最久未使用的元素，常用语LRU缓存。</li>
<li>数据存储： 需要保持元素插入顺序的场景。</li>
</ul>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>基于红黑树实现，</p>
<p>可以传入一个Comparable根据定义规则进行键排序。</p>
<p>键是有序的。</p>
<p>不允许键为null，可以值为null</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-10 09:19:45" itemprop="dateCreated datePublished" datetime="2025-02-10T09:19:45+08:00">2025-02-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-11 08:54:38" itemprop="dateModified" datetime="2025-02-11T08:54:38+08:00">2025-02-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h2><h3 id="Linux有哪些命令？"><a href="#Linux有哪些命令？" class="headerlink" title="Linux有哪些命令？"></a>Linux有哪些命令？</h3><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="线程和进程的区别是什么？"><a href="#线程和进程的区别是什么？" class="headerlink" title="线程和进程的区别是什么？"></a>线程和进程的区别是什么？</h3><p><strong>1. 本质区别</strong></p>
<p>进程是操作系统资源分配的基本单位，线程是cpu任务调度和执行的基本单位。</p>
<p><strong>2. 资源开销</strong></p>
<p>每个进程都有独立的代码和数据空间（程序上下文），进程之间切换开销比较大，同一进程内的线程共享此进程的代码和数据空间，只拥有自己独立运行栈和程序计数器，线程之间的开销较小。</p>
<p><strong>3. 包含关系</strong></p>
<p>线程是进程的一部分，同一个进程可以包含一个或多个进程。</p>
<p><strong>4. 健壮性</strong></p>
<p>多个进程空间相互独立，一个进程出错不会对其他进程造成影响，但是一个进程内一个线程崩溃会造成整个进程的出错。多进程比多线程要健壮。</p>
<p><strong>5. 内存分配</strong></p>
<p>同一进程中的线程共享彼此进程的内存空间和资源，多个进程之间的内存空间相互独立。</p>
<p><strong>6. 执行过程</strong></p>
<p>每个独立的进程拥有程序运行的入口，顺序执行序列和程序出口；但是线程不能独立执行，必须依赖进程</p>
<h3 id="进程间的通信有什么？"><a href="#进程间的通信有什么？" class="headerlink" title="进程间的通信有什么？"></a>进程间的通信有什么？</h3><h3 id="进程的调度算法有哪些？"><a href="#进程的调度算法有哪些？" class="headerlink" title="进程的调度算法有哪些？"></a>进程的调度算法有哪些？</h3><h2 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h2><h3 id="IO模型有哪些？"><a href="#IO模型有哪些？" class="headerlink" title="IO模型有哪些？"></a>IO模型有哪些？</h3><h3 id="select-poll-epoll区别"><a href="#select-poll-epoll区别" class="headerlink" title="select poll epoll区别"></a>select poll epoll区别</h3><h3 id="为什么网络IO会被阻塞"><a href="#为什么网络IO会被阻塞" class="headerlink" title="为什么网络IO会被阻塞"></a>为什么网络IO会被阻塞</h3><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="什么是用户态和内核态？"><a href="#什么是用户态和内核态？" class="headerlink" title="什么是用户态和内核态？"></a>什么是用户态和内核态？</h3><h3 id="什么是Reactior？"><a href="#什么是Reactior？" class="headerlink" title="什么是Reactior？"></a>什么是Reactior？</h3><h3 id="为什么会有虚拟内存"><a href="#为什么会有虚拟内存" class="headerlink" title="为什么会有虚拟内存"></a>为什么会有虚拟内存</h3><h3 id="什么是分段，什么是分页？"><a href="#什么是分段，什么是分页？" class="headerlink" title="什么是分段，什么是分页？"></a>什么是分段，什么是分页？</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-06 08:24:09" itemprop="dateCreated datePublished" datetime="2025-02-06T08:24:09+08:00">2025-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-08 19:42:43" itemprop="dateModified" datetime="2025-03-08T19:42:43+08:00">2025-03-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="计算机网络面试"><a href="#计算机网络面试" class="headerlink" title="计算机网络面试"></a>计算机网络面试</h1><h2 id="TCP-IP四层模型是什么？"><a href="#TCP-IP四层模型是什么？" class="headerlink" title="TCP&#x2F;IP四层模型是什么？"></a>TCP&#x2F;IP四层模型是什么？</h2><p>图解：</p>
<p><img src="https://pic1.imgdb.cn/item/67a40ca1d0e0a243d4fc0c57.png"></p>
<p>TCP&#x2F;IP 协议是一种网络体系模型的代名词，指多种协议的协议簇，包含： TCP,IP,MAX,UDP,HTTP,FTP等多种协议。</p>
<p>注意： 网络接口层因为没有具体的实现，可以拆分成 数据链路层 和 物理层。</p>
<h2 id="cookie-Session-Token-有什么区别？"><a href="#cookie-Session-Token-有什么区别？" class="headerlink" title="cookie Session Token 有什么区别？"></a>cookie Session Token 有什么区别？</h2><p>注意： HTTP是无状态的，服务器无法识别是那个客户端。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p><img src="https://pic1.imgdb.cn/item/67a40f5fd0e0a243d4fc0cb6.png"></p>
<p>cookie由服务器创建，保存在浏览器，用来识别是哪一个浏览器。</p>
<p>浏览器是可以直接查看的，不安全。</p>
<h3 id="Session（会话）"><a href="#Session（会话）" class="headerlink" title="Session（会话）"></a>Session（会话）</h3><p>设置了时间和sessionID。</p>
<p>图解：</p>
<p><img src="https://pic1.imgdb.cn/item/67a4108ad0e0a243d4fc0cd4.png"></p>
<p>安全性：</p>
<ul>
<li>SessionID是一串字符串，无法推测出用户名和密码。</li>
<li>服务器在发送Cookie之前，是会对含有SessionID的Cookie进行签名。</li>
</ul>
<p>SessionID保存在Cookie中。</p>
<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>Json Web Token（JWT）</p>
<p>思路： 无状态的Token，服务端不保存任何Token</p>
<p>图解：</p>
<p><img src="https://pic1.imgdb.cn/item/67a412acd0e0a243d4fc0d31.png"></p>
<p>JWT 的数据结构</p>
<p><img src="https://pic1.imgdb.cn/item/67a4132dd0e0a243d4fc0d4e.png"></p>
<p>缺点： 服务器不会保存会话状态，无法强制下线用户，只能再次校验。JWT不加密，可以保存敏感信息。</p>
<p>JWT适合场景，一次性的命令认证。</p>
<p>总结：</p>
<ul>
<li>JWT可以减少数据存储和数据库查询，因为它本身包含数据。</li>
<li>JWT的playload数据本身并没有加密，如果有敏感数据要手动加密。</li>
<li>JWT在未到期时间之前无法撤销，如果需要，可以通过其他方式实现，比如说黑名单。</li>
</ul>
<h2 id="从输入网址到网页显示发生了什么？"><a href="#从输入网址到网页显示发生了什么？" class="headerlink" title="从输入网址到网页显示发生了什么？"></a>从输入网址到网页显示发生了什么？</h2><p>输入网址</p>
<p>↓</p>
<p>DNS解析，将URL地址解析为ip地址。</p>
<p>（DNS里面记录着URL和ip）</p>
<p>↓</p>
<p>TCP（三次握手），连接，建立通道。</p>
<p>↓</p>
<p>发送HTTP请求</p>
<p>↓</p>
<p>响应HTTP请求（发送状态码）</p>
<p>↓</p>
<p>页面渲染（HTML，CSS，js）</p>
<p>↓</p>
<p>浏览器收到信息</p>
<h2 id="常见的-HTTP-状态码有哪些？"><a href="#常见的-HTTP-状态码有哪些？" class="headerlink" title="常见的 HTTP 状态码有哪些？"></a>常见的 HTTP 状态码有哪些？</h2><p><strong>1XX</strong>: <strong>信息性状态码</strong></p>
<ul>
<li>100 Contionue： 客户端应继续发送请求</li>
<li>101 Switching Protocols： 服务器要求客户端切换协议；</li>
</ul>
<p><strong>2XX: 成功状态码</strong></p>
<ul>
<li>200 OK： 请求成功</li>
<li>201 Created： 请求已成功并创建了新的资源。</li>
<li>204 No Content: 服务器成功处理了请求，但没有返回任何信息</li>
</ul>
<p><strong>3XX: 重定向状态码</strong></p>
<ul>
<li>301 Moved Permanently：资源的URL已永久更改，需要更新链接。</li>
<li>302 Found：资源的URL临时性更改。</li>
<li>304 Not Modified：客户端缓存的资源仍然有效，无需重新传输。</li>
</ul>
<p><strong>4XX： 客户端错误状态码</strong></p>
<ul>
<li>400 Bad Request：服务器无法理解请求的语法。</li>
<li>403 Forbidden：服务器拒绝请求。</li>
<li>404 Not Found：请求的资源不存在。</li>
</ul>
<p><strong>5XX: 服务器错误状态码</strong></p>
<ul>
<li>500 Internal Server Error：服务器遇到了意外情况。</li>
<li>503 Service Unavailable：服务器当前无法处理请求</li>
</ul>
<h2 id="HTTP请求包含哪些内容？-请求头和请求体有哪些内容？"><a href="#HTTP请求包含哪些内容？-请求头和请求体有哪些内容？" class="headerlink" title="HTTP请求包含哪些内容？ 请求头和请求体有哪些内容？"></a>HTTP请求包含哪些内容？ 请求头和请求体有哪些内容？</h2><p>请求行， 请求头， 请求体</p>
<p>请求头：</p>
<ul>
<li>Host： url地址中的主机</li>
<li>User-Agent：客户端的信息描述（我是谁？）</li>
<li>Content-Type： 请求体的消息格式</li>
</ul>
<p>请求体：表单数据</p>
<h3 id="GET和POST区别是什么？"><a href="#GET和POST区别是什么？" class="headerlink" title="GET和POST区别是什么？"></a>GET和POST区别是什么？</h3><ul>
<li>get 是HTTP协议中的一种请求方式，主要用于服务获取信息</li>
<li>post 是HTTP协议中的一种请求方式，主要用于向服务器发送数据</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li><strong>传输方式不同</strong>， get请求方式数据被包含在URL中，数据在网络上以明文的形式传输，数据量小；post数据存放在请求体里面，可以传输数据量大。</li>
<li><strong>数据量大小不同：</strong> get小，浏览器对长度有限制；post理论上没有限制，大。</li>
<li><strong>安全性不同：</strong> 由于get请求在URL中是可见的，不安全，不适合传输敏感信息。post方法的数据在请求体中，相对较为安全</li>
<li><strong>幂等性不同：</strong> get方法是幂等的，也就是说多次请求同一个URL，服务器的状态不会改变。而post方法不是幂等的，每次请求可能得到不同的结果。</li>
<li><strong>缓存方式不同：</strong> get方法通常可以被浏览器缓存，而post方法无法缓存。</li>
</ul>
<h2 id="TCP和UDP有什么区别？"><a href="#TCP和UDP有什么区别？" class="headerlink" title="TCP和UDP有什么区别？"></a>TCP和UDP有什么区别？</h2><p><strong>TCP（传输控制协议）</strong></p>
<p>面向连接的协议，通过建立可靠的连接来传输数据；TCP提供了可靠的传输，利用序号和重传机制确保数据的完整性和可靠性。传输数据慢，消耗资源多</p>
<p><strong>UDP（用户数据报协议）</strong></p>
<p>无连接协议，数据包发送前不需要建立连接；不提供可靠性保证，数据发送后不能得到确认和重传，UDP相对于TCP更加轻量，传输数据快，消耗资源少</p>
<h2 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h2><p><img src="https://pic1.imgdb.cn/item/67a9508dd0e0a243d4fdbe38.png"></p>
<p>三次握手是建立连接的，目的是解决网络信道不可靠的问题。</p>
<p><img src="https://pic1.imgdb.cn/item/67a95118d0e0a243d4fdbe42.png"></p>
<h2 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h2><p><img src="https://pic1.imgdb.cn/item/67a951e6d0e0a243d4fdbe4a.png"></p>
<h2 id="拆包和粘包"><a href="#拆包和粘包" class="headerlink" title="拆包和粘包"></a>拆包和粘包</h2><p>拆包：</p>
<p>把一个完整的数据包拆分成多个小包发送给您</p>
<p>粘包：</p>
<p>把多个数据包粘合在一起发送</p>
<p>拆包和粘包现象，是TCP协议的数据传输机制导致的。</p>
<p>添加特殊字符来表示数据包的开始和结束。</p>
<p>通过自定义消息协议，并在协议头中保存数据包的长度信息。</p>
<p>基于定长消息，发送端的消息长度是固定的，服务端按照固定长度来解析。</p>
<h2 id="TCP的拥塞控制步骤"><a href="#TCP的拥塞控制步骤" class="headerlink" title="TCP的拥塞控制步骤"></a>TCP的拥塞控制步骤</h2><p>当每个发送方都以过快的速度发送给您数据，导致数据在传输中无法缓存，导致拥塞，导致大量数据包丢失。</p>
<p>出现超时时，网络阻塞。</p>
<p>TCP拥塞控制</p>
<p>拥塞控制流程: </p>
<p>tcp拥塞]算法共有4种：慢开始、拥塞避免、快重传、快恢复 </p>
<p>慢开始发生在最开始，这个时候不断试探网络是否把握的住，拥塞窗口(cwnd)以n²的增速开始增长，然后到了设置的阈值，我们就采取拥塞避免的算法每次加一的试探网络，当然后面肯定避免不了超时，我们这时候阈值设为当前阈值的一半，我们重新开始慢开始，到达现在的阈值开始拥塞避免。快重传（然后接收器接收到一个不按顺序的数据段，接收器会立马给发送器发送重复确认，如果发送机接收到三个重复确认，它会假定确认件支出的数据段丢失了。)然后开始快回复，在当前cwnd下的一半重新开始传输</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/04/%E5%B9%B6%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/02/04/%E5%B9%B6%E5%8F%91/" class="post-title-link" itemprop="url">并发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-02-04 19:21:39" itemprop="dateCreated datePublished" datetime="2025-02-04T19:21:39+08:00">2025-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-10 18:25:03" itemprop="dateModified" datetime="2025-03-10T18:25:03+08:00">2025-03-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h1><p>不错的并发知识：<a target="_blank" rel="noopener" href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2078%20%e8%ae%b2-%e5%ae%8c/01%20%e4%b8%ba%e4%bd%95%e8%af%b4%e5%8f%aa%e6%9c%89%201%20%e7%a7%8d%e5%ae%9e%e7%8e%b0%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%96%b9%e6%b3%95%ef%bc%9f.md">https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%2078%20%e8%ae%b2-%e5%ae%8c/01%20%e4%b8%ba%e4%bd%95%e8%af%b4%e5%8f%aa%e6%9c%89%201%20%e7%a7%8d%e5%ae%9e%e7%8e%b0%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%96%b9%e6%b3%95%ef%bc%9f.md</a></p>
<h2 id="Java天生的多线程"><a href="#Java天生的多线程" class="headerlink" title="Java天生的多线程"></a>Java天生的多线程</h2><ul>
<li>main 主线程</li>
<li>Reference Handler （引用处理的线程，强，软，弱，虚，-GC 有不同表现， -JVM深入分析）</li>
<li>Attach Listener（附加监听器。简单来说，他是jdk里边一个工具类提供的jvm进程间通信的工具。 cmd –java -version； jvm –jstack，jmp，dump）进程间的通讯）</li>
<li>Signal Dispatcher（信号分发器，我们通过cmd发送jstask，传入了jvm进程中这时候信号分发器就要发挥作用了。</li>
<li>Monitor Ctrl-Break</li>
<li>Finalizer（JVM垃圾回收相关内容，此处只做简单的介绍，只有当开始一轮垃圾收集的时候，才会开始调用finalize方法。jvm在垃圾收集的时候，会将是去引用的对象封装到Finalizer对象（Reference），放入到我们的F-queue队列中。由Finalizer现成执行inalize方法）</li>
</ul>
<h2 id="线程的优先级和守护线程"><a href="#线程的优先级和守护线程" class="headerlink" title="线程的优先级和守护线程"></a>线程的优先级和守护线程</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1-10，在线程构建的时候可以通过<code>setPriority（int）</code>方法来修改优先级，默认优先级是5，<strong>优先级高的线程分配CPU时间片的数量要多余优先级低的线程。</strong></p>
<h2 id="什么是Java中的线程同步？"><a href="#什么是Java中的线程同步？" class="headerlink" title="什么是Java中的线程同步？"></a>什么是Java中的线程同步？</h2><p><strong>线程同步</strong>是指在多项成环境下，为了避免多个线程对共享资源进行同时访问，从而引发的数据不一致问题或其他问题的一种机制。通过对关键代码段加锁，使得同一时刻只有一个线程可以访问共享资源。</p>
<p>当多个线程共享同一资源（如变量、对象或文件）是，若没有同步机制，可能导致 <strong>竞态条件</strong> ，线程对共享资源的操作是非原子性的，多个现成之间可能导致同时修改数据，导致结果不符合预期。</p>
<h2 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h2><p>**线程安全 **是指多个线程访问某一共享资源时，能够保证一致性和正确性，即无论线程如何交替执行，程序都能够产生预期的结果，且不会出现数据竞争或内存冲突。在Java中，线程安全的实现通常依赖于同步机制和线程隔离技术。</p>
<p><strong>常用的线程安全措施</strong></p>
<ul>
<li><strong>同步锁</strong>： 通过 <code>synchronized</code> 和 <code>ReentrantLock</code> 实现对共享资源的同步控制。</li>
<li><strong>原子操作类</strong>： Java提供的 <code>AtomicInteger</code> 和 <code>AtomicReference</code> 等类确保多线程环境下的原子操作。</li>
<li><strong>线程安全容器</strong>： 如 <code>ConcurrentHashMap</code> 和 <code>CopyOnWriteArrayList</code> 等，避免手动加锁。</li>
<li><strong>局部变量</strong>： 线程内独立的局部变量天然是线程安全的，因为每个线程都有自己的栈空间（线程隔离）</li>
<li><strong>ThreadLocal：</strong> 类似于局部变量，属于线程本地资源，通过线程隔离保证了线程安全。</li>
</ul>
<h2 id="什么是协程？Java支持协程吗？"><a href="#什么是协程？Java支持协程吗？" class="headerlink" title="什么是协程？Java支持协程吗？"></a>什么是协程？Java支持协程吗？</h2><p>说明：</p>
<p><strong>协程：</strong> （Coroutine) 是一种轻量级的线程，它允许在执行中暂停并在之后恢复执行，而无需阻塞队列。与线程相比，协程就是 <strong>用户态调度</strong> ，效率更高，因为它不涉及操作系统的内核调度。</p>
<p>Java一开始没有原生支持的协程，但在Java19中通过Project Loom 引入了虚拟线程，最终在Java21确认。</p>
<h2 id="在Java中线程的生命周期如何定义"><a href="#在Java中线程的生命周期如何定义" class="headerlink" title="在Java中线程的生命周期如何定义"></a>在Java中线程的生命周期如何定义</h2><p>在Java中，线程的生命周期可以分为以下几个状态：</p>
<ul>
<li><strong>New（初始状态）：</strong> 线程对象创建后，但未调用start（）方法。</li>
<li><strong>Runable(可运行状态）：</strong> 调用start（）方法后，线程进入就绪状态，等待CPU调度。</li>
<li><strong>Blocked(阻塞状态）:</strong> 线程试图获取一个对象锁而被阻塞。</li>
<li><strong>Waiting（等待状态）：</strong> 线程进入等待状态，需要被显式唤醒才能继续执行。</li>
<li><strong>Timed Waiting（含等待时间的等待状态）：</strong> 线程进入等待状态，但指定了等待时间，超时后会被唤醒。</li>
<li><strong>Terminated（终止状态）：</strong> 线程执行完成后或因异常退出。</li>
</ul>
<p>操作系统中线程的生命周期：</p>
<ul>
<li>新建（New）： 线程对象被创建，但尚未启动。</li>
<li>就绪（Runnable）： 线程被启动，处于可运行状态，等待CPU调度执行。</li>
<li>运行（Running)： 线程获取CPU资源， 开始执行run（）方法中的代码。</li>
<li>阻塞（Blocked）： 线程因为某些操作（如等待锁、IO锁操作）被阻塞，暂时停止执行。</li>
<li>终止（Terminated): 线程执行完成或因异常退出后，生命周期结束。</li>
</ul>
<h2 id="线程之间如何进行通讯？"><a href="#线程之间如何进行通讯？" class="headerlink" title="线程之间如何进行通讯？"></a>线程之间如何进行通讯？</h2><p>在Java中，线程之间的通信是指 <strong>多个线程协同工作</strong>， 主要实现方式包括：</p>
<p><strong>1. 共享变量</strong></p>
<ul>
<li>线程可以通过访问共享内存变量来交换信息（需要注意同步问题，防止数据竞争和不一致）</li>
<li>共享也可以是文件，例如写入同一个文件来进行通信。</li>
</ul>
<p><strong>2. 同步机制：</strong></p>
<ul>
<li>synchronized：Java中的同步关键字，用于确保同一时刻只有一个线程可以访问共享资源，利用Object类提供的<code>wait(),notify(),notifyAll()</code> 实现线程之间的等待、通知机制。</li>
<li>ReentrantLock： 配置Condition提供了类似于wait(),notify()的等待、通知。</li>
<li>BlockingQueue: 通过阻塞队列实现生产者-消费者模式</li>
<li>CountDownLatch：可以允许一个或多个线程等待，直到在其他线程中执行一组操作完成</li>
<li>Cyclicbarrier：可以让一组线程互相等待，直到达到某个公共屏障点。</li>
<li>Volatile： Java中的关键字，确保变量的可加性，防止指令重排。</li>
<li>Semaphore：信号量，可以控制对特定资源的访问线程数。</li>
</ul>
<h2 id="Synchronized-和-ReentrantLock的区别？"><a href="#Synchronized-和-ReentrantLock的区别？" class="headerlink" title="Synchronized 和 ReentrantLock的区别？"></a>Synchronized 和 ReentrantLock的区别？</h2><blockquote>
<p>注意： 有时候会看到Synchroized时Lock对比，实际上 ReentrantLock实现了Lock接口。</p>
</blockquote>
<p>两者的<strong>共同特点</strong>：</p>
<ul>
<li>都是用来协调多线程对共享对象、变量的访问。</li>
<li>都是可重入锁，同一线程可以多次获得同一个锁</li>
<li>都保证了可见性和互斥性。</li>
</ul>
<p>两者的<strong>不同特点</strong>：</p>
<ul>
<li>ReentrantLock显示的获得、释放锁（需要手动控制），synchronized隐式获得锁释放。</li>
<li>ReentrantLock可影响中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性。</li>
<li>ReentrantLock是API级别的（需要写代码实现）， synchronized 是JVM级别的（内置）</li>
<li>ReentrantLock可以实现公平锁和， synchronized就是一个非公平锁。</li>
<li>ReentrantLock通过Condition可以绑定多个条件。</li>
<li>底层实现不同，synchronized 是同步阻塞，   使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略。</li>
<li>Lock是一个接口，而sychronized是Java中的关键字，由内置语言实现。</li>
<li>synchronized发生异常是，会自动释放线程占有的锁，因此不会导致死锁现象发生。而Lock在发生异常时，如果没有主动通过unLock() 去释放锁，则很可能造成死锁现象，因此使用lock是需要在finally快中释放锁。</li>
<li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能响应中断。</li>
<li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到</li>
<li>Lock可以提高多个线程进行读操作的效率，即就是<strong>实现读写锁</strong>等。（分为独占锁和共享锁）</li>
</ul>
<h3 id="既然ReentrantLock-功能那么全，为什么还要用Synchronized呢？"><a href="#既然ReentrantLock-功能那么全，为什么还要用Synchronized呢？" class="headerlink" title="既然ReentrantLock 功能那么全，为什么还要用Synchronized呢？"></a>既然ReentrantLock 功能那么全，为什么还要用Synchronized呢？</h3><p>尽管 <code>ReentrantLock</code> 提供了更多功能和灵活性，<code>synchronized</code> 仍然被广泛使用，原因如下：</p>
<ol>
<li><strong>简洁性</strong>：<ul>
<li><code>synchronized</code> 语法简单，自动管理锁的获取和释放，减少了代码复杂度。</li>
<li><code>ReentrantLock</code> 需要显式地加锁和解锁，增加了代码的复杂性和出错风险。</li>
</ul>
</li>
<li><strong>内置支持</strong>：<ul>
<li><code>synchronized</code> 是 Java 语言的一部分，无需额外导入。</li>
<li><code>ReentrantLock</code> 属于 <code>java.util.concurrent</code> 包，需要显式导入。</li>
</ul>
</li>
<li><strong>自动释放锁</strong>：<ul>
<li><code>synchronized</code> 在代码块或方法执行结束后自动释放锁，避免忘记解锁。</li>
<li><code>ReentrantLock</code> 必须手动调用 <code>unlock()</code>，否则可能导致死锁。</li>
</ul>
</li>
<li><strong>性能差异</strong>：<ul>
<li>在 Java 6 及以后版本中，<code>synchronized</code> 经过优化，性能与 <code>ReentrantLock</code> 相当，甚至在某些场景下更优。</li>
<li>只有在高并发场景下，<code>ReentrantLock</code> 的高级功能（如可中断锁、公平锁等）才能体现出优势。</li>
</ul>
</li>
<li><strong>调试和监控</strong>：<ul>
<li><code>synchronized</code> 与 JVM 的监控工具（如 JConsole、VisualVM）集成更好，便于调试。</li>
<li><code>ReentrantLock</code> 的调试和监控相对复杂。</li>
</ul>
</li>
<li><strong>兼容性</strong>：<ul>
<li><code>synchronized</code> 自 Java 1.0 引入，兼容所有 Java 版本。</li>
<li><code>ReentrantLock</code> 在 Java 5 中引入，不适用于早期版本。</li>
</ul>
</li>
<li><strong>默认行为</strong>：<ul>
<li><code>synchronized</code> 的默认行为（如非公平锁）适合大多数场景。</li>
<li><code>ReentrantLock</code> 提供了更多选项（如公平锁），但这些功能在大多数情况下并非必需。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**<code>synchronized</code>**：适合大多数场景，简洁、易用、性能良好。</li>
<li>**<code>ReentrantLock</code>**：适合需要高级功能（如可中断锁、公平锁等）的高并发场景。</li>
</ul>
<p>因此，<code>synchronized</code> 仍然是许多场景下的首选，而 <code>ReentrantLock</code> 则用于需要更复杂控制的场合。</p>
<h2 id="Condition和Object类锁方法的区别"><a href="#Condition和Object类锁方法的区别" class="headerlink" title="Condition和Object类锁方法的区别"></a>Condition和Object类锁方法的区别</h2><ul>
<li>Condition 类的 awiat 方法和 Object 类的 wait 方法等效</li>
<li>Condition 类的 signal 方法和 Object 类的 notify 方法等效</li>
<li>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效</li>
<li>ReentrantLock 类可以唤醒指定条件的线程，而Object唤醒是随机的。</li>
</ul>
<h2 id="如何创建多线程"><a href="#如何创建多线程" class="headerlink" title="如何创建多线程"></a>如何创建多线程</h2><p><strong>1. 实现Runnable接口</strong></p>
<ul>
<li>实现Runnable接口的 <code>run()</code>方法，使用构造器Thread类的构造函数传入<code>Runnbale</code> 对象，调用<code>start()</code> 方法启动线程。（这个是没有返回值的）</li>
</ul>
<p><strong>2. 继承Thread类</strong></p>
<ul>
<li>继承Thread类并重写<code>run()</code>方法，直接创建<code>Thread</code> 子类并调用<code>start（）</code> 方法启动线程。</li>
</ul>
<p><strong>3. 使用Callable和FutureTask</strong></p>
<ul>
<li><p>实现 Callable 接口的 call方法，使用FutureTask包装Callable对象，在通过Thread方法启动（有返回值）</p>
</li>
<li><p>实例：</p>
<img src="https://pic1.imgdb.cn/item/67cbb7d3066befcec6e0aba9.png" alt="image.png"></li>
</ul>
<p><strong>4. 使用线程池(ExecutorService)</strong></p>
<ul>
<li><p>通过 <code>ExecutorService</code> 提交 <code>Runnable</code> 或 <code>Callable</code>任务，不直接创建和管理线程，适合大量并发任务。</p>
<img src="https://pic1.imgdb.cn/item/67cbb84e066befcec6e0acc7.png" alt="image.png"></li>
</ul>
<p><strong>5. CompletableFuture（本质也是线程池，默认forkjoinpool)</strong></p>
<ul>
<li>Java8引入的功能，非常方便地进行异步任务调度，通过<code>thenApply、thenAccept</code> 等方法可以轻松的处理异步任务之间的依赖关系。</li>
</ul>
<img src="https://pic1.imgdb.cn/item/67cbb8e4066befcec6e0ad8d.png" alt="image.png">

<blockquote>
<p>注意：本质上只有一种，就是Thread来创建，其他的都是对Thread做了一个封装。</p>
</blockquote>
<p><strong>线程池的优势</strong></p>
<ul>
<li>使用线程池可以有效的管理和重用线程，避免频繁创建和销毁线程带来的开销。常用的线程池<code>FixedThreadPool</code>、<code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></li>
</ul>
<p> <strong>FixedThreadPool</strong></p>
<ul>
<li><strong>适用场景</strong>：任务数量已知且相对稳定，且任务执行时间较长。</li>
<li><strong>特点</strong>：线程池大小固定，不会动态调整。</li>
<li><strong>优点</strong>：资源消耗可控，适合负载较重的场景。</li>
<li><strong>缺点</strong>：如果任务数量突然增加，可能会导致任务积压。</li>
</ul>
<p><strong>CachedThreadPool</strong></p>
<ul>
<li><strong>适用场景</strong>：任务数量不确定，且任务执行时间较短。</li>
<li><strong>特点</strong>：线程池大小不固定，会根据任务数量动态调整。</li>
<li><strong>优点</strong>：适合处理大量短时任务，资源利用率高。</li>
<li><strong>缺点</strong>：如果任务数量过多，可能会创建大量线程，导致资源耗尽。</li>
</ul>
<p><strong>ScheduledThreadPool</strong></p>
<ul>
<li><strong>适用场景</strong>：需要定期执行任务或延迟执行任务。</li>
<li><strong>特点</strong>：支持定时任务和周期性任务。</li>
<li><strong>优点</strong>：适合需要调度任务的场景。</li>
<li><strong>缺点</strong>：不适合处理大量短时任务。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><strong>FixedThreadPool</strong>：适合任务数量稳定且执行时间较长的场景。</li>
<li><strong>CachedThreadPool</strong>：适合任务数量不确定且执行时间较短的场景。</li>
<li><strong>ScheduledThreadPool</strong>：适合需要定时或周期性执行任务的场景。</li>
</ul>
<h2 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h2><p><strong>当前一个满的情况下，会执行后一个</strong></p>
<p>核心线程池 -》 工作队列 -》 新开线程 -》 拒绝策略</p>
<p>线程池的参数：</p>
<ul>
<li>corePoolSize ： 核心线程数</li>
<li>maximumPoolSize: 最大线程数</li>
<li>workQueue： 工作队列</li>
<li>keepAliveTime： 回收线程时间</li>
<li>threadFactory： 线程工厂，表示怎么创建线程</li>
<li>Rejected： 这个接口是实现拒绝策略的，表示都满了的拒绝。</li>
</ul>
<p><img src="https://pic1.imgdb.cn/item/67a2b8edd0e0a243d4fbdbaa.png"></p>
<p>poll： 假如queue为空，并且允许关闭核心线程数 或者 我当前的线程树大于核心线程数， 回收。（或超时）</p>
<p>take： 否则， 阻塞在take中，等待queue里面的task。（自旋）</p>
<p><strong>整体结构图</strong></p>
<p><img src="https://pic1.imgdb.cn/item/67a2bbe7d0e0a243d4fbdcf7.png"></p>
<h2 id="如何合理设置线程池"><a href="#如何合理设置线程池" class="headerlink" title="如何合理设置线程池"></a>如何合理设置线程池</h2><h4 id="选择原则："><a href="#选择原则：" class="headerlink" title="选择原则："></a>选择原则：</h4><ul>
<li><strong>CPU 密集型任务</strong>：任务主要消耗 CPU 资源（如计算、逻辑处理）。<ul>
<li>核心线程数通常设置为 <strong>CPU 核心数 + 1</strong>。</li>
<li>例如，4 核 CPU 可以设置为 5。</li>
<li>过多的线程会导致频繁的上下文切换，反而降低性能。</li>
</ul>
</li>
<li><strong>IO 密集型任务</strong>：任务主要消耗 IO 资源（如文件读写、网络请求、数据库操作）。<ul>
<li>核心线程数可以设置为 <strong>CPU 核心数 × 2</strong> 或更高。</li>
<li>因为 IO 操作会阻塞线程，增加线程数可以提高 CPU 利用率。</li>
</ul>
</li>
<li><strong>混合型任务</strong>：既有 CPU 密集型任务，也有 IO 密集型任务。<ul>
<li>可以根据任务的比例动态调整，或者通过性能测试来确定最佳值。</li>
</ul>
</li>
</ul>
<h2 id="Java中有哪些拒绝策略"><a href="#Java中有哪些拒绝策略" class="headerlink" title="Java中有哪些拒绝策略"></a>Java中有哪些拒绝策略</h2><p>一共有4种：</p>
<ul>
<li><strong>AbortPolicy</strong>：当任务队列满且没有线程空闲，此时添加任务会直接抛出 <code>RejectedExecutionException</code> 错误，这也是默认的拒绝策略，适合于必须通知调用者任务未能被执行。（abort 放弃）</li>
<li><strong>CallerRunsPolicy：</strong> 当任务队列满没有空闲空间，此时添加任务由即调用者线程执行。适用于希望通过减缓任务提交速度来稳定系统的场景（Caller调用）</li>
<li><strong>DiscardOldestPolicy:</strong>  当任务队列满且没有线程空闲，会删除最早的任务，然后重新提交当前任务。适用于希望丢弃最旧的任务以保证新的重要任务能够被处理的场景。</li>
<li><strong>DiscardPolicy</strong>： 直接丢弃当前任务，不会执行任何操作，也不会抛出异常。适用于对部分任务丢弃没有影响的场景，或系统负载较高时不需要处理所有任务。</li>
</ul>
<h2 id="Java-并发库中提供了哪些线程池实现？他们有什么区别？"><a href="#Java-并发库中提供了哪些线程池实现？他们有什么区别？" class="headerlink" title="Java 并发库中提供了哪些线程池实现？他们有什么区别？"></a>Java 并发库中提供了哪些线程池实现？他们有什么区别？</h2><p><strong>1. FixedThreadPool：</strong> 创建一个固定数量的线程池。</p>
<p>线程池中的线程数是固定的，空闲的线程会被复用。如果所有线程都在忙，则新任务会放入队列中等待。</p>
<p>适合负载稳定的场景，任务数量确定且不需要动态调整线程数。（fixed 固定的）</p>
<p><strong>2. CachedThreadPool：</strong>一个可以根据需要创建新线程的线程池。</p>
<p>线程池的线程数量没有上限，空闲线程会在60秒后被回收，如果有新任务且没有可用线程，会创建线程。</p>
<p>适合短期大量并发场景，任务执行时间短且线程数需求变化较大。（Cached 缓存）</p>
<p><strong>3. SingleThreadExecutor：</strong> 创建一个只有单个线程的线程池。</p>
<p>只有一个线程处理任务，任务会按照提交顺序一次执行。</p>
<p>适用于需要保证任务按顺序执行的场景，或者不需要并发处理任务的情况。</p>
<p><strong>4. ScheduledThreadPool：</strong> 支持定时任务和周期性任务的线程池。</p>
<p>可以定时或以固定频率执行任务，线程池大小可以由用户指定。</p>
<p>适用于需要周期性任务执行的场景，如定时任务调度。</p>
<p><strong>5. WorkStealingPool:</strong> 基于任务窃取算法的线程池</p>
<p>线程池中的每个线程维护着一个双端队里（deque），线程可以从自己的队列中去任务队列执行，如果线程的任务队列为空，它可以从其他线程的队列中”窃取” 任务来执行，达到负载均衡的效果。</p>
<p>适合大量小任务并行执行，特别是递归算法或大任务分解成小任务。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-11 20:32:19" itemprop="dateCreated datePublished" datetime="2025-01-11T20:32:19+08:00">2025-01-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/06/%E5%AD%98%E5%82%A8%E5%9B%BE%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/06/%E5%AD%98%E5%82%A8%E5%9B%BE%E7%89%87/" class="post-title-link" itemprop="url">存储图片</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-06 21:11:42" itemprop="dateCreated datePublished" datetime="2025-01-06T21:11:42+08:00">2025-01-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/06/%E5%9C%BA%E6%99%AF%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/06/%E5%9C%BA%E6%99%AF%E9%A2%98/" class="post-title-link" itemprop="url">场景题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-01-06 19:07:24 / 修改时间：23:47:29" itemprop="dateCreated datePublished" datetime="2025-01-06T19:07:24+08:00">2025-01-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="一笔订单在取消的那一刻付款了，怎么办？"><a href="#一笔订单在取消的那一刻付款了，怎么办？" class="headerlink" title="一笔订单在取消的那一刻付款了，怎么办？"></a>一笔订单在取消的那一刻付款了，怎么办？</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/05/java%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/05/java%E9%9D%A2%E8%AF%95/" class="post-title-link" itemprop="url">java面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-05 23:28:38" itemprop="dateCreated datePublished" datetime="2025-01-05T23:28:38+08:00">2025-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-09 08:21:11" itemprop="dateModified" datetime="2025-02-09T08:21:11+08:00">2025-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">面试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java面试"><a href="#Java面试" class="headerlink" title="Java面试"></a>Java面试</h1><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="java中的序列化和反序列化是什么？"><a href="#java中的序列化和反序列化是什么？" class="headerlink" title="java中的序列化和反序列化是什么？"></a>java中的序列化和反序列化是什么？</h3><p><strong>序列化：</strong></p>
<p>序列化是指将数据结构或对象状态转换成可以存储或传输的格式的过程。这个格式通常是和平台无关的，比如JSON,XML,二进制格式等，以便可以在不同的系统或环境中进行交换。序列化后的数据可以存储在文件中，或者通过网络发送给其他系统。</p>
<p><strong>为什么要序列化</strong></p>
<ul>
<li><strong>数据持久化</strong>：将对象状态保存到文件中，以便在程序关闭或系统重启后能够重新加载这些数据。</li>
<li><strong>网络传输</strong>：在网络通信中，数据需要在客户端和服务端之间传输，序列化可以将对象转换成字节流，便于在网络中传输。</li>
<li><strong>对象深拷贝</strong>：通过序列化一个对象，然后立即进行反序列化，可以实现对象的深拷贝。</li>
</ul>
<p><strong>反序列化：</strong></p>
<p>反序列化是序列化的逆过程，即将序列化后的数据（如JSON,XML,二进制格式等）转换回原始的数据结构或对象状态。这个过程允许对象在需要时重新构建对象，并使用其原始数据。</p>
<p><strong>为什么要反序列化</strong></p>
<ul>
<li><strong>数据恢复</strong>：在程序启动时，从文件中读取序列化后的数据，反序列化成对象，以恢复程序运行前的状态。</li>
<li><strong>数据接收</strong>：在网络通信中，接收到的序列化数据需要被反序列化成对象，以便在本地系统中使用。</li>
</ul>
<h3 id="什么是不可变类？"><a href="#什么是不可变类？" class="headerlink" title="什么是不可变类？"></a>什么是不可变类？</h3><p><strong>不可变类</strong>：所谓的不可变类是指这个类的实例一旦创建完成后，就不能改变其成员变量值。如JDK内部自带的很多不可变类：Interger、Long和String等。</p>
<p>优点：线程安全</p>
<p><strong>设计方法</strong></p>
<p><strong>1. 类添加final修饰符，保证类不被继承</strong>。</p>
<p><strong>2. 保证所有成员变量必须私有，并且加上final修饰</strong></p>
<p><strong>3. 不提供改变成员变量的方法，包括setter</strong></p>
<p><strong>4.通过构造器初始化所有成员，进行深拷贝(deep copy)</strong></p>
<p><strong>5. 在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝</strong></p>
<h3 id="Exception-和-Error有什么区别？"><a href="#Exception-和-Error有什么区别？" class="headerlink" title="Exception 和 Error有什么区别？"></a>Exception 和 Error有什么区别？</h3><p><strong>‌Exception‌</strong>：Exception是程序运行中可以预见的异常情况，通常是由于程序设计或外部输入错误引起的。它们可以被捕获和处理，程序可以继续运行或给出错误提示。<br><strong>‌Error‌</strong>：Error是程序运行中不可预见的严重错误，通常是由于系统资源不足、硬件故障等引起的。这些错误通常会导致JVM崩溃，无法恢复，因此无法捕获和处理‌。</p>
<h3 id="什么是Java的多态特性？"><a href="#什么是Java的多态特性？" class="headerlink" title="什么是Java的多态特性？"></a>什么是Java的多态特性？</h3><p>Java多态是面向对象编程的一个重要特性，它允许不同的对象对同一消息做出不同的响应。具体点就是不同的对象去完成相同的一个任务完成后展现的结果不相同</p>
<p>多态 多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：多态性是对象多种表现形式的体现</p>
<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="Java中的参数传递是按值传递还是按引用？"><a href="#Java中的参数传递是按值传递还是按引用？" class="headerlink" title="Java中的参数传递是按值传递还是按引用？"></a>Java中的参数传递是按值传递还是按引用？</h3><p>按值传递</p>
<h3 id="为什么Java不支持多重继承？"><a href="#为什么Java不支持多重继承？" class="headerlink" title="为什么Java不支持多重继承？"></a>为什么Java不支持多重继承？</h3><p>可能会出现菱形问题，简化了继承链，避免了多重继承带来的冲突。接口作为了多重继承的替代方案。</p>
<h3 id="JDK8-的新特性？"><a href="#JDK8-的新特性？" class="headerlink" title="JDK8 的新特性？"></a>JDK8 的新特性？</h3><ol>
<li><p>Lambda表达式</p>
</li>
<li><p>函数式接口（仅包含一个抽象方法的接口，配合Lambda隐式调用）</p>
</li>
<li><p>StreamAPI（处理集合流）</p>
<h2 id="3-Stream-API"><a href="#3-Stream-API" class="headerlink" title="3. Stream API"></a>3. <strong>Stream API</strong></h2><p>Stream API 是 JDK 8 中的另一个重要特性，它为 Java 提供了一种声明式的方式来处理集合数据。通过 Stream API，开发者可以轻松地进行过滤、映射、排序、聚合等操作，且支持串行和并行流处理。</p>
<h3 id="3-1-创建-Stream"><a href="#3-1-创建-Stream" class="headerlink" title="3.1 创建 Stream"></a>3.1 创建 Stream</h3><p>Stream 可以从集合、数组、I&#x2F;O 通道等<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=251898554&content_type=Article&match_order=1&q=%E6%95%B0%E6%8D%AE%E6%BA%90&zhida_source=entity">数据源</a>中创建。以下是一些常见的创建 Stream 的方式：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 从集合中创建 Stream</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;);</span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">// 从数组中创建 Stream</span><br><span class="line">String[] array = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;;</span><br><span class="line">Stream&lt;String&gt; stream2 = Arrays.stream(array);</span><br><span class="line"></span><br><span class="line">// 使用 Stream.of() 创建</span><br><span class="line">Stream&lt;String&gt; stream3 = Stream.of(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-常见的-Stream-操作"><a href="#3-2-常见的-Stream-操作" class="headerlink" title="3.2 常见的 Stream 操作"></a>3.2 常见的 Stream 操作</h3><p>Stream API 提供了多种操作方法，这些方法可以分为 <strong>中间操作</strong> 和 <strong>终止操作</strong>。</p>
<h3 id="3-2-1-中间操作"><a href="#3-2-1-中间操作" class="headerlink" title="3.2.1 中间操作"></a>3.2.1 中间操作</h3><p>中间操作会返回一个新的 Stream，可以链式调用。常见的中间操作有：</p>
<ul>
<li><code>filter</code>：过滤元素</li>
<li><code>map</code>：将每个元素转换为另一个对象</li>
<li><code>flatMap</code>：将元素转换为多个元素（扁平化）</li>
<li><code>sorted</code>：排序</li>
</ul>
<h3 id="3-2-2-终止操作"><a href="#3-2-2-终止操作" class="headerlink" title="3.2.2 终止操作"></a>3.2.2 终止操作</h3><p>终止操作会触发 Stream 的计算，并返回一个结果。常见的终止操作有：</p>
<ul>
<li><code>collect</code>：将 Stream 转换为集合或其他类型</li>
<li><code>forEach</code>：遍历每个元素</li>
<li><code>reduce</code>：通过给定的二元<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=251898554&content_type=Article&match_order=1&q=%E6%93%8D%E4%BD%9C%E7%AC%A6&zhida_source=entity">操作符</a>将 Stream 中的元素合并为一个结果</li>
<li><code>count</code>：计算元素的数量</li>
<li><code>findFirst</code>：获取 Stream 中的第一个元素</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;);</span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(&quot;a&quot;))</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .forEach(System.out::println); // 输出 &quot;APPLE&quot;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-并行流处理"><a href="#3-3-并行流处理" class="headerlink" title="3.3 并行流处理"></a>3.3 并行流处理</h3><p>Stream API 支持<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=251898554&content_type=Article&match_order=3&q=%E5%B9%B6%E8%A1%8C%E6%B5%81&zhida_source=entity">并行流</a>，可以更高效地处理大量数据。通过调用 <code>parallelStream()</code> 或 <code>stream.parallel()</code>，可以轻松地将串行操作转换为并行操作：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.parallelStream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(&quot;a&quot;))</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>并行流利用多核处理器来提高性能，特别适合进行大规模数据处理。</p>
</li>
<li><p>新日期时间</p>
</li>
<li><p>默认方法</p>
</li>
<li><p>Optional</p>
</li>
<li><p>新的并发API</p>
</li>
</ol>
<h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="String-StringBuffer-StringBuilder区别？"><a href="#String-StringBuffer-StringBuilder区别？" class="headerlink" title="String, StringBuffer, StringBuilder区别？"></a>String, StringBuffer, StringBuilder区别？</h3><h3 id="StringBuilder-的实现原理？"><a href="#StringBuilder-的实现原理？" class="headerlink" title="StringBuilder 的实现原理？"></a>StringBuilder 的实现原理？</h3><h3 id="包装类和基本类型的区别是什么？"><a href="#包装类和基本类型的区别是什么？" class="headerlink" title="包装类和基本类型的区别是什么？"></a>包装类和基本类型的区别是什么？</h3><h3 id="接口和抽象类有什么区别？"><a href="#接口和抽象类有什么区别？" class="headerlink" title="接口和抽象类有什么区别？"></a>接口和抽象类有什么区别？</h3><h3 id="JDK和JRE有什么区别？"><a href="#JDK和JRE有什么区别？" class="headerlink" title="JDK和JRE有什么区别？"></a>JDK和JRE有什么区别？</h3><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><h3 id="Java中hashCode和equea方法是什么？它们与-符号有什么区别？"><a href="#Java中hashCode和equea方法是什么？它们与-符号有什么区别？" class="headerlink" title="Java中hashCode和equea方法是什么？它们与&#x3D;&#x3D;符号有什么区别？"></a>Java中hashCode和equea方法是什么？它们与&#x3D;&#x3D;符号有什么区别？</h3><h3 id="Java中的hashCode和equals方法之间有什么关系？"><a href="#Java中的hashCode和equals方法之间有什么关系？" class="headerlink" title="Java中的hashCode和equals方法之间有什么关系？"></a>Java中的hashCode和equals方法之间有什么关系？</h3><h3 id="java中的动态代理？"><a href="#java中的动态代理？" class="headerlink" title="java中的动态代理？"></a>java中的动态代理？</h3><h3 id="JDk动态代理和CGLIB动态代理有什么区别"><a href="#JDk动态代理和CGLIB动态代理有什么区别" class="headerlink" title="JDk动态代理和CGLIB动态代理有什么区别?"></a>JDk动态代理和CGLIB动态代理有什么区别?</h3><h3 id="Java中注解的原理是什么？"><a href="#Java中注解的原理是什么？" class="headerlink" title="Java中注解的原理是什么？"></a>Java中注解的原理是什么？</h3><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><h3 id="Java的反射机制吗？如何应用反射？"><a href="#Java的反射机制吗？如何应用反射？" class="headerlink" title="Java的反射机制吗？如何应用反射？"></a>Java的反射机制吗？如何应用反射？</h3><h3 id="Java中泛型的作用？"><a href="#Java中泛型的作用？" class="headerlink" title="Java中泛型的作用？"></a>Java中泛型的作用？</h3><h3 id="泛型擦除是什么？"><a href="#泛型擦除是什么？" class="headerlink" title="泛型擦除是什么？"></a>泛型擦除是什么？</h3><h3 id="什么是java泛型的上下限定符？"><a href="#什么是java泛型的上下限定符？" class="headerlink" title="什么是java泛型的上下限定符？"></a>什么是java泛型的上下限定符？</h3><h3 id="Java中的深拷贝和浅拷贝？"><a href="#Java中的深拷贝和浅拷贝？" class="headerlink" title="Java中的深拷贝和浅拷贝？"></a>Java中的深拷贝和浅拷贝？</h3><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="接口类和抽象类有什么区别？"><a href="#接口类和抽象类有什么区别？" class="headerlink" title="接口类和抽象类有什么区别？"></a>接口类和抽象类有什么区别？</h3><p><strong>1. 抽象类</strong></p>
<p>抽象类是一种特殊的类，通常是作为其他类的基类，提供了公共的属性和方法，允许子类根据需求进行扩展。</p>
<p><strong>1.1 特性</strong></p>
<ul>
<li>包含抽象方法： 必须在子类中实现</li>
<li>包含具体方法： 可以直接被子类继承。</li>
<li>包含成员变量</li>
<li>有构造函数</li>
<li>单继承</li>
</ul>
<p><strong>2. 接口</strong></p>
<p>接口是一种特殊的引用类型，它是方法声明的集合，接口中的方法都是抽象的，即没有具体的实现。接口主要用于定义一组方法，这些方法必须由实现接口的类进行实现。</p>
<p><strong>2.1 特性</strong></p>
<ul>
<li>抽象方法：接口中默认是抽象方法，需要接口类实现</li>
<li>常量： 通常 <code>public static final</code> 进行修饰</li>
<li>默认方法和静态方法： 从Java8开始，接口可以包含默认方法（使用default进行修饰）和静态方法（static）。默认方法提供了接口实现，而静态方法只与接口关联，不与接口类的实现关联。</li>
<li>多实现： 一个类可以实现多个接口</li>
<li>不包含成员变量</li>
<li>不能包含构造方法</li>
</ul>
<p><strong>3. 场景</strong></p>
<p>抽象类： 是自下而上的，提取类的公共特性抽象出一个公有的父类。</p>
<p>接口类： 是自上而下的，先定义接口，让后让类实现这些接口。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="JDk动态代理和CGLIB动态代理的区别"><a href="#JDk动态代理和CGLIB动态代理的区别" class="headerlink" title="JDk动态代理和CGLIB动态代理的区别"></a>JDk动态代理和CGLIB动态代理的区别</h3><p>JDK和CGLIB是Java中两种实现动态代理的方式，他们的目的都是为了实现类的代理。</p>
<p><strong>1. JDK</strong></p>
<p>通过 <strong>接口和反射</strong>来实现类的动态代理（切面）</p>
<p>创建代理类开销小，实现方法开销大</p>
<p><strong>接口驱动的编程</strong></p>
<p><strong>2. CGLIB</strong></p>
<p>通过 <strong>字节码和子类继承</strong>的方式来实现动态代理( ASM 字节码生成框架)</p>
<p>创建代理类开销大，实现方法开销小（字节码操作，减少了反射的开销）</p>
<p>无法代理 final修饰的方法和变量</p>
<p><strong>没有实现接口的类</strong></p>
<p><strong>3. 在Spring AOP中的使用</strong></p>
<p>（1）JDK动态代理</p>
<p>在Spring AOP中，如果目标对象实现了接口，Spring默认使用JDK动态代理。这是因为Spring AOP的核心思想是基于接口的面向切面编程（Aspect-Oriented Programming）。</p>
<p>（2）CGLIB动态代理</p>
<p>如果目标对象没有实现任何接口，Spring AOP会自动使用CGLIB动态代理。在Spring配置中，你也可以强制使用CGLIB代理（通过设置<code>proxyTargetClass=true</code>）。</p>
<p><strong>4. 对比</strong></p>
<p><img src="https://pic1.imgdb.cn/item/67a16638d0e0a243d4fb835a.png"></p>
<h3 id="用过反射吗？如何应用反射"><a href="#用过反射吗？如何应用反射" class="headerlink" title="用过反射吗？如何应用反射"></a>用过反射吗？如何应用反射</h3><p>Java的反射是指，在运行时获取类的结构信息，（如方法，字段，构造函数），并操作对象的一种机制，反射机制提供了在运行时动态创建对象，调用方法，访问字段等功能，而无需在编译时知道这些类的具体信息。</p>
<p><strong>反射机制的优缺点</strong></p>
<ul>
<li>可以在运行时，动态的获取类的信息，不需要再编译时知道类的信息。</li>
<li>可以在运行时，动态的创建对象，不需要在编译时就知道对象的类型。</li>
<li>可以在运行时，动态的调用对象的属性和方法，动态的改变对象的行为。</li>
</ul>
<p><strong>性能</strong></p>
<p>反射操作相比直接代码调用具有更高的性能开销，因为它涉及到动态解析和方法调用</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="说说HashMap的原理"><a href="#说说HashMap的原理" class="headerlink" title="说说HashMap的原理"></a>说说HashMap的原理</h3><p>采用了数组+链表+红黑树+哈希算法的结合。</p>
<p>HashMap存储的是键值对</p>
<p>当存储数据时，通过将KV合成一个node，在Key通过hashCode获取哈希值，在通过算法将哈希值转化为桶的下标</p>
<p>下标无值，直接放入</p>
<p>下标有值，和链表的每一个key进行比较，相同覆盖，则向后比较，最后加到链表的尾部</p>
<p>JDK8以后，当链表超过8个，则转化成红黑树。</p>
<p>默认容量为16，第一次扩容通常是64，之后2倍</p>
<p>装载因子（默认0.75）</p>
<p>扩容后是采用头插法的</p>
<p>注意： 线程不安全，可以采用ConcurrentHashMap</p>
<p><strong>两种遍历方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　<span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">　　<span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> map.entrySet().iterator();</span><br><span class="line">　　<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">　　Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) iter.next();</span><br><span class="line">　　<span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">　　<span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">　　&#125;</span><br><span class="line"><span class="comment">// 效率高</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　<span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">　　<span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> map.keySet().iterator();</span><br><span class="line">　　<span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">　　<span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">　　<span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">　　&#125;</span><br><span class="line"><span class="comment">// 效率低</span></span><br></pre></td></tr></table></figure>



<h3 id="HashMap是如何扩容的"><a href="#HashMap是如何扩容的" class="headerlink" title="HashMap是如何扩容的"></a>HashMap是如何扩容的</h3><p><strong>扩容的步骤</strong></p>
<p><strong>计算新容量</strong>：当 HashMap 需要扩容时，新的容量通常是当前容量的两倍。</p>
<p><strong>创建新数组</strong>：根据新的容量创建一个新的数组（新的桶数组），其大小是旧数组的两倍。</p>
<p><strong>重新哈希并分布元素</strong>：遍历旧数组中的所有元素，将它们重新计算哈希值并插入到新数组的相应位置。这个过程被称为 rehashing。</p>
<h3 id="介绍一下Java中有那些集合类"><a href="#介绍一下Java中有那些集合类" class="headerlink" title="介绍一下Java中有那些集合类"></a>介绍一下Java中有那些集合类</h3><p>集合图解</p>
<p><img src="https://pic1.imgdb.cn/item/67a1701ad0e0a243d4fb8aa5.png"></p>
<p><strong>collection 接口</strong></p>
<p><img src="https://pic1.imgdb.cn/item/67a17073d0e0a243d4fb8b6e.png"></p>
<p><strong>map接口</strong></p>
<p><img src="https://pic1.imgdb.cn/item/67a17097d0e0a243d4fb8b96.png"></p>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="你了解Java线程池的原理吗？"><a href="#你了解Java线程池的原理吗？" class="headerlink" title="你了解Java线程池的原理吗？"></a>你了解Java线程池的原理吗？</h3><p><strong>当前一个满的情况下，会执行后一个</strong></p>
<p>核心线程池 -》 工作队列 -》 新开线程 -》 拒绝策略</p>
<p>线程池的参数：</p>
<ul>
<li>corePoolSize ： 核心线程数</li>
<li>maximumPoolSize: 最大线程数</li>
<li>workQueue： 工作队列</li>
<li>keepAliveTime： 回收线程时间</li>
<li>threadFactory： 线程工厂，表示怎么创建线程</li>
<li>Rejected： 这个接口是实现拒绝策略的，表示都满了的拒绝。</li>
</ul>
<p><img src="https://pic1.imgdb.cn/item/67a2b8edd0e0a243d4fbdbaa.png"></p>
<p>poll： 假如queue为空，并且允许关闭核心线程数 或者 我当前的线程树大于核心线程数， 回收。（或超时）</p>
<p>take： 否则， 阻塞在take中，等待queue里面的task。（自旋）</p>
<p><strong>整体结构图</strong></p>
<p><img src="https://pic1.imgdb.cn/item/67a2bbe7d0e0a243d4fbdcf7.png"></p>
<h4 id="有哪些拒绝策略？"><a href="#有哪些拒绝策略？" class="headerlink" title="有哪些拒绝策略？"></a>有哪些拒绝策略？</h4><p>拒绝策略： 线程占用满时，需要拒绝策略</p>
<p><strong>JDK内置的拒绝策略：</strong></p>
<ul>
<li>AbortPolicy（异常策略）： 直接抛出异常，阻止系统正常运行。</li>
<li>CallerRunsPolicy： 该策略直接将任务交给调用者线程运行性能极有可能会急剧下降。</li>
<li>DiscardOldsetPlicy（丢弃最老策略）： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</li>
<li>DiscardPolicy（丢弃策略）： 该策略默默然地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方式。</li>
</ul>
<p>以上拒绝策略都实现了 <code>RejectedExecutionHandle</code> 接口，若以上拒绝策略都无法满足，完全可以自己扩展。</p>
<p>注意： 默认的拒绝策略是 <code>AbortPolicy</code></p>
<h4 id="线程工厂有什么用？"><a href="#线程工厂有什么用？" class="headerlink" title="线程工厂有什么用？"></a>线程工厂有什么用？</h4><p>定制化的创建新线程的对象。</p>
<h4 id="有设置核心线程数的经验吗？"><a href="#有设置核心线程数的经验吗？" class="headerlink" title="有设置核心线程数的经验吗？"></a>有设置核心线程数的经验吗？</h4><p><strong>内核指的就是CPU核数</strong>，<strong>逻辑处理器是线程数-最大可以并行的线程数</strong></p>
<h3 id="用过哪些Java并发工具"><a href="#用过哪些Java并发工具" class="headerlink" title="用过哪些Java并发工具"></a>用过哪些Java并发工具</h3><ul>
<li>ConcurrentHashMap</li>
<li>AtomicInteger</li>
<li>Semaphore</li>
<li>CyclicBarier</li>
<li>CountDownLatch</li>
<li>BlockingQueue</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁：</p>
<p><img src="https://pic1.imgdb.cn/item/67a2c6d6d0e0a243d4fbdd90.png"></p>
<p>锁的本质：</p>
<p><img src="https://pic1.imgdb.cn/item/67a2c705d0e0a243d4fbdd95.png"></p>
<h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h3><p>compare and swap()</p>
<h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><h3 id="Synchronized-和-Reetranlock有什么区别"><a href="#Synchronized-和-Reetranlock有什么区别" class="headerlink" title="Synchronized 和 Reetranlock有什么区别"></a>Synchronized 和 Reetranlock有什么区别</h3><h3 id="volatile-关键字作用是什么？"><a href="#volatile-关键字作用是什么？" class="headerlink" title="volatile 关键字作用是什么？"></a>volatile 关键字作用是什么？</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/05/%E7%BD%91%E5%85%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/05/%E7%BD%91%E5%85%B3/" class="post-title-link" itemprop="url">网关</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-01-05 15:49:13 / 修改时间：20:07:45" itemprop="dateCreated datePublished" datetime="2025-01-05T15:49:13+08:00">2025-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h1><p><img src="https://pic1.imgdb.cn/item/677a714dd0e0a243d4ef2c43.png"></p>
<h2 id="什么是网关？"><a href="#什么是网关？" class="headerlink" title="什么是网关？"></a>什么是网关？</h2><p><strong>API网关是一个服务器，是系统的唯一入口。</strong></p>
<p>API网关封装了系统的内部架构，为每个客户端提供了一个定制的API。</p>
<p>它的职责：路由，鉴权，跨域，缓存，流量染色，访问控制，统一业务处理，发布控制，脱敏，负载均衡，接口保护（限制请求，信息脱敏，降级熔断，限流，超时时间），统一日志，统一文档。</p>
<p><strong>API网关方式的核心要点是，所有客户端和消费端都通过统一的网关接入微服务</strong>，在网关层处理所有的非业务功能，通常，网关也提供了REST、HTTP的访问API。</p>
<h2 id="网关的主要功能"><a href="#网关的主要功能" class="headerlink" title="网关的主要功能"></a>网关的主要功能</h2><p>微服务网关作为微服务后端服务的统一入口，它可以统筹管理后端服务，主要分为数据平面和控制平面：</p>
<p><strong>1. 数据平面</strong></p>
<p>数据平面主要功能是接入用户的HTTP请求和微服务被拆分后的聚合。使用微服务网关统一对外暴露后端服务的API和契约，路由和过滤功能正是网关的核心能力模块。另外，微服务网关可以实现拦截机制和专注跨横切面的功能，包括协议转换、安全认证、熔断限流、灰度发布、日志管理、流量监控等</p>
<p><strong>2. 控制平面</strong></p>
<p>控制平面主要功能是对后端服务做统一的管控和配置管理。</p>
<p><strong>3. 整体结构及其功能</strong></p>
<p><img src="https://pic1.imgdb.cn/item/677a73d5d0e0a243d4ef2caa.png"></p>
<ul>
<li><strong>路由功能</strong>：路由是微服务网关的核心能力。通过路由功能微服务网关可以将请求转发到目标微服务。在微服务架构中，网关可以结合注册中心的动态服务发现，实现对后端服务的发现，调用方只需要知道网关对外暴露的服务API就可以透明地访问后端微服务。</li>
<li><strong>负载均衡</strong>：API网关结合负载均衡技术，利用Eureka或者Consul等服务发现工具，通过轮询、指定权重、IP地址哈希等机制实现下游服务的负载均衡。</li>
<li><strong>统一鉴权</strong>：一般而言，无论对内网还是外网的接口都需要做用户身份认证，而用户认证在一些规模较大的系统中都会采用统一的单点登录（Single Sign On）系统，如果每个微服务都要对接单点登录系统，那么显然比较浪费资源且开发效率低。API网关是统一管理安全性的绝佳场所，可以将认证的部分抽取到网关层，微服务系统无须关注认证的逻辑，只关注自身业务即可。</li>
<li><strong>协议转换</strong>：API网关的一大作用在于构建异构系统，API网关作为单一入口，通过协议转换整合后台基于REST、AMQP、Dubbo等不同风格和实现技术的微服务，面向Web Mobile、开放平台等特定客户端提供统一服务。</li>
<li><strong>指标监控</strong>：网关可以统计后端服务的请求次数，并且可以实时地更新当前的流量健康状态，可以对URL粒度的服务进行延迟统计，也可以使用Hystrix Dashboard查看后端服务的流量状态及是否有熔断发生。</li>
<li><strong>限流熔断</strong>：在某些场景下需要控制客户端的访问次数和访问频率，一些高并发系统有时还会有限流的需求。在网关上可以配置一个阈值，当请求数超过阈值时就直接返回错误而不继续访问后台服务。当出现流量洪峰或者后端服务出现延迟或故障时，网关能够主动进行熔断，保护后端服务，并保持前端用户体验良好。</li>
<li><strong>黑白名单</strong>：微服务网关可以使用系统黑名单，过滤HTTP请求特征，拦截异常客户端的请求，例如DDoS攻击等侵蚀带宽或资源迫使服务中断等行为，可以在网关层面进行拦截过滤。比较常见的拦截策略是根据IP地址增加黑名单。在存在鉴权管理的路由服务中可以通过设置白名单跳过鉴权管理而直接访问后端服务资源。</li>
<li><strong>灰度发布</strong>：微服务网关可以根据HTTP请求中的特殊标记和后端服务列表元数据标识进行流量控制，实现在用户无感知的情况下完成灰度发布。</li>
<li><strong>流量染色</strong>：和灰度发布的原理相似，网关可以根据HTTP请求的Host、Head、Agent等标识对请求进行染色，有了网关的流量染色功能，我们可以对服务后续的调用链路进行跟踪，对服务延迟及服务运行状况进行进一步的链路分析。</li>
<li><strong>文档中心</strong>：网关结合Swagger，可以将后端的微服务暴露给网关，网关作为统一的入口给接口的使用方提供查看后端服务的API规范，不需要知道每一个后端微服务的Swagger地址，这样网关起到了对后端API聚合的效果。</li>
<li><strong>日志审计</strong>：微服务网关可以作为统一的日志记录和收集器，对服务URL粒度的日志请求信息和响应信息进行拦截。</li>
</ul>
<h2 id="常用网关"><a href="#常用网关" class="headerlink" title="常用网关"></a>常用网关</h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>Nginx是一个高性能的HTTP反向代理服务器，<strong>Nginx一方面可以做反向代理，另外一方面可以做静态资源服务器，接口使用Lua动态语言可以完成灵活的定制功能。</strong></p>
<h3 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h3><p>Zuul 是 Netflix 开源的一个API网关组件，它可以和 Eureka、Ribbon、Hystrix 等组件配合使用。社区活跃，融合于 SpringCloud 完整生态，是构建微服务体系前置网关服务的最佳选型之一。</p>
<p>Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能：</p>
<ul>
<li><strong>统一鉴权 + 动态路由 + 负载均衡 + 压力测试</strong></li>
<li><strong>审查与监控</strong>：与边缘位置追踪有意义的数据和统计结果，从而带来精确的生产视图。</li>
<li><strong>多区域弹性</strong>：跨越 AWS Region 进行请求路由，旨在实现 ELB（Elastic Load Balancing，弹性负载均衡）使用的多样化，以及让系统的边缘更贴近系统的使用者。</li>
</ul>
<h3 id="SpringCloudGetWay"><a href="#SpringCloudGetWay" class="headerlink" title="SpringCloudGetWay"></a>SpringCloudGetWay</h3><p>Spring Cloud Gateway 是Spring Cloud的一个全新的API网关项目，目的是为了替换掉Zuul1，它基于Spring5.0 + SpringBoot2.0 + WebFlux（基于⾼性能的Reactor模式响应式通信框架Netty，异步⾮阻塞模型）等技术开发，性能⾼于Zuul，官⽅测试，<strong>Spring Cloud GateWay是Zuul的1.6倍</strong>，旨在为微服务架构,提供⼀种简单有效的统⼀的API路由管理⽅式。</p>
<p>Spring Cloud Gateway可以与Spring Cloud Discovery Client（如Eureka）、Ribbon、Hystrix等组件配合使用，<strong>实现路由转发、负载均衡、熔断、鉴权、路径重写、⽇志监控等，并且Gateway还内置了限流过滤器，实现了限流的功能。</strong></p>
<p>整体结构如下：</p>
<p><img src="https://pic1.imgdb.cn/item/677a75b0d0e0a243d4ef2d34.png"></p>
<h3 id="Kong"><a href="#Kong" class="headerlink" title="Kong"></a>Kong</h3><p>Kong是一款基于OpenResty（Nginx + Lua模块）编写的高可用、易扩展的，由Mashape公司开源的API Gateway项目</p>
<h3 id="Traefik"><a href="#Traefik" class="headerlink" title="Traefik"></a>Traefik</h3><p>Træfɪk 是一个为了让部署微服务更加便捷而诞生的现代HTTP反向代理、负载均衡工具。它支持多种后台 (Docker, Swarm, Kubernetes, Marathon, Mesos, Consul, Etcd, Zookeeper, BoltDB, Rest API, file…) 来自动化、动态的应用它的设置。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/01/04/API%E9%89%B4%E6%9D%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/111.png">
      <meta itemprop="name" content="ZhangYuHao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhang'Blog">
      <meta itemprop="description" content="一个小人物的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zhang'Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/01/04/API%E9%89%B4%E6%9D%83/" class="post-title-link" itemprop="url">API鉴权</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-01-04 21:58:00" itemprop="dateCreated datePublished" datetime="2025-01-04T21:58:00+08:00">2025-01-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">ZhangYuHao</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
